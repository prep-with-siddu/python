# 1.2 Python Standard Library Essentials â€” Notes

> **Status**: âœ… Completed  
> **Date**: 28 February 2026

---

## 1. `datetime` Module

```python
from datetime import datetime, date, time, timedelta

# ---- datetime.datetime â€” date + time combined ----
now = datetime.now()              # 2026-02-28 14:30:00.123456
utc_now = datetime.utcnow()      # UTC time (naive â€” no timezone)

# Create specific datetime
dt = datetime(2026, 2, 28, 14, 30, 0)
print(dt.year)     # 2026
print(dt.month)    # 2
print(dt.day)      # 28
print(dt.hour)     # 14
print(dt.minute)   # 30
print(dt.second)   # 0

# ---- datetime.date â€” date only ----
today = date.today()              # 2026-02-28
d = date(2026, 2, 28)
print(d.weekday())    # 0=Mon, 6=Sun
print(d.isoformat())  # "2026-02-28"

# ---- datetime.time â€” time only ----
t = time(14, 30, 0)               # 14:30:00
print(t.hour)      # 14
print(t.minute)    # 30

# ---- timedelta â€” duration / time difference ----
delta = timedelta(days=7, hours=3, minutes=30)
future = now + delta              # 7 days 3.5 hours later
past = now - timedelta(days=30)   # 30 days ago

# Difference between two dates
diff = datetime(2026, 12, 31) - datetime(2026, 1, 1)
print(diff.days)       # 364
print(diff.total_seconds())  # Total seconds
```

---

## 2. Timezones (`pytz`, `zoneinfo`)

```python
# ---- zoneinfo (Python 3.9+ â€” USE THIS) ----
from datetime import datetime
from zoneinfo import ZoneInfo

# Timezone-aware datetime
ist = ZoneInfo("Asia/Kolkata")
utc = ZoneInfo("UTC")

now_ist = datetime.now(ist)       # Current time in IST
now_utc = datetime.now(utc)       # Current time in UTC

# Convert between timezones
dt_utc = datetime(2026, 2, 28, 9, 0, tzinfo=utc)
dt_ist = dt_utc.astimezone(ist)
print(dt_ist)   # 2026-02-28 14:30:00+05:30 (UTC+5:30)

# ---- pytz (older, still widely used) ----
# pip install pytz
import pytz

ist_tz = pytz.timezone("Asia/Kolkata")
utc_tz = pytz.UTC

# IMPORTANT: Use localize() with pytz, NOT tzinfo= in constructor!
dt = datetime(2026, 2, 28, 14, 30)
dt_ist = ist_tz.localize(dt)      # âœ… Correct
# dt_ist = datetime(2026, 2, 28, 14, 30, tzinfo=ist_tz)  # âŒ Can be wrong!

# List all timezones
print(pytz.all_timezones)
```

> ğŸ’¡ **Backend Rule**: Always store datetime in **UTC** in the database. Convert to local timezone only when displaying to users.

---

## 3. `dateutil` for Advanced Parsing

```python
# pip install python-dateutil
from dateutil import parser
from dateutil.relativedelta import relativedelta

# ---- Flexible date parsing ----
# Parses almost ANY date string format automatically!
dt1 = parser.parse("Feb 28, 2026")
dt2 = parser.parse("28/02/2026")
dt3 = parser.parse("2026-02-28T14:30:00Z")
dt4 = parser.parse("Saturday, February 28, 2026 2:30 PM")
# All produce valid datetime objects!

# ---- relativedelta â€” smarter timedelta ----
from datetime import datetime

now = datetime.now()
# Add 3 months (timedelta can't do months!)
future = now + relativedelta(months=3)
# Add 1 year and 2 months
future = now + relativedelta(years=1, months=2)
# Next Friday
from dateutil.rrule import rrule, WEEKLY, FR
```

---

## 4. `uuid` Module (Critical for Backend IDs)

```python
import uuid

# ---- UUID v4 (random â€” most common for backends) ----
id1 = uuid.uuid4()
print(id1)          # e.g., "a1b2c3d4-5678-4abc-9def-012345678901"
print(str(id1))     # String version
print(id1.hex)      # No dashes: "a1b2c3d456784abc9def012345678901"

# ---- UUID v1 (timestamp-based) ----
id2 = uuid.uuid1()  # Based on MAC address + timestamp

# ---- UUID from string ----
my_uuid = uuid.UUID("a1b2c3d4-5678-4abc-9def-012345678901")

# ---- Use as primary key in databases ----
class User:
    def __init__(self, name):
        self.id = str(uuid.uuid4())    # Unique ID
        self.name = name

# ---- Why UUID over auto-increment? ----
# âœ… No sequential IDs (security â€” can't guess next user)
# âœ… Can generate IDs client-side (offline, microservices)
# âœ… No conflicts when merging databases
# âŒ Slightly slower than integer IDs, larger storage
```

---

## 5. `hashlib` Module (Hashing)

```python
import hashlib

# ---- SHA-256 (most common) ----
text = "Hello, Sid!"
hash_obj = hashlib.sha256(text.encode("utf-8"))
print(hash_obj.hexdigest())   # 64-char hex string
# "3b0a1..."  â†’ always same output for same input

# ---- MD5 (fast but NOT secure for passwords) ----
md5_hash = hashlib.md5("hello".encode()).hexdigest()

# ---- SHA-512 ----
sha512 = hashlib.sha512("data".encode()).hexdigest()

# ---- File checksum (verify file integrity) ----
def file_checksum(filepath):
    sha256 = hashlib.sha256()
    with open(filepath, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            sha256.update(chunk)
    return sha256.hexdigest()

# ---- Password hashing (DO NOT use hashlib directly!) ----
# Use bcrypt or argon2 for passwords instead:
# pip install bcrypt
import bcrypt
password = "my_password".encode()
hashed = bcrypt.hashpw(password, bcrypt.gensalt())
# Verify:
bcrypt.checkpw(password, hashed)    # True
```

> âš ï¸ **Never use MD5/SHA for passwords!** Use `bcrypt` or `argon2` â€” they're slow on purpose (resist brute-force).

---

## 6. `secrets` Module (Secure Tokens & API Keys)

```python
import secrets

# ---- Generate secure random token ----
token = secrets.token_hex(32)       # 64-char hex string
print(token)   # "a3f8c1d2e5..."

token_url = secrets.token_urlsafe(32)  # URL-safe base64
print(token_url)   # "Xk9mR2..."

token_bytes = secrets.token_bytes(32)  # Raw bytes

# ---- Generate API keys ----
api_key = secrets.token_urlsafe(48)    # 64-char URL-safe string

# ---- Secure random integer ----
otp = secrets.randbelow(1000000)       # 0 to 999999
otp_str = f"{otp:06d}"                # Zero-padded: "042371"

# ---- Secure comparison (prevents timing attacks) ----
secrets.compare_digest("token1", "token2")   # Safe string comparison

# ---- Why secrets over random? ----
# random module â†’ predictable (NOT safe for security!)
# secrets module â†’ cryptographically secure âœ…
```

---

## 7. `subprocess` Module (Running External Commands)

```python
import subprocess

# ---- Basic usage ----
result = subprocess.run(["ls", "-la"], capture_output=True, text=True)
print(result.stdout)       # Command output
print(result.stderr)       # Error output
print(result.returncode)   # 0 = success

# ---- With shell=True (careful â€” security risk!) ----
result = subprocess.run("echo Hello", shell=True, capture_output=True, text=True)

# ---- Check for errors ----
result = subprocess.run(["python3", "script.py"], check=True)
# check=True â†’ raises CalledProcessError on non-zero exit

# ---- Timeout ----
try:
    result = subprocess.run(["long_command"], timeout=30)
except subprocess.TimeoutExpired:
    print("Command timed out!")

# ---- Pipe commands ----
ps = subprocess.Popen(["ps", "aux"], stdout=subprocess.PIPE)
grep = subprocess.run(["grep", "python"], stdin=ps.stdout, capture_output=True, text=True)
print(grep.stdout)
```

> âš ï¸ **Never use `shell=True` with user input** â€” it's a shell injection vulnerability!

---

## 8. `pickle` and `shelve` (Python Serialization)

```python
import pickle

# ---- pickle â€” serialize Python objects to bytes ----
data = {"name": "Sid", "scores": [95, 88, 92]}

# Serialize (dump)
with open("data.pkl", "wb") as f:
    pickle.dump(data, f)

# Deserialize (load)
with open("data.pkl", "rb") as f:
    loaded = pickle.load(f)
print(loaded)   # {'name': 'Sid', 'scores': [95, 88, 92]}

# ---- shelve â€” persistent dictionary ----
import shelve

with shelve.open("mydata") as db:
    db["user"] = {"name": "Sid", "age": 25}
    db["scores"] = [95, 88, 92]

with shelve.open("mydata") as db:
    print(db["user"])      # {'name': 'Sid', 'age': 25}
```

> âš ï¸ **Never unpickle untrusted data!** Pickle can execute arbitrary code. Use JSON for APIs.

---

## 9. `logging` Module Basics

```python
import logging

# ---- Basic setup ----
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)

logger = logging.getLogger(__name__)

# ---- Log levels (from lowest to highest) ----
logger.debug("Detailed info for debugging")        # 10
logger.info("General information")                  # 20
logger.warning("Something unexpected")              # 30
logger.error("Something failed")                    # 40
logger.critical("System is about to crash!")         # 50

# ---- Log to file ----
logging.basicConfig(
    filename="app.log",
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)

# ---- Log with context ----
user_id = 42
logger.info("User %s logged in", user_id)
logger.error("Failed to process order %s", order_id, exc_info=True)

# ---- Backend logging best practice ----
# Use INFO for normal operations
# Use WARNING for recoverable issues
# Use ERROR for failures
# Use DEBUG only in development
# NEVER log passwords, tokens, or sensitive data!
```

---

## 10. `collections` Module Overview

```python
from collections import (
    namedtuple, defaultdict, OrderedDict,
    Counter, deque, ChainMap
)

# ---- namedtuple â€” lightweight immutable object ----
Point = namedtuple("Point", ["x", "y"])
p = Point(3, 4)
print(p.x, p.y)   # 3, 4

User = namedtuple("User", "name age email")
u = User("Sid", 25, "sid@test.com")

# ---- defaultdict â€” dict with default value ----
dd = defaultdict(list)
dd["fruits"].append("apple")     # No KeyError!
dd["fruits"].append("banana")
print(dd)   # {'fruits': ['apple', 'banana']}

word_count = defaultdict(int)
for word in "hello world hello".split():
    word_count[word] += 1
print(word_count)   # {'hello': 2, 'world': 1}

# ---- Counter â€” count elements ----
c = Counter("abracadabra")
print(c)                    # Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})
print(c.most_common(2))     # [('a', 5), ('b', 2)]

votes = Counter(["BJP", "INC", "BJP", "BJP", "INC"])
print(votes["BJP"])          # 3

# ---- deque â€” double-ended queue (fast append/pop both ends) ----
dq = deque([1, 2, 3])
dq.appendleft(0)    # [0, 1, 2, 3]
dq.append(4)        # [0, 1, 2, 3, 4]
dq.popleft()        # 0 (fast! O(1))
dq.rotate(1)        # Rotate right by 1

# Fixed-size deque (auto-removes oldest)
recent = deque(maxlen=5)
for i in range(10):
    recent.append(i)
print(list(recent))  # [5, 6, 7, 8, 9] â€” only last 5

# ---- OrderedDict (preserves insertion order) ----
# Note: Regular dict preserves order since Python 3.7+
# OrderedDict still useful for move_to_end(), equality checks
od = OrderedDict()
od["a"] = 1
od["b"] = 2
od.move_to_end("a")   # Move 'a' to end

# ---- ChainMap â€” combine multiple dicts ----
defaults = {"color": "red", "size": "medium"}
user_prefs = {"color": "blue"}
config = ChainMap(user_prefs, defaults)
print(config["color"])   # "blue" (user pref wins)
print(config["size"])    # "medium" (falls back to default)
```

---

## 11. `dataclasses` Quick Intro

```python
from dataclasses import dataclass, field
from typing import Optional

# ---- Basic dataclass (auto-generates __init__, __repr__, __eq__) ----
@dataclass
class User:
    name: str
    age: int
    email: str
    active: bool = True    # Default value

user = User("Sid", 25, "sid@test.com")
print(user)        # User(name='Sid', age=25, email='sid@test.com', active=True)
print(user.name)   # "Sid"

# Equality works automatically
user2 = User("Sid", 25, "sid@test.com")
print(user == user2)   # True

# ---- Frozen (immutable) ----
@dataclass(frozen=True)
class Point:
    x: float
    y: float

p = Point(3, 4)
# p.x = 5    # âŒ FrozenInstanceError

# ---- With default factory ----
@dataclass
class Config:
    name: str
    tags: list = field(default_factory=list)    # âœ… Use field() for mutable defaults
    # tags: list = []    # âŒ NEVER do this â€” shared mutable default!

# ---- Post-init processing ----
@dataclass
class Rectangle:
    width: float
    height: float
    area: float = field(init=False)    # Not in __init__
    
    def __post_init__(self):
        self.area = self.width * self.height

r = Rectangle(5, 3)
print(r.area)   # 15.0
```

---

## 12. `socket` Module Basics

```python
import socket

# ---- TCP Client ----
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(("httpbin.org", 80))
request = "GET /get HTTP/1.1\r\nHost: httpbin.org\r\n\r\n"
client.send(request.encode())
response = client.recv(4096)
print(response.decode())
client.close()

# ---- TCP Server (basic) ----
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
server.bind(("0.0.0.0", 8080))
server.listen(5)

print("Server listening on port 8080...")
while True:
    conn, addr = server.accept()
    print(f"Connection from {addr}")
    data = conn.recv(1024)
    conn.send(b"HTTP/1.1 200 OK\r\n\r\nHello!")
    conn.close()

# ---- Get IP info ----
hostname = socket.gethostname()
ip = socket.gethostbyname(hostname)
print(f"Host: {hostname}, IP: {ip}")

# ---- Check if port is open ----
def is_port_open(host, port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(2)
    result = sock.connect_ex((host, port))
    sock.close()
    return result == 0

print(is_port_open("google.com", 80))    # True
```

> ğŸ’¡ You rarely write raw sockets in backend work â€” frameworks like FastAPI/Flask handle this. But understanding it helps debug networking issues.

---

## ğŸ”— Quick Reference

```python
# ---- datetime ----
from datetime import datetime, timedelta
now = datetime.now()
future = now + timedelta(days=7)

# ---- timezone ----
from zoneinfo import ZoneInfo
dt_ist = datetime.now(ZoneInfo("Asia/Kolkata"))

# ---- uuid ----
import uuid
id = str(uuid.uuid4())

# ---- hashing ----
import hashlib
h = hashlib.sha256("data".encode()).hexdigest()

# ---- secrets ----
import secrets
token = secrets.token_urlsafe(32)

# ---- logging ----
import logging
logger = logging.getLogger(__name__)
logger.info("Message")

# ---- collections ----
from collections import defaultdict, Counter, deque
dd = defaultdict(list)
c = Counter("hello")

# ---- dataclass ----
from dataclasses import dataclass
@dataclass
class User:
    name: str
    age: int
```

---

> ğŸ“ **Next up**: 1.3 Variables & Data Types
