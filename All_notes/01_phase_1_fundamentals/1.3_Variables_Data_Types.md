# 1.3 Variables & Data Types â€” Notes

> **Status**: âœ… Completed  
> **Date**: 28 February 2026

---

## 1. Variables and Naming Conventions

```python
# ---- Variables â€” just labels pointing to objects ----
name = "Sid"          # str
age = 25              # int
pi = 3.14159          # float
is_active = True      # bool

# ---- Naming conventions (PEP 8 â€” snake_case) ----
user_name = "Sid"           # âœ… snake_case for variables
MAX_RETRIES = 3             # âœ… UPPER_SNAKE for constants
UserModel = "model"         # âœ… PascalCase for classes (not here though)
_private_var = "hidden"     # âœ… Single underscore = "private" (convention)
__mangled = "name mangled"  # âœ… Double underscore = name mangling in classes

# âŒ DON'T
# userName = "Sid"          # camelCase â€” not Pythonic
# 1name = "invalid"         # Cannot start with digit
# my-var = "invalid"        # Hyphens not allowed
# class = "reserved"        # Reserved keywords not allowed

# ---- Multiple assignment ----
a, b, c = 1, 2, 3
x = y = z = 0            # All point to same object
first, *rest = [1, 2, 3, 4, 5]   # first=1, rest=[2,3,4,5]

# ---- Swap variables ----
a, b = b, a    # Pythonic swap (no temp variable needed!)
```

---

## 2. `int`, `float`, `complex`

```python
# ---- int â€” unlimited precision integers ----
x = 42
big = 999_999_999_999_999    # Underscores for readability
binary = 0b1010              # 10 in binary
octal = 0o17                 # 15 in octal
hexval = 0xFF                # 255 in hex

print(type(x))       # <class 'int'>

# ---- float â€” 64-bit double precision ----
pi = 3.14159
scientific = 2.5e10          # 25000000000.0
tiny = 1.5e-4                # 0.00015

# âš ï¸ Float precision issues!
print(0.1 + 0.2)             # 0.30000000000000004  (NOT 0.3!)
print(0.1 + 0.2 == 0.3)      # False!

# Fix: use round() or math.isclose()
import math
math.isclose(0.1 + 0.2, 0.3)  # True

# Special float values
float("inf")     # Positive infinity
float("-inf")    # Negative infinity
float("nan")     # Not a Number

# ---- complex ----
z = 3 + 4j
print(z.real)    # 3.0
print(z.imag)    # 4.0
print(abs(z))    # 5.0 (magnitude)
```

---

## 3. `Decimal` Type (CRITICAL for Money)

```python
from decimal import Decimal, ROUND_HALF_UP, getcontext

# ---- Why Decimal? Float loses precision! ----
print(0.1 + 0.2)                    # 0.30000000000000004 âŒ
print(Decimal("0.1") + Decimal("0.2"))   # 0.3 âœ…

# ---- Always create from STRING, not float ----
price = Decimal("99.99")       # âœ… Correct
# Decimal(0.1)                 # âŒ Still imprecise!

# ---- Arithmetic ----
total = Decimal("99.99") * 3
print(total)    # 299.97

tax = total * Decimal("0.18")
print(tax)      # 53.9946

# ---- Rounding ----
rounded = tax.quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)
print(rounded)  # 53.99

# ---- Set precision globally ----
getcontext().prec = 10

# ---- Backend money pattern ----
class Money:
    def __init__(self, amount: str, currency: str = "INR"):
        self.amount = Decimal(amount)
        self.currency = currency
    
    def __repr__(self):
        return f"â‚¹{self.amount:.2f}"

price = Money("1499.99")
print(price)   # â‚¹1499.99
```

> ğŸ’¡ **Rule**: ALWAYS use `Decimal` for financial/money calculations in backend. Never `float`.

---

## 4. `str` â€” Strings

```python
# ---- Creation ----
s1 = "Hello"
s2 = 'World'
s3 = """Multi-line
string"""
s4 = r"C:\new\path"     # Raw string (no escape processing)

# ---- f-strings (Python 3.6+ â€” preferred!) ----
name = "Sid"
age = 25
print(f"Name: {name}, Age: {age}")
print(f"Next year: {age + 1}")
print(f"Price: {99.5:.2f}")       # "Price: 99.50"
print(f"{'Sid':>10}")             # "       Sid" (right-aligned)
print(f"{'Sid':<10}")             # "Sid       " (left-aligned)
print(f"{'Sid':^10}")             # "   Sid    " (center-aligned)
print(f"{1000000:,}")             # "1,000,000" (comma separator)

# ---- Slicing ----
s = "Hello, World!"
print(s[0])       # 'H'
print(s[-1])      # '!'
print(s[0:5])     # 'Hello'
print(s[7:])      # 'World!'
print(s[::-1])    # '!dlroW ,olleH' (reversed)
print(s[::2])     # 'Hlo ol!'  (every 2nd char)

# ---- Common methods ----
"hello".upper()           # "HELLO"
"HELLO".lower()           # "hello"
"  hello  ".strip()       # "hello"
"hello world".split()     # ["hello", "world"]
", ".join(["a", "b"])     # "a, b"
"hello".replace("l", "r") # "herro"
"hello".find("ll")        # 2 (index, -1 if not found)
"hello".count("l")        # 2
"hello".startswith("he")  # True
"hello".endswith("lo")    # True
"hello".isdigit()         # False
"42".isdigit()            # True
"hello".isalpha()         # True
```

---

## 5. `bool` â€” Truthy / Falsy

```python
# ---- Truthy and Falsy values ----
# Falsy (evaluate to False):
bool(0)          # False
bool(0.0)        # False
bool("")         # False
bool([])         # False
bool({})         # False
bool(set())      # False
bool(None)       # False
bool(False)      # False

# Everything else is Truthy:
bool(1)          # True
bool(-1)         # True
bool("hello")    # True
bool([1, 2])     # True
bool({"a": 1})   # True

# ---- Used in conditions ----
items = []
if not items:
    print("List is empty")    # âœ… Pythonic

# âŒ Don't do this:
# if len(items) == 0:          # Not Pythonic
# if items == []:              # Not Pythonic

# ---- bool is subclass of int ----
print(True + True)    # 2
print(True * 10)      # 10
print(sum([True, False, True, True]))  # 3 (counts True values)
```

---

## 6. `None` Type

```python
# None = absence of value (like null in other languages)
result = None
print(type(result))    # <class 'NoneType'>

# ---- Check for None with 'is', not == ----
if result is None:       # âœ… Correct
    print("No result")

# if result == None:     # âŒ Works but not Pythonic

# ---- Common uses ----
def find_user(user_id):
    if user_id == 1:
        return {"name": "Sid"}
    return None              # User not found

# Default parameters
def greet(name=None):
    if name is None:
        name = "Guest"
    return f"Hello, {name}"
```

---

## 7. `bytes` and `bytearray`

```python
# ---- bytes (immutable) ----
b = b"Hello"              # bytes literal
print(b[0])               # 72 (ASCII code for 'H')
print(type(b))            # <class 'bytes'>

# String â†” Bytes conversion
text = "Hello, Sid!"
encoded = text.encode("utf-8")     # str â†’ bytes
decoded = encoded.decode("utf-8")  # bytes â†’ str

# ---- bytearray (mutable bytes) ----
ba = bytearray(b"Hello")
ba[0] = 74    # Change 'H' to 'J'
print(ba)     # bytearray(b'Jello')

# ---- When you need bytes ----
# - File I/O in binary mode: open("file", "rb")
# - Network sockets
# - Cryptography
# - Image/audio processing
# - Database BLOBs
```

---

## 8. Type Conversion

```python
# ---- Explicit conversion ----
int("42")          # 42
int(3.99)          # 3 (truncates, doesn't round!)
float("3.14")      # 3.14
str(42)            # "42"
str(3.14)          # "3.14"
bool(1)            # True
bool("")           # False
list("hello")      # ['h', 'e', 'l', 'l', 'o']
tuple([1, 2, 3])   # (1, 2, 3)
set([1, 2, 2, 3])  # {1, 2, 3}

# ---- Pitfalls ----
# int("3.14")      # âŒ ValueError! Use int(float("3.14"))
# int("hello")     # âŒ ValueError!

# ---- Safe conversion ----
def safe_int(value, default=0):
    try:
        return int(value)
    except (ValueError, TypeError):
        return default

safe_int("42")       # 42
safe_int("hello")    # 0
safe_int(None)       # 0
```

---

## 9. `type()` and `isinstance()`

```python
# ---- type() â€” exact type ----
print(type(42))          # <class 'int'>
print(type("hello"))     # <class 'str'>
print(type([1, 2]))      # <class 'list'>

# Check exact type
print(type(42) == int)   # True
print(type(True) == int) # True! (bool is subclass of int)

# ---- isinstance() â€” checks inheritance too (PREFERRED) ----
print(isinstance(42, int))           # True
print(isinstance(True, int))         # True (bool inherits from int)
print(isinstance(True, bool))        # True
print(isinstance("hi", (str, int)))  # True (check multiple types)

# ---- isinstance is BETTER than type() ----
class Animal:
    pass

class Dog(Animal):
    pass

dog = Dog()
print(type(dog) == Animal)       # False âŒ (misses inheritance)
print(isinstance(dog, Animal))   # True âœ… (checks inheritance chain)
```

---

## 10. Dynamic vs Static Typing

```python
# ---- Python is DYNAMICALLY typed ----
x = 42          # x is int
x = "hello"     # x is now str â€” no error!
x = [1, 2, 3]   # x is now list

# Variable is just a label â€” it can point to anything

# ---- Static typing (Java, C++, Go) ----
# int x = 42;
# x = "hello";   // âŒ Compile error!

# ---- Type hints (optional in Python) ----
name: str = "Sid"
age: int = 25
# Python ignores these at runtime â€” they're for tools like mypy
```

---

## 11. Mutable vs Immutable (VERY Important!)

```python
# ---- Immutable â€” cannot be changed after creation ----
# int, float, str, tuple, frozenset, bytes, bool, None

s = "hello"
# s[0] = "H"    # âŒ TypeError! Strings are immutable
s = "Hello"      # Creates NEW string, old "hello" is garbage collected

t = (1, 2, 3)
# t[0] = 99     # âŒ TypeError! Tuples are immutable

# ---- Mutable â€” CAN be changed ----
# list, dict, set, bytearray

lst = [1, 2, 3]
lst[0] = 99      # âœ… [99, 2, 3]

d = {"a": 1}
d["b"] = 2       # âœ… {"a": 1, "b": 2}

# ---- THE BIG GOTCHA: Mutable default arguments! ----
# âŒ WRONG â€” shared mutable default
def add_item(item, items=[]):
    items.append(item)
    return items

print(add_item("a"))   # ['a']
print(add_item("b"))   # ['a', 'b'] â† BUG! Same list!

# âœ… CORRECT â€” use None
def add_item(item, items=None):
    if items is None:
        items = []
    items.append(item)
    return items

# ---- Mutable objects in functions ----
def modify(lst):
    lst.append(4)    # Modifies the ORIGINAL list!

my_list = [1, 2, 3]
modify(my_list)
print(my_list)   # [1, 2, 3, 4] â† Original changed!

# ---- Copy to prevent mutation ----
import copy
original = [[1, 2], [3, 4]]
shallow = original.copy()        # Shallow copy
deep = copy.deepcopy(original)   # Deep copy (nested objects too)

shallow[0].append(99)
print(original)   # [[1, 2, 99], [3, 4]] â† Shallow copy shares inner lists!
print(deep)       # [[1, 2], [3, 4]]     â† Deep copy is independent âœ…
```

### Mutability Cheat Sheet

| Type | Mutable? | Hashable? | Can be dict key? |
|------|----------|-----------|-------------------|
| `int` | âŒ Immutable | âœ… | âœ… |
| `float` | âŒ Immutable | âœ… | âœ… |
| `str` | âŒ Immutable | âœ… | âœ… |
| `tuple` | âŒ Immutable | âœ…* | âœ…* |
| `frozenset` | âŒ Immutable | âœ… | âœ… |
| `bool` | âŒ Immutable | âœ… | âœ… |
| `list` | âœ… Mutable | âŒ | âŒ |
| `dict` | âœ… Mutable | âŒ | âŒ |
| `set` | âœ… Mutable | âŒ | âŒ |

*Tuple is hashable only if all its elements are hashable.

---

## ğŸ”— Quick Reference

```python
# Types
x: int = 42
y: float = 3.14
s: str = "hello"
b: bool = True
n = None
money = Decimal("99.99")     # For financial calculations

# Type checking
type(x)                      # <class 'int'>
isinstance(x, int)           # True (preferred!)

# Conversion
int("42"), float("3.14"), str(42), bool(0)

# Mutability
# Immutable: int, float, str, tuple, frozenset, bytes
# Mutable:   list, dict, set, bytearray

# Copy
import copy
shallow = obj.copy()
deep = copy.deepcopy(obj)
```

---

> ğŸ“ **Next up**: 1.4 Operators
