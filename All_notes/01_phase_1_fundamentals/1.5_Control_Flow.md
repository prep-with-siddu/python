# 1.5 Control Flow ‚Äî Notes

> **Status**: ‚úÖ Completed  
> **Date**: 28 February 2026

---

## 1. `if`, `elif`, `else`

```python
age = 25

# ---- Basic if-elif-else ----
if age >= 18:
    print("Adult")
elif age >= 13:
    print("Teenager")
else:
    print("Child")

# ---- No braces! Python uses INDENTATION (4 spaces) ----

# ---- Multiple conditions ----
score = 85
if score >= 90:
    grade = "A"
elif score >= 80:
    grade = "B"
elif score >= 70:
    grade = "C"
elif score >= 60:
    grade = "D"
else:
    grade = "F"

print(f"Grade: {grade}")   # B

# ---- with logical operators ----
user_age = 25
has_id = True

if user_age >= 18 and has_id:
    print("Can enter")

if not has_id:
    print("ID required")
```

---

## 2. Nested Conditions

```python
score = 85
attendance = 90

if score >= 80:
    if attendance >= 75:
        print("Pass with distinction")
    else:
        print("Score good but attendance low")
else:
    if attendance >= 75:
        print("Attendance good but need better score")
    else:
        print("Need improvement in both")

# ‚úÖ BETTER: Flatten nested conditions when possible
if score >= 80 and attendance >= 75:
    print("Pass with distinction")
elif score >= 80:
    print("Score good but attendance low")
elif attendance >= 75:
    print("Attendance good but need better score")
else:
    print("Need improvement in both")

# ‚úÖ Guard clause pattern (early return ‚Äî great for functions!)
def process_user(user):
    if user is None:
        return "No user"
    if not user.is_active:
        return "User inactive"
    if user.age < 18:
        return "Too young"
    
    # Main logic here ‚Äî no deep nesting!
    return f"Processing {user.name}"
```

---

## 3. Ternary Operator (One-line if-else)

```python
# ---- Syntax: value_if_true IF condition ELSE value_if_false ----
age = 25
status = "Adult" if age >= 18 else "Minor"
print(status)   # "Adult"

# ---- Practical examples ----
x = -5
abs_x = x if x >= 0 else -x    # Manual abs()

name = ""
display = name if name else "Anonymous"

# ---- In f-strings ----
score = 85
print(f"Result: {'Pass' if score >= 60 else 'Fail'}")

# ---- Nested ternary (avoid ‚Äî hard to read!) ----
x = 15
result = "high" if x > 20 else "medium" if x > 10 else "low"
# Better to use if-elif-else for 3+ conditions
```

---

## 4. `match-case` (Python 3.10+ Structural Pattern Matching)

```python
# ---- Basic pattern matching ----
command = "quit"

match command:
    case "start":
        print("Starting...")
    case "stop":
        print("Stopping...")
    case "quit" | "exit":    # Multiple patterns
        print("Goodbye!")
    case _:                  # Default (like else)
        print("Unknown command")

# ---- Match with values ----
status_code = 404

match status_code:
    case 200:
        print("OK")
    case 301 | 302:
        print("Redirect")
    case 404:
        print("Not Found")
    case 500:
        print("Server Error")
    case code if 400 <= code < 500:    # Guard condition
        print(f"Client Error: {code}")
    case _:
        print(f"Unknown: {status_code}")

# ---- Match with structure (POWERFUL!) ----
point = (3, 4)

match point:
    case (0, 0):
        print("Origin")
    case (x, 0):
        print(f"On x-axis at {x}")
    case (0, y):
        print(f"On y-axis at {y}")
    case (x, y):
        print(f"Point at ({x}, {y})")

# ---- Match with dict-like patterns ----
event = {"type": "click", "x": 100, "y": 200}

match event:
    case {"type": "click", "x": x, "y": y}:
        print(f"Click at ({x}, {y})")
    case {"type": "keypress", "key": key}:
        print(f"Key pressed: {key}")

# ---- Match with class patterns ----
class Point:
    __match_args__ = ("x", "y")
    def __init__(self, x, y):
        self.x = x
        self.y = y

p = Point(10, 20)

match p:
    case Point(x=0, y=0):
        print("Origin")
    case Point(x, y) if x == y:
        print(f"On diagonal at {x}")
    case Point(x, y):
        print(f"Point({x}, {y})")

# ---- API response handling ----
response = {"status": "error", "code": 422, "errors": ["Invalid email"]}

match response:
    case {"status": "success", "data": data}:
        process_data(data)
    case {"status": "error", "code": 401}:
        redirect_to_login()
    case {"status": "error", "code": code, "errors": errors}:
        print(f"Error {code}: {errors}")
```

---

## 5. Walrus Operator `:=` (Python 3.8+)

Assign and use a value in the **same expression**.

```python
# ---- Without walrus ----
line = input("Enter: ")
while line != "quit":
    print(f"You said: {line}")
    line = input("Enter: ")

# ---- With walrus ‚úÖ ----
while (line := input("Enter: ")) != "quit":
    print(f"You said: {line}")

# ---- In if statements ----
data = [1, 2, 3, 4, 5]

# Without walrus
length = len(data)
if length > 3:
    print(f"List has {length} items")

# With walrus
if (n := len(data)) > 3:
    print(f"List has {n} items")

# ---- In list comprehensions ----
results = [y for x in range(10) if (y := x ** 2) > 20]
# [25, 36, 49, 64, 81]

# ---- Reading chunks from file ----
with open("data.txt", "r") as f:
    while (chunk := f.read(1024)):
        process(chunk)

# ---- Regex match and use ----
import re
text = "Order #12345"
if (match := re.search(r"#(\d+)", text)):
    print(f"Order number: {match.group(1)}")
```

---

## 6. Scope Rules ‚Äî LEGB

Python looks for variables in this order: **L ‚Üí E ‚Üí G ‚Üí B**

```python
# ---- LEGB Rule ----
# L = Local      ‚Äî inside current function
# E = Enclosing  ‚Äî inside enclosing (outer) function
# G = Global     ‚Äî module level
# B = Built-in   ‚Äî Python built-ins (print, len, etc.)

x = "global"             # G ‚Äî Global

def outer():
    x = "enclosing"      # E ‚Äî Enclosing
    
    def inner():
        x = "local"      # L ‚Äî Local
        print(x)         # "local" (L found first)
    
    inner()
    print(x)             # "enclosing" (E scope)

outer()
print(x)                 # "global" (G scope)

# ---- Visualized ----
"""
+----------------------------------+
| Built-in (print, len, range...)  |
|  +----------------------------+  |
|  | Global (module level)      |  |
|  |  +----------------------+  |  |
|  |  | Enclosing (outer fn) |  |  |
|  |  |  +----------------+  |  |  |
|  |  |  | Local (fn body)|  |  |  |
|  |  |  +----------------+  |  |  |
|  |  +----------------------+  |  |
|  +----------------------------+  |
+----------------------------------+
"""
```

---

## 7. `global` and `nonlocal` Keywords

```python
# ---- global ‚Äî modify module-level variable from inside function ----
count = 0

def increment():
    global count       # Without this ‚Üí UnboundLocalError!
    count += 1

increment()
increment()
print(count)   # 2

# ---- nonlocal ‚Äî modify enclosing function's variable ----
def counter():
    count = 0
    
    def increment():
        nonlocal count    # Modify the enclosing 'count'
        count += 1
        return count
    
    return increment

c = counter()
print(c())    # 1
print(c())    # 2
print(c())    # 3

# ---- Why avoid global? ----
# ‚ùå Makes code hard to test and debug
# ‚ùå Creates hidden dependencies
# ‚ùå Not thread-safe
# ‚úÖ Use function parameters and return values instead
# ‚úÖ Use classes for shared state

# ---- Common mistake ----
x = 10
def test():
    # print(x)    # ‚ùå UnboundLocalError if you also assign x below!
    x = 20        # This makes Python treat x as LOCAL for entire function
    print(x)

# Fix: Either use 'global x' or don't assign to x in the function
```

---

## üîó Quick Reference

```python
# if-elif-else
if condition:
    ...
elif another:
    ...
else:
    ...

# Ternary
result = "yes" if condition else "no"

# match-case (3.10+)
match value:
    case pattern1:
        ...
    case _:
        ...  # default

# Walrus operator (3.8+)
if (n := len(data)) > 10:
    print(n)

# Scope: L ‚Üí E ‚Üí G ‚Üí B
# global x     ‚Üí access module-level x
# nonlocal x   ‚Üí access enclosing function's x
```

---

> üìù **Next up**: 1.6 Loops & Built-in Functions
