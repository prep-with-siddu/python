# 1.7 Strings Deep Dive ‚Äî Notes

> **Status**: ‚úÖ Completed  
> **Date**: 28 February 2026

---

## 1. String Methods

```python
s = "  Hello, World!  "

# ---- Case ----
"hello".upper()          # "HELLO"
"HELLO".lower()          # "hello"
"hello world".title()    # "Hello World"
"hello world".capitalize()  # "Hello world"
"Hello".swapcase()       # "hELLO"
"hello".casefold()       # "hello" (aggressive lowercase, good for comparison)

# ---- Whitespace ----
s.strip()                # "Hello, World!"    (both sides)
s.lstrip()               # "Hello, World!  "  (left only)
s.rstrip()               # "  Hello, World!"  (right only)
"---hello---".strip("-") # "hello" (strip specific chars)

# ---- Split & Join ----
"hello world python".split()           # ['hello', 'world', 'python']
"a,b,c,d".split(",")                  # ['a', 'b', 'c', 'd']
"a,b,c,d".split(",", maxsplit=2)      # ['a', 'b', 'c,d']
"line1\nline2\nline3".splitlines()     # ['line1', 'line2', 'line3']

", ".join(["a", "b", "c"])            # "a, b, c"
"-".join(["2026", "02", "28"])         # "2026-02-28"
"".join(["H", "e", "l", "l", "o"])    # "Hello"

# ---- Search ----
"hello world".find("world")       # 6 (index, -1 if not found)
"hello world".index("world")      # 6 (raises ValueError if not found!)
"hello world".rfind("o")          # 7 (search from right)
"hello world hello".count("hello") # 2

# ---- Check ----
"hello".startswith("he")       # True
"hello".endswith("lo")         # True
"hello".startswith(("he", "Hi"))  # True (tuple of prefixes)

# ---- Replace ----
"hello world".replace("world", "Python")   # "hello Python"
"aaa".replace("a", "b", 2)                # "bba" (max 2 replacements)

# ---- Checking content ----
"42".isdigit()          # True
"hello".isalpha()       # True
"hello42".isalnum()     # True
"   ".isspace()         # True
"Hello World".istitle() # True
"HELLO".isupper()       # True
"hello".islower()       # True

# ---- Padding / Alignment ----
"42".zfill(5)             # "00042"
"hello".ljust(10)         # "hello     "
"hello".rjust(10)         # "     hello"
"hello".center(11)        # "   hello   "
"hello".center(11, "-")   # "---hello---"
```

---

## 2. String Formatting

```python
name = "Sid"
age = 25
price = 99.5

# ---- f-strings (Python 3.6+ ‚Äî PREFERRED!) ----
print(f"Name: {name}, Age: {age}")
print(f"Next year: {age + 1}")
print(f"Price: ‚Çπ{price:.2f}")              # ‚Çπ99.50
print(f"Large: {1000000:,}")               # 1,000,000
print(f"Percent: {0.857:.1%}")             # 85.7%
print(f"Binary: {42:b}")                    # 101010
print(f"Hex: {255:x}")                      # ff
print(f"Octal: {8:o}")                      # 10

# Alignment
print(f"{'left':<15}|")       # "left           |"
print(f"{'right':>15}|")      # "          right|"
print(f"{'center':^15}|")     # "    center     |"
print(f"{'padded':*^15}")     # "****padded*****"

# Expression inside f-string
print(f"{2 ** 10 = }")        # "2 ** 10 = 1024" (Python 3.8+)
print(f"{name!r}")            # "'Sid'" (repr)
print(f"{name!s}")            # "Sid" (str ‚Äî default)

# Multiline f-string
message = (
    f"Hello {name},\n"
    f"Your age is {age}.\n"
    f"Price: ‚Çπ{price:.2f}"
)

# ---- .format() method ----
"Hello, {}!".format("Sid")                  # "Hello, Sid!"
"Name: {name}, Age: {age}".format(name="Sid", age=25)
"{0} and {1} and {0}".format("a", "b")     # "a and b and a"

# ---- % formatting (old, avoid) ----
"Hello, %s! Age: %d" % ("Sid", 25)
"Price: %.2f" % 99.5
```

### Format Spec Mini-Language

| Syntax | Meaning | Example | Result |
|--------|---------|---------|--------|
| `:.2f` | 2 decimal float | `f"{3.14159:.2f}"` | `3.14` |
| `:,` | Comma separator | `f"{1000000:,}"` | `1,000,000` |
| `:.1%` | Percentage | `f"{0.85:.1%}"` | `85.0%` |
| `:>10` | Right align (width 10) | `f"{'hi':>10}"` | `"        hi"` |
| `:<10` | Left align | `f"{'hi':<10}"` | `"hi        "` |
| `:^10` | Center align | `f"{'hi':^10}"` | `"    hi    "` |
| `:05d` | Zero-pad integer | `f"{42:05d}"` | `00042` |
| `:b` | Binary | `f"{10:b}"` | `1010` |
| `:x` | Hex | `f"{255:x}"` | `ff` |

---

## 3. Raw Strings and Escape Characters

```python
# ---- Escape characters ----
print("Hello\nWorld")     # Newline
print("Tab\there")        # Tab
print("She said \"hi\"")  # Escaped quotes
print("Path: C:\\Users")  # Escaped backslash
print("Line1\nLine2")     # \n = newline
print("Col1\tCol2")       # \t = tab

# Common escapes:
# \n  ‚Äî newline
# \t  ‚Äî tab
# \\  ‚Äî backslash
# \"  ‚Äî double quote
# \'  ‚Äî single quote
# \0  ‚Äî null character
# \r  ‚Äî carriage return

# ---- Raw strings (no escaping) ----
path = r"C:\Users\new\folder"     # Backslashes treated literally
print(path)   # C:\Users\new\folder

# Great for:
# - Windows file paths
# - Regex patterns
import re
pattern = r"\d{3}-\d{4}"    # Raw string for regex
```

---

## 4. String Immutability

```python
s = "Hello"

# ‚ùå Cannot modify in-place
# s[0] = "h"    # TypeError: 'str' object does not support item assignment

# ‚úÖ Create new string
s = "h" + s[1:]     # "hello"
s = s.replace("H", "h")

# ---- Why immutable? ----
# 1. Strings can be dict keys and set elements (hashable)
# 2. Thread-safe (no concurrent modification issues)
# 3. Python can optimize: same value ‚Üí same object (interning)

a = "hello"
b = "hello"
print(a is b)    # True! Python reuses the same object

# ---- String concatenation performance ----
# ‚ùå Slow (creates new string each time)
result = ""
for i in range(10000):
    result += str(i)

# ‚úÖ Fast (join list at the end)
parts = []
for i in range(10000):
    parts.append(str(i))
result = "".join(parts)

# ‚úÖ Even faster: list comprehension
result = "".join(str(i) for i in range(10000))
```

---

## 5. String Encoding

```python
# ---- encode() ‚Äî str ‚Üí bytes ----
text = "Hello, Sid! üáÆüá≥"
encoded = text.encode("utf-8")
print(encoded)    # b'Hello, Sid! \xf0\x9f\x87\xae\xf0\x9f\x87\xb3'
print(type(encoded))  # <class 'bytes'>

# ---- decode() ‚Äî bytes ‚Üí str ----
decoded = encoded.decode("utf-8")
print(decoded)    # "Hello, Sid! üáÆüá≥"

# ---- Common encodings ----
# utf-8   ‚Äî universal, supports all characters ‚úÖ (default!)
# ascii   ‚Äî English only (0-127)
# latin-1 ‚Äî Western European
# utf-16  ‚Äî Windows internal

# ---- Encoding errors ----
"Hello üáÆüá≥".encode("ascii")          # ‚ùå UnicodeEncodeError!
"Hello üáÆüá≥".encode("ascii", errors="ignore")   # b'Hello '
"Hello üáÆüá≥".encode("ascii", errors="replace")  # b'Hello ????'

# ---- Check byte length (important for APIs/DBs) ----
text = "‡§®‡§Æ‡§∏‡•ç‡§§‡•á"    # Hindi
print(len(text))                    # 6 characters
print(len(text.encode("utf-8")))    # 18 bytes! (Hindi = 3 bytes/char)

# ---- Backend: always use UTF-8 ----
# response headers: Content-Type: application/json; charset=utf-8
# database: utf8mb4 (MySQL) or UTF8 (PostgreSQL)
```

---

## 6. Regular Expressions Basics (`re` module)

```python
import re

text = "Contact: sid@test.com or support@company.org, call 9876543210"

# ---- re.search() ‚Äî find first match ----
match = re.search(r"\d+", text)
if match:
    print(match.group())   # "9876543210"
    print(match.start())   # Starting index
    print(match.end())     # Ending index
    print(match.span())    # (start, end)

# ---- re.findall() ‚Äî find ALL matches ----
emails = re.findall(r"[\w.]+@[\w.]+", text)
print(emails)   # ['sid@test.com', 'support@company.org']

numbers = re.findall(r"\d+", "abc 123 def 456")
print(numbers)  # ['123', '456']

# ---- re.match() ‚Äî match at START of string only ----
result = re.match(r"\d+", "123abc")   # Matches "123"
result = re.match(r"\d+", "abc123")   # None (not at start)

# ---- re.sub() ‚Äî find and replace ----
cleaned = re.sub(r"\d+", "***", "Call 9876 or 1234")
print(cleaned)   # "Call *** or ***"

# Censor email
censored = re.sub(r"([\w.]+)@([\w.]+)", r"***@\2", text)
# "Contact: ***@test.com or ***@company.org, call 9876543210"

# ---- re.split() ‚Äî split by pattern ----
parts = re.split(r"[,;]\s*", "a, b;c,  d; e")
print(parts)   # ['a', 'b', 'c', 'd', 'e']

# ---- re.compile() ‚Äî pre-compile for reuse ----
email_pattern = re.compile(r"[\w.+-]+@[\w-]+\.[\w.]+")
emails = email_pattern.findall(text)
is_email = email_pattern.match("test@example.com")
```

### Common Regex Patterns
```python
# ---- Character classes ----
# \d  ‚Äî digit [0-9]
# \D  ‚Äî non-digit
# \w  ‚Äî word char [a-zA-Z0-9_]
# \W  ‚Äî non-word char
# \s  ‚Äî whitespace (\n, \t, space)
# \S  ‚Äî non-whitespace
# .   ‚Äî any char (except newline)

# ---- Quantifiers ----
# *   ‚Äî 0 or more
# +   ‚Äî 1 or more
# ?   ‚Äî 0 or 1
# {3} ‚Äî exactly 3
# {2,5} ‚Äî 2 to 5
# {3,}  ‚Äî 3 or more

# ---- Anchors ----
# ^   ‚Äî start of string
# $   ‚Äî end of string
# \b  ‚Äî word boundary

# ---- Practical patterns ----
# Indian phone:  r"[6-9]\d{9}"
# Email:         r"[\w.+-]+@[\w-]+\.[\w.]+"
# URL:           r"https?://[\w./\-?=&#]+"
# Date:          r"\d{4}-\d{2}-\d{2}"
# IP address:    r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"
# PIN code:      r"\b\d{6}\b"
```

---

## 7. Regex Advanced Patterns

```python
import re

# ---- Groups ‚Äî capture parts of the match ----
match = re.search(r"(\d{4})-(\d{2})-(\d{2})", "Date: 2026-02-28")
if match:
    print(match.group(0))   # "2026-02-28" (full match)
    print(match.group(1))   # "2026" (year)
    print(match.group(2))   # "02"   (month)
    print(match.group(3))   # "28"   (day)
    print(match.groups())   # ('2026', '02', '28')

# ---- Named groups ----
match = re.search(
    r"(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})",
    "Date: 2026-02-28"
)
if match:
    print(match.group("year"))    # "2026"
    print(match.groupdict())      # {'year': '2026', 'month': '02', 'day': '28'}

# ---- Non-capturing group ----
# (?:...) ‚Äî group without capturing
pattern = r"(?:http|https)://(\S+)"
match = re.search(pattern, "Visit https://example.com")
print(match.group(1))    # "example.com" (only captured group)

# ---- Lookahead (?=...) ‚Äî match if followed by ----
# Find numbers followed by "px"
re.findall(r"\d+(?=px)", "width: 100px, height: 200px, weight: 50kg")
# ['100', '200']

# ---- Negative lookahead (?!...) ----
# Find numbers NOT followed by "px"
re.findall(r"\d+(?!px)", "100px 200px 50kg")
# ['10', '20', '50'] ‚Äî careful with partial matches!

# ---- Lookbehind (?<=...) ----
# Find text after "price: "
re.findall(r"(?<=price: )\d+", "price: 500, price: 1000")
# ['500', '1000']

# ---- Greedy vs Lazy ----
text = "<b>hello</b> and <b>world</b>"

# Greedy (default) ‚Äî matches as MUCH as possible
re.findall(r"<b>.*</b>", text)
# ['<b>hello</b> and <b>world</b>']  ‚Üê One big match!

# Lazy (?) ‚Äî matches as LITTLE as possible
re.findall(r"<b>.*?</b>", text)
# ['<b>hello</b>', '<b>world</b>']  ‚Üê Two separate matches!

# ---- Flags ----
re.search(r"hello", "Hello World", re.IGNORECASE)    # re.I
re.findall(r"^line", "line1\nline2", re.MULTILINE)    # re.M
re.search(r"hello .+ world", "hello\n world", re.DOTALL)  # re.S (. matches \n)

# ---- Verbose regex (readable!) ----
pattern = re.compile(r"""
    (?P<year>\d{4})    # Year
    -
    (?P<month>\d{2})   # Month
    -
    (?P<day>\d{2})     # Day
""", re.VERBOSE)

# ---- Email validation (production-level) ----
email_regex = re.compile(r"""
    ^                       # Start
    [a-zA-Z0-9._%+-]+      # Local part
    @                       # @ symbol
    [a-zA-Z0-9.-]+         # Domain
    \.                      # Dot
    [a-zA-Z]{2,}           # TLD (at least 2 chars)
    $                       # End
""", re.VERBOSE)

print(bool(email_regex.match("sid@test.com")))     # True
print(bool(email_regex.match("invalid@.com")))     # False
```

---

## üîó Quick Reference

```python
# String methods
s.upper()  .lower()  .strip()  .split()  .join()
s.find()  .replace()  .count()  .startswith()  .endswith()
s.isdigit()  .isalpha()  .isalnum()

# Formatting
f"Name: {name}, Price: {price:.2f}"
f"{'text':>10}"     # Right-align
f"{num:,}"          # Comma separator

# Encoding
text.encode("utf-8")     # str ‚Üí bytes
data.decode("utf-8")     # bytes ‚Üí str

# Regex
import re
re.search(pattern, text)     # First match
re.findall(pattern, text)    # All matches
re.sub(pattern, repl, text)  # Replace
re.split(pattern, text)      # Split
re.compile(pattern)          # Pre-compile
```

---

> üìù **Next up**: 1.8 Date & Time (Backend Essential)
