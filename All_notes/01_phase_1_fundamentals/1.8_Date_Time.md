# 1.8 Date & Time (Backend Essential) ‚Äî Notes

> **Status**: ‚úÖ Completed  
> **Date**: 28 February 2026

---

## 1. `datetime.datetime`, `datetime.date`, `datetime.time`

```python
from datetime import datetime, date, time

# ---- datetime (date + time) ----
now = datetime.now()                # Current local datetime
print(now)                          # 2026-02-28 14:30:45.123456
print(now.year, now.month, now.day) # 2026 2 28
print(now.hour, now.minute, now.second)  # 14 30 45
print(now.microsecond)              # 123456
print(now.weekday())                # 0-6 (0=Monday, 6=Sunday)
print(now.isoweekday())             # 1-7 (1=Monday, 7=Sunday)
print(now.timestamp())              # Unix timestamp (float)

# Create specific datetime
dt = datetime(2026, 2, 28, 14, 30, 0)
print(dt)    # 2026-02-28 14:30:00

# ---- date (date only) ----
today = date.today()                # 2026-02-28
d = date(2026, 12, 31)
print(d.year, d.month, d.day)       # 2026 12 31
print(d.isoformat())                # "2026-12-31"
print(d.toordinal())                # Days since Jan 1, year 1

# Create from string
d = date.fromisoformat("2026-02-28")   # Python 3.7+

# ---- time (time only) ----
t = time(14, 30, 45)               # 14:30:45
print(t.hour, t.minute, t.second)  # 14 30 45
print(t.isoformat())               # "14:30:45"

# Create from datetime
current_time = datetime.now().time()
current_date = datetime.now().date()

# ---- Combine date + time ----
d = date(2026, 2, 28)
t = time(14, 30)
dt = datetime.combine(d, t)        # 2026-02-28 14:30:00
```

---

## 2. `timedelta` for Date Arithmetic

```python
from datetime import datetime, timedelta

now = datetime.now()

# ---- Create timedeltas ----
one_day = timedelta(days=1)
one_week = timedelta(weeks=1)
duration = timedelta(days=3, hours=5, minutes=30, seconds=15)
# Also: milliseconds, microseconds

# ---- Add / Subtract ----
tomorrow = now + timedelta(days=1)
yesterday = now - timedelta(days=1)
next_week = now + timedelta(weeks=1)
three_months_approx = now + timedelta(days=90)   # Approximate!

# ---- Difference between dates ----
future = datetime(2026, 12, 31, 23, 59, 59)
diff = future - now
print(diff.days)              # Number of full days
print(diff.seconds)           # Remaining seconds (after full days)
print(diff.total_seconds())   # TOTAL seconds (most useful!)

# ---- Practical: age calculation ----
birth = date(2001, 5, 15)
today = date.today()
age_days = (today - birth).days
age_years = age_days // 365    # Approximate
print(f"Age: ~{age_years} years")

# ---- Practical: deadline check ----
deadline = datetime(2026, 3, 15, 17, 0, 0)
remaining = deadline - datetime.now()
if remaining.total_seconds() > 0:
    hours = remaining.total_seconds() / 3600
    print(f"Time remaining: {hours:.1f} hours")
else:
    print("Deadline passed!")

# ---- Compare datetimes ----
dt1 = datetime(2026, 1, 1)
dt2 = datetime(2026, 12, 31)
print(dt1 < dt2)    # True
print(dt1 == dt2)   # False
```

> ‚ö†Ô∏è `timedelta` has no `months` or `years` parameter! Use `dateutil.relativedelta` for those.

---

## 3. `strftime()` and `strptime()` (Formatting & Parsing)

```python
from datetime import datetime

now = datetime.now()

# ---- strftime() ‚Äî datetime ‚Üí string ----
print(now.strftime("%Y-%m-%d"))           # "2026-02-28"
print(now.strftime("%d/%m/%Y"))           # "28/02/2026"
print(now.strftime("%B %d, %Y"))          # "February 28, 2026"
print(now.strftime("%I:%M %p"))           # "02:30 PM"
print(now.strftime("%H:%M:%S"))           # "14:30:45"
print(now.strftime("%A, %B %d, %Y"))      # "Saturday, February 28, 2026"
print(now.strftime("%Y-%m-%dT%H:%M:%S"))  # "2026-02-28T14:30:45" (ISO-like)

# ---- strptime() ‚Äî string ‚Üí datetime ----
dt = datetime.strptime("28/02/2026", "%d/%m/%Y")
print(dt)    # 2026-02-28 00:00:00

dt = datetime.strptime("2026-02-28 14:30:00", "%Y-%m-%d %H:%M:%S")
print(dt)    # 2026-02-28 14:30:00

dt = datetime.strptime("Feb 28, 2026", "%b %d, %Y")
print(dt)    # 2026-02-28 00:00:00
```

### Format Codes Cheat Sheet

| Code | Meaning | Example |
|------|---------|---------|
| `%Y` | Year (4-digit) | 2026 |
| `%y` | Year (2-digit) | 26 |
| `%m` | Month (01-12) | 02 |
| `%B` | Month name | February |
| `%b` | Month abbrev | Feb |
| `%d` | Day (01-31) | 28 |
| `%A` | Weekday name | Saturday |
| `%a` | Weekday abbrev | Sat |
| `%H` | Hour 24h (00-23) | 14 |
| `%I` | Hour 12h (01-12) | 02 |
| `%M` | Minute (00-59) | 30 |
| `%S` | Second (00-59) | 45 |
| `%p` | AM/PM | PM |
| `%f` | Microsecond | 123456 |
| `%z` | UTC offset | +0530 |
| `%Z` | Timezone name | IST |
| `%j` | Day of year | 059 |
| `%w` | Weekday (0=Sun) | 6 |

---

## 4. Timezone-Aware vs Naive Datetime

```python
from datetime import datetime

# ---- Naive datetime (NO timezone info) ----
naive = datetime.now()
print(naive.tzinfo)    # None ‚Äî DANGEROUS in backends!

# ---- Aware datetime (HAS timezone info) ----
from datetime import timezone
utc_aware = datetime.now(timezone.utc)
print(utc_aware.tzinfo)   # UTC

# ---- Why it matters ----
# Naive: 2026-02-28 14:30:00          (Which timezone? IST? UTC? PST?)
# Aware: 2026-02-28 14:30:00+05:30    (Clearly IST!)

# ‚ö†Ô∏è Cannot compare naive and aware datetimes!
# naive < utc_aware   # ‚ùå TypeError!

# ---- Backend Rule ----
# 1. ALWAYS use timezone-aware datetimes
# 2. ALWAYS store in UTC in the database
# 3. Convert to user's timezone ONLY when displaying
```

---

## 5. `zoneinfo` Module (Python 3.9+)

```python
from datetime import datetime
from zoneinfo import ZoneInfo

# ---- Create timezone-aware datetime ----
utc = ZoneInfo("UTC")
ist = ZoneInfo("Asia/Kolkata")
est = ZoneInfo("America/New_York")
jst = ZoneInfo("Asia/Tokyo")

now_utc = datetime.now(utc)
now_ist = datetime.now(ist)

print(now_utc)   # 2026-02-28 09:00:00+00:00
print(now_ist)   # 2026-02-28 14:30:00+05:30

# ---- Convert between timezones ----
meeting_utc = datetime(2026, 3, 1, 10, 0, tzinfo=utc)
meeting_ist = meeting_utc.astimezone(ist)
meeting_est = meeting_utc.astimezone(est)

print(f"UTC:  {meeting_utc}")    # 2026-03-01 10:00:00+00:00
print(f"IST:  {meeting_ist}")    # 2026-03-01 15:30:00+05:30
print(f"EST:  {meeting_est}")    # 2026-03-01 05:00:00-05:00

# ---- Get all available timezones ----
from zoneinfo import available_timezones
indian_tz = [tz for tz in available_timezones() if "Kolkata" in tz]
print(indian_tz)   # ['Asia/Kolkata']

# ---- Replace timezone (attach to naive) ----
naive = datetime(2026, 2, 28, 14, 30)
aware = naive.replace(tzinfo=ist)
print(aware)    # 2026-02-28 14:30:00+05:30
```

---

## 6. `pytz` Library

```python
# pip install pytz
import pytz
from datetime import datetime

# ---- List timezones ----
print(pytz.all_timezones)       # All timezones
print(pytz.common_timezones)    # Common ones

ist = pytz.timezone("Asia/Kolkata")
utc = pytz.UTC

# ---- IMPORTANT: Use localize() with pytz! ----
naive = datetime(2026, 2, 28, 14, 30)

# ‚úÖ Correct way with pytz
aware = ist.localize(naive)
print(aware)    # 2026-02-28 14:30:00+05:30

# ‚ùå WRONG way (can cause subtle bugs!)
# wrong = datetime(2026, 2, 28, 14, 30, tzinfo=ist)

# ---- Convert ----
utc_time = aware.astimezone(utc)
print(utc_time)    # 2026-02-28 09:00:00+00:00

# ---- Current time in UTC ----
now_utc = datetime.now(pytz.UTC)
```

> üí° For new projects, prefer `zoneinfo` (Python 3.9+) over `pytz`. No extra install needed!

---

## 7. ISO 8601 Format (API Standard)

```python
from datetime import datetime, timezone

# ---- ISO 8601 ‚Äî the standard for APIs and databases ----
# Format: YYYY-MM-DDTHH:MM:SS.ffffffZ or YYYY-MM-DDTHH:MM:SS+HH:MM

now = datetime.now(timezone.utc)

# ---- Create ISO string ----
iso_str = now.isoformat()
print(iso_str)    # "2026-02-28T09:00:00+00:00"

# Date only
from datetime import date
print(date.today().isoformat())   # "2026-02-28"

# ---- Parse ISO string ----
dt = datetime.fromisoformat("2026-02-28T14:30:00+05:30")    # Python 3.7+
print(dt)

# Python 3.11+: handles "Z" suffix
# dt = datetime.fromisoformat("2026-02-28T09:00:00Z")

# For older Python, handle "Z" manually:
iso = "2026-02-28T09:00:00Z"
dt = datetime.fromisoformat(iso.replace("Z", "+00:00"))

# ---- API response format ----
# Always return ISO 8601 in APIs:
response = {
    "user": "Sid",
    "created_at": now.isoformat(),       # "2026-02-28T09:00:00+00:00"
    "updated_at": now.isoformat(),
}

# ---- Common ISO formats ----
# "2026-02-28"                    ‚Äî Date only
# "2026-02-28T14:30:00"          ‚Äî Local (naive)
# "2026-02-28T14:30:00+05:30"    ‚Äî IST
# "2026-02-28T09:00:00+00:00"    ‚Äî UTC
# "2026-02-28T09:00:00Z"         ‚Äî UTC (Z = Zulu = UTC)
```

---

## 8. Unix Timestamps

```python
from datetime import datetime, timezone
import time

# ---- What is a Unix timestamp? ----
# Seconds since January 1, 1970 00:00:00 UTC (the "epoch")

# ---- Get current timestamp ----
ts = time.time()           # 1772352000.123456
ts = datetime.now(timezone.utc).timestamp()

# ---- Convert datetime ‚Üí timestamp ----
dt = datetime(2026, 2, 28, 14, 30, 0, tzinfo=timezone.utc)
ts = dt.timestamp()
print(ts)    # 1772284200.0

# ---- Convert timestamp ‚Üí datetime ----
dt = datetime.fromtimestamp(1772284200, tz=timezone.utc)
print(dt)    # 2026-02-28 14:30:00+00:00

# ‚ö†Ô∏è ALWAYS specify timezone when converting!
# datetime.fromtimestamp(ts)           # ‚ùå Returns local time (ambiguous)
# datetime.fromtimestamp(ts, tz=utc)   # ‚úÖ Returns UTC

# ---- Timestamp in milliseconds (JavaScript style) ----
ts_ms = int(datetime.now(timezone.utc).timestamp() * 1000)
print(ts_ms)    # 1772352000123

# Convert back
dt = datetime.fromtimestamp(ts_ms / 1000, tz=timezone.utc)

# ---- Practical: API rate limiting ----
last_request_ts = time.time()
# ... later ...
if time.time() - last_request_ts < 1.0:
    raise Exception("Rate limited! Wait 1 second")
```

---

## 9. `dateutil.parser` for Flexible Parsing

```python
# pip install python-dateutil
from dateutil import parser
from dateutil.relativedelta import relativedelta

# ---- Auto-parse almost ANY date format ----
parser.parse("Feb 28, 2026")              # 2026-02-28 00:00:00
parser.parse("28/02/2026")                # 2026-02-28 00:00:00
parser.parse("2026-02-28T14:30:00Z")      # 2026-02-28 14:30:00+00:00
parser.parse("Saturday, February 28, 2026 2:30 PM")
parser.parse("28 Feb 2026 14:30")
parser.parse("Feb 28th, 2026")

# Handle ambiguous dates
parser.parse("01/02/2026", dayfirst=True)   # Feb 1 (DD/MM)
parser.parse("01/02/2026", dayfirst=False)  # Jan 2 (MM/DD)

# ---- relativedelta ‚Äî months and years arithmetic ----
from datetime import datetime

now = datetime.now()

# Add months (timedelta CAN'T do this!)
three_months = now + relativedelta(months=3)
next_year = now + relativedelta(years=1)
complex_delta = now + relativedelta(years=1, months=2, days=15)

# Calculate exact age
birth = datetime(2001, 5, 15)
today = datetime.now()
age = relativedelta(today, birth)
print(f"{age.years} years, {age.months} months, {age.days} days")

# Last day of month
from dateutil.relativedelta import relativedelta
first_of_next_month = datetime(2026, 2, 1) + relativedelta(months=1)
last_of_this_month = first_of_next_month - relativedelta(days=1)
print(last_of_this_month)   # 2026-02-28
```

---

## 10. UTC as Standard for Backend Storage

```python
from datetime import datetime, timezone
from zoneinfo import ZoneInfo

# ---- THE GOLDEN RULES ----
# 1. Store ALL datetimes in UTC in the database
# 2. Convert to user's timezone ONLY when displaying
# 3. Accept user input in their timezone, convert to UTC immediately

# ---- Store in UTC ----
def store_event(event_name, user_tz_str="Asia/Kolkata"):
    now_utc = datetime.now(timezone.utc)   # Always UTC!
    # Save to database: now_utc
    return {"event": event_name, "created_at": now_utc.isoformat()}

# ---- Display in user's timezone ----
def display_time(utc_dt_str, user_tz_str="Asia/Kolkata"):
    utc_dt = datetime.fromisoformat(utc_dt_str)
    user_tz = ZoneInfo(user_tz_str)
    local_dt = utc_dt.astimezone(user_tz)
    return local_dt.strftime("%B %d, %Y %I:%M %p %Z")

# Example flow:
# User in IST creates event at 2:30 PM IST
# ‚Üí Store as 9:00 AM UTC in database
# ‚Üí Display as 2:30 PM IST to Indian user
# ‚Üí Display as 9:00 AM GMT to UK user
# ‚Üí Display as 4:00 AM EST to US East Coast user

# ---- Why UTC? ----
# ‚úÖ No ambiguity (one source of truth)
# ‚úÖ Daylight saving time doesn't affect stored data
# ‚úÖ Easy to convert to ANY timezone
# ‚úÖ Sorting/comparing works correctly
# ‚úÖ International users see correct local times
```

### Backend Date/Time Checklist
```
‚úÖ Always store in UTC
‚úÖ Always use timezone-aware datetimes
‚úÖ Use ISO 8601 for API responses
‚úÖ Use zoneinfo/pytz for conversions
‚úÖ Use dateutil for flexible parsing
‚úÖ Use Decimal for time-based billing
‚ùå Never use naive datetimes in production
‚ùå Never store in local timezone
‚ùå Never hardcode timezone offsets (+5:30)
```

---

## üîó Quick Reference

```python
from datetime import datetime, date, time, timedelta, timezone
from zoneinfo import ZoneInfo

# Current time
now = datetime.now()                     # Local (naive)
now_utc = datetime.now(timezone.utc)    # UTC (aware) ‚úÖ

# Create
dt = datetime(2026, 2, 28, 14, 30)
d = date(2026, 2, 28)

# Arithmetic
tomorrow = now + timedelta(days=1)
diff = dt2 - dt1

# Format
dt.strftime("%Y-%m-%d %H:%M:%S")    # ‚Üí string
datetime.strptime("2026-02-28", "%Y-%m-%d")  # string ‚Üí datetime

# ISO 8601
dt.isoformat()                       # "2026-02-28T14:30:00+00:00"
datetime.fromisoformat(iso_str)      # Parse ISO string

# Timezone
ist = ZoneInfo("Asia/Kolkata")
dt_ist = dt_utc.astimezone(ist)

# Timestamp
ts = dt.timestamp()                  # datetime ‚Üí unix
dt = datetime.fromtimestamp(ts, tz=timezone.utc)  # unix ‚Üí datetime

# dateutil
from dateutil import parser
parser.parse("Feb 28, 2026")        # Flexible parsing
from dateutil.relativedelta import relativedelta
dt + relativedelta(months=3)         # Add months
```

---

> üìù **Phase 1 Complete!** Next: Phase 2 ‚Äî Data Structures
