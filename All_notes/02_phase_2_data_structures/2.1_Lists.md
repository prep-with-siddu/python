# 2.1 Lists â€” Notes

> **Status**: âœ… Completed  
> **Date**: 28 February 2026

---

## 1. Creating Lists, Indexing, Slicing

### Creating Lists
```python
# Empty list
empty = []
empty = list()

# List with values
fruits = ["apple", "banana", "cherry"]
numbers = [1, 2, 3, 4, 5]
mixed = [1, "hello", 3.14, True, None]     # Can hold different types
nested = [[1, 2], [3, 4], [5, 6]]          # List of lists
```

### Indexing (Accessing Elements)
```python
fruits = ["apple", "banana", "cherry", "date", "elderberry"]

# Positive indexing (0-based, from left)
print(fruits[0])     # apple
print(fruits[2])     # cherry
print(fruits[4])     # elderberry

# Negative indexing (from right)
print(fruits[-1])    # elderberry  (last element)
print(fruits[-2])    # date        (second from last)
print(fruits[-5])    # apple       (same as [0])

# IndexError if out of range
# print(fruits[10])  # IndexError: list index out of range
```

### Slicing (`list[start:stop:step]`)
```python
nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Basic slicing â€” start is INCLUDED, stop is EXCLUDED
print(nums[2:5])      # [2, 3, 4]
print(nums[:4])        # [0, 1, 2, 3]        (from beginning)
print(nums[6:])        # [6, 7, 8, 9]        (to end)
print(nums[:])         # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  (full copy)

# With step
print(nums[0:10:2])   # [0, 2, 4, 6, 8]     (every 2nd element)
print(nums[1:10:3])   # [1, 4, 7]            (every 3rd, starting from 1)
print(nums[::3])       # [0, 3, 6, 9]        (every 3rd)

# Negative step (reverse)
print(nums[::-1])      # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]  (reversed!)
print(nums[7:2:-1])    # [7, 6, 5, 4, 3]     (backward from 7 to 3)

# Slicing never causes IndexError
print(nums[5:100])     # [5, 6, 7, 8, 9]     (stops at end gracefully)
```

### Modifying via Slicing
```python
nums = [0, 1, 2, 3, 4, 5]
nums[1:4] = [10, 20, 30]    # Replace elements 1-3
print(nums)                   # [0, 10, 20, 30, 4, 5]

nums[2:4] = [99]             # Replace 2 elements with 1
print(nums)                   # [0, 10, 99, 4, 5]

nums[1:1] = [7, 8, 9]       # Insert without removing
print(nums)                   # [0, 7, 8, 9, 10, 99, 4, 5]
```

> ğŸ’¡ **Slicing creates a NEW list** (shallow copy). `nums[2:5]` doesn't modify the original.

---

## 2. List Methods

```python
fruits = ["apple", "banana"]

# ---- Adding Elements ----
fruits.append("cherry")        # Add to END â†’ ["apple", "banana", "cherry"]
fruits.extend(["date", "fig"]) # Add MULTIPLE to end â†’ [..., "date", "fig"]
fruits.insert(1, "avocado")    # Insert at INDEX 1 â†’ ["apple", "avocado", "banana", ...]

# append vs extend
fruits.append([1, 2])         # Adds LIST AS ONE ELEMENT â†’ [..., [1, 2]]
fruits.extend([1, 2])         # Adds EACH ELEMENT â†’ [..., 1, 2]

# ---- Removing Elements ----
fruits = ["apple", "banana", "cherry", "banana", "date"]

fruits.remove("banana")       # Remove FIRST occurrence â†’ ["apple", "cherry", "banana", "date"]
# fruits.remove("mango")     # ValueError if not found!

popped = fruits.pop()         # Remove & return LAST â†’ "date"
popped = fruits.pop(1)        # Remove & return at INDEX 1 â†’ "cherry"

fruits.clear()                # Remove ALL â†’ []

# ---- Searching ----
fruits = ["apple", "banana", "cherry", "banana"]

print(fruits.index("banana"))     # 1 (first occurrence)
# print(fruits.index("mango"))   # ValueError if not found!
print(fruits.index("banana", 2)) # 3 (search from index 2)

print(fruits.count("banana"))    # 2 (how many times it appears)
print(fruits.count("mango"))     # 0

# ---- Sorting ----
nums = [3, 1, 4, 1, 5, 9, 2, 6]

nums.sort()                      # In-place, ascending â†’ [1, 1, 2, 3, 4, 5, 6, 9]
nums.sort(reverse=True)          # In-place, descending â†’ [9, 6, 5, 4, 3, 2, 1, 1]
nums.reverse()                   # Reverse in-place â†’ [1, 1, 2, 3, 4, 5, 6, 9]

# ---- Copying ----
original = [1, 2, 3]
copy = original.copy()           # Shallow copy (same as original[:])
copy.append(4)
print(original)                  # [1, 2, 3] â€” original unchanged!
```

### Methods Cheat Sheet
| Method | Action | Returns | Modifies Original? |
|--------|--------|---------|-------------------|
| `append(x)` | Add x to end | `None` | âœ… Yes |
| `extend(iterable)` | Add all items from iterable | `None` | âœ… Yes |
| `insert(i, x)` | Insert x at index i | `None` | âœ… Yes |
| `remove(x)` | Remove first x | `None` | âœ… Yes |
| `pop(i)` | Remove & return at index i | The removed item | âœ… Yes |
| `clear()` | Remove all | `None` | âœ… Yes |
| `index(x)` | Find position of x | Index (int) | âŒ No |
| `count(x)` | Count occurrences of x | Count (int) | âŒ No |
| `sort()` | Sort in-place | `None` | âœ… Yes |
| `reverse()` | Reverse in-place | `None` | âœ… Yes |
| `copy()` | Shallow copy | New list | âŒ No |

> ğŸš¨ **Common mistake**: `sort()` returns `None`, not a sorted list! Don't do `x = mylist.sort()`.

---

## 3. List Comprehensions

A **concise way** to create lists. Replaces `for` + `append` pattern.

```python
# Traditional way
squares = []
for x in range(10):
    squares.append(x ** 2)

# âœ… List comprehension â€” same thing in ONE line
squares = [x ** 2 for x in range(10)]
# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# Syntax: [expression FOR variable IN iterable]
```

### With Condition (Filtering)
```python
# [expression FOR var IN iterable IF condition]

# Even numbers only
evens = [x for x in range(20) if x % 2 == 0]
# [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

# Words longer than 3 characters
words = ["hi", "hello", "hey", "world", "ok"]
long_words = [w for w in words if len(w) > 3]
# ['hello', 'world']

# Filter + transform
upper_long = [w.upper() for w in words if len(w) > 3]
# ['HELLO', 'WORLD']
```

### With If-Else (Ternary in Comprehension)
```python
# [expr_if_true IF condition ELSE expr_if_false FOR var IN iterable]

nums = [1, 2, 3, 4, 5, 6]
labels = ["even" if x % 2 == 0 else "odd" for x in nums]
# ['odd', 'even', 'odd', 'even', 'odd', 'even']
```

### Real-World Backend Examples
```python
# Extract IDs from API response
users = [{"id": 1, "name": "Sid"}, {"id": 2, "name": "Rahul"}, {"id": 3, "name": "Amit"}]
user_ids = [u["id"] for u in users]
# [1, 2, 3]

# Filter active users
active_users = [u for u in users if u.get("is_active", True)]

# Clean input data
raw_emails = ["  Sid@Mail.COM  ", "RAHUL@gmail.com", "  amit@yahoo.IN"]
clean_emails = [email.strip().lower() for email in raw_emails]
# ['sid@mail.com', 'rahul@gmail.com', 'amit@yahoo.in']
```

> ğŸ’¡ **Rule**: If the comprehension gets too complex (more than ~80 chars), use a regular `for` loop instead. Readability > cleverness.

---

## 4. Nested List Comprehensions

```python
# Flatten a 2D list
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# Traditional way
flat = []
for row in matrix:
    for num in row:
        flat.append(num)

# âœ… Nested comprehension
flat = [num for row in matrix for num in row]
# [1, 2, 3, 4, 5, 6, 7, 8, 9]
# Read as: for row in matrix â†’ for num in row â†’ num

# Create a 2D matrix
matrix = [[i * 3 + j for j in range(3)] for i in range(3)]
# [[0, 1, 2], [3, 4, 5], [6, 7, 8]]

# Transpose a matrix
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
transposed = [[row[i] for row in matrix] for i in range(3)]
# [[1, 4, 7], [2, 5, 8], [3, 6, 9]]

# Multiplication table
table = [[i * j for j in range(1, 6)] for i in range(1, 6)]
# [[1,2,3,4,5], [2,4,6,8,10], [3,6,9,12,15], [4,8,12,16,20], [5,10,15,20,25]]
```

> ğŸ’¡ Nested comprehensions can be hard to read. If it needs >2 levels of nesting, use regular loops.

---

## 5. `sorted()` vs `.sort()` â€” Key Parameter, Lambda Sorting

### `sort()` vs `sorted()`
```python
nums = [3, 1, 4, 1, 5, 9]

# .sort() â€” modifies in-place, returns None
result = nums.sort()
print(result)     # None
print(nums)       # [1, 1, 3, 4, 5, 9]  (modified!)

# sorted() â€” returns NEW list, original unchanged
nums = [3, 1, 4, 1, 5, 9]
result = sorted(nums)
print(result)     # [1, 1, 3, 4, 5, 9]  (new list)
print(nums)       # [3, 1, 4, 1, 5, 9]  (unchanged!)
```

| Feature | `.sort()` | `sorted()` |
|---------|----------|-----------|
| Returns | `None` | New sorted list |
| Modifies original | âœ… Yes | âŒ No |
| Works on | Lists only | Any iterable |
| Memory | No extra | Creates new list |

### Key Parameter â€” Custom Sorting
```python
# Sort strings by length
words = ["banana", "fig", "cherry", "apple", "date"]
print(sorted(words, key=len))
# ['fig', 'date', 'apple', 'banana', 'cherry']

# Sort by last character
print(sorted(words, key=lambda w: w[-1]))
# ['banana', 'apple', 'date', 'fig', 'cherry']

# Sort dicts by a field (VERY common in backend!)
users = [
    {"name": "Sid", "age": 25},
    {"name": "Amit", "age": 22},
    {"name": "Rahul", "age": 30},
]

by_age = sorted(users, key=lambda u: u["age"])
# [{'name': 'Amit', 'age': 22}, {'name': 'Sid', 'age': 25}, {'name': 'Rahul', 'age': 30}]

by_name = sorted(users, key=lambda u: u["name"])
# Sorted alphabetically by name

# Reverse sort
by_age_desc = sorted(users, key=lambda u: u["age"], reverse=True)

# Sort by multiple keys (age ascending, then name ascending)
users2 = [
    {"name": "Sid", "age": 25},
    {"name": "Amit", "age": 25},
    {"name": "Rahul", "age": 22},
]
result = sorted(users2, key=lambda u: (u["age"], u["name"]))
# [{'name': 'Rahul', 'age': 22}, {'name': 'Amit', 'age': 25}, {'name': 'Sid', 'age': 25}]
```

### Using `operator.itemgetter` (Faster than Lambda)
```python
from operator import itemgetter

users = [{"name": "Sid", "age": 25}, {"name": "Amit", "age": 22}]
by_age = sorted(users, key=itemgetter("age"))     # Same as lambda u: u["age"]

# Multiple keys
by_age_name = sorted(users, key=itemgetter("age", "name"))
```

> ğŸ’¡ **Backend tip**: `sorted()` with `key` is how you implement custom ordering in API responses when you can't do it at the database level.

---

## 6. Shallow Copy vs Deep Copy

### The Problem
```python
# Simple assignment is NOT a copy â€” both point to the SAME object!
a = [1, 2, 3]
b = a              # b is just another name for the same list
b.append(4)
print(a)           # [1, 2, 3, 4]  ğŸ˜± a was modified too!
print(a is b)      # True â€” they're the same object
```

### Shallow Copy â€” Copies the outer list, NOT nested objects
```python
import copy

# 3 ways to shallow copy
original = [1, 2, [3, 4]]
copy1 = original.copy()          # Method 1: .copy()
copy2 = original[:]              # Method 2: slice
copy3 = list(original)           # Method 3: list()
copy4 = copy.copy(original)      # Method 4: copy module

# Shallow copy works fine for simple lists
simple = [1, 2, 3]
clone = simple.copy()
clone.append(4)
print(simple)    # [1, 2, 3]  âœ… original unchanged
print(clone)     # [1, 2, 3, 4]

# BUT fails for nested lists!
original = [1, 2, [3, 4]]
shallow = original.copy()
shallow[2].append(5)
print(original)    # [1, 2, [3, 4, 5]]  ğŸ˜± nested list was shared!
print(shallow)     # [1, 2, [3, 4, 5]]
```

### Deep Copy â€” Copies EVERYTHING, including nested objects
```python
import copy

original = [1, 2, [3, 4]]
deep = copy.deepcopy(original)
deep[2].append(5)
print(original)    # [1, 2, [3, 4]]      âœ… completely independent!
print(deep)        # [1, 2, [3, 4, 5]]
```

### Visual Comparison
```
Shallow Copy:                    Deep Copy:
original â†’ [1, 2, â—]           original â†’ [1, 2, â—]
                  â†“                              â†“
shallow  â†’ [1, 2, â—]           deep     â†’ [1, 2, â—]
                  â†“                              â†“
            [3, 4]  â† SHARED!            [3, 4]   [3, 4]  â† INDEPENDENT!
```

| | Shallow Copy | Deep Copy |
|--|-------------|-----------|
| Copies outer list | âœ… Yes | âœ… Yes |
| Copies nested objects | âŒ No (shared) | âœ… Yes (independent) |
| Speed | Fast | Slower |
| Use when | Flat lists, simple data | Nested/complex structures |

> ğŸš¨ **Interview classic**: "What's the difference between shallow copy and deep copy?" â€” Know this cold.

---

## 7. List as Stack and Queue

### Stack (LIFO â€” Last In, First Out)
```python
# Use append() and pop() â€” both O(1) at the end

stack = []
stack.append("a")     # Push
stack.append("b")     # Push
stack.append("c")     # Push
print(stack)           # ['a', 'b', 'c']

top = stack.pop()      # Pop last
print(top)             # 'c'
print(stack)           # ['a', 'b']

# Peek (look without removing)
print(stack[-1])       # 'b'
```

### Queue (FIFO â€” First In, First Out)
```python
# âŒ Using list as queue â€” pop(0) is O(n)! Slow!
queue = []
queue.append("a")      # Enqueue
queue.append("b")
queue.append("c")
first = queue.pop(0)   # Dequeue â†’ O(n) because all elements shift!
print(first)            # 'a'

# âœ… Use collections.deque instead â€” O(1) for both ends
from collections import deque
queue = deque()
queue.append("a")       # Enqueue (right)
queue.append("b")
queue.append("c")
first = queue.popleft() # Dequeue (left) â†’ O(1)!
print(first)             # 'a'
```

| Operation | List (Stack) | List (Queue) | `deque` (Queue) |
|-----------|-------------|-------------|-----------------|
| Add to end | `append()` O(1) | `append()` O(1) | `append()` O(1) |
| Remove from end | `pop()` O(1) | â€” | `pop()` O(1) |
| Remove from front | â€” | `pop(0)` **O(n)** âŒ | `popleft()` **O(1)** âœ… |

> ğŸ’¡ **Always use `deque`** for queues. Never use `list.pop(0)` in production â€” it's O(n).

---

## ğŸ”— Quick Reference

```python
# Create
lst = [1, 2, 3]

# Access
lst[0]          # First
lst[-1]         # Last
lst[1:4]        # Slice

# Add
lst.append(x)   # End
lst.insert(i,x) # Position
lst.extend(it)  # Multiple

# Remove
lst.remove(x)   # By value
lst.pop(i)      # By index
lst.clear()     # All

# Search
lst.index(x)    # Position
lst.count(x)    # Count

# Sort
lst.sort()      # In-place
sorted(lst)     # New list

# Copy
lst.copy()      # Shallow
copy.deepcopy() # Deep

# Comprehension
[x**2 for x in range(10) if x % 2 == 0]
```

---

> ğŸ“ **Next up**: Section 2.2 â€” Tuples
