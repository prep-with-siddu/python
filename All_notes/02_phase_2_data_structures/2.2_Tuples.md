# 2.2 Tuples â€” Notes

> **Status**: âœ… Completed  
> **Date**: 28 February 2026

---

## 1. Creating Tuples & Immutability

### Creating Tuples
```python
# With parentheses
fruits = ("apple", "banana", "cherry")

# Without parentheses (packing)
colors = "red", "green", "blue"
print(type(colors))    # <class 'tuple'>

# Single element tuple â€” NEED trailing comma!
single = ("hello",)     # âœ… This is a tuple
not_tuple = ("hello")   # âŒ This is just a string!
print(type(single))     # <class 'tuple'>
print(type(not_tuple))  # <class 'str'>

# Empty tuple
empty = ()
empty = tuple()

# From other iterables
from_list = tuple([1, 2, 3])          # (1, 2, 3)
from_string = tuple("hello")          # ('h', 'e', 'l', 'l', 'o')
from_range = tuple(range(5))          # (0, 1, 2, 3, 4)
```

### Indexing & Slicing (Same as Lists)
```python
t = (10, 20, 30, 40, 50)

print(t[0])        # 10
print(t[-1])       # 50
print(t[1:4])      # (20, 30, 40)  â€” returns a tuple!
print(t[::-1])     # (50, 40, 30, 20, 10)
```

### Immutability â€” CANNOT Modify After Creation
```python
t = (1, 2, 3)

# t[0] = 10        # âŒ TypeError: 'tuple' object does not support item assignment
# t.append(4)      # âŒ AttributeError: 'tuple' object has no attribute 'append'
# del t[0]         # âŒ TypeError

# BUT! Mutable objects INSIDE a tuple CAN be changed!
t = (1, 2, [3, 4])
t[2].append(5)     # âœ… Works!
print(t)            # (1, 2, [3, 4, 5])
# The tuple itself didn't change â€” it still points to the same list object
# But the list's contents changed (because lists are mutable)
```

### Why Immutability Matters
| Benefit | Explanation |
|---------|------------|
| **Hashable** | Tuples can be dict keys and set elements (lists can't!) |
| **Thread-safe** | No risk of data being modified by multiple threads |
| **Faster** | Slightly faster than lists due to immutability optimizations |
| **Intent** | Signals "this data should NOT change" |

```python
# Tuple as dict key â€” works because immutable & hashable
locations = {
    (28.6139, 77.2090): "Delhi",
    (12.9716, 77.5946): "Bangalore",
    (19.0760, 72.8777): "Mumbai",
}
print(locations[(12.9716, 77.5946)])    # Bangalore

# List as dict key â€” FAILS
# locations = {[28.6139, 77.2090]: "Delhi"}  # âŒ TypeError: unhashable type: 'list'
```

> ğŸ’¡ **Rule of thumb**: Use tuples for data that shouldn't change (coordinates, RGB colors, database rows, config values).

---

## 2. Tuple Unpacking (Multiple Assignment)

### Basic Unpacking
```python
# Assign multiple variables at once
point = (10, 20)
x, y = point
print(x)    # 10
print(y)    # 20

# Works without parentheses too
name, age, city = "Sid", 25, "Bangalore"

# Swap variables (Python's elegant way!)
a, b = 1, 2
a, b = b, a       # Swap!
print(a, b)        # 2, 1
```

### Unpacking in Loops
```python
# Very common pattern â€” unpacking in for loops
users = [("Sid", 25), ("Rahul", 30), ("Amit", 22)]

for name, age in users:
    print(f"{name} is {age} years old")

# With enumerate (returns index, value tuples)
fruits = ["apple", "banana", "cherry"]
for i, fruit in enumerate(fruits):
    print(f"{i}: {fruit}")

# With dict.items() (returns key, value tuples)
scores = {"Sid": 90, "Rahul": 85, "Amit": 92}
for name, score in scores.items():
    print(f"{name}: {score}")
```

### Extended Unpacking with `*` (Star Expression)
```python
# *variable captures "the rest" as a list
first, *rest = [1, 2, 3, 4, 5]
print(first)    # 1
print(rest)     # [2, 3, 4, 5]

first, *middle, last = [1, 2, 3, 4, 5]
print(first)    # 1
print(middle)   # [2, 3, 4]
print(last)     # 5

*start, last = [1, 2, 3, 4, 5]
print(start)    # [1, 2, 3, 4]
print(last)     # 5

# Useful for function returns
def get_stats():
    return 10, 20, 30, 40, 50

minimum, *others, maximum = get_stats()
print(minimum)    # 10
print(maximum)    # 50
```

### Ignoring Values with `_`
```python
# Use _ for values you don't need
name, _, city = ("Sid", 25, "Bangalore")    # Don't need age
print(name, city)    # Sid Bangalore

# Ignore multiple
first, *_, last = [1, 2, 3, 4, 5]
print(first, last)   # 1 5

# Common with functions returning multiple values
_, extension = "photo.jpg".rsplit(".", 1)
print(extension)     # jpg
```

> ğŸ’¡ **Backend tip**: Tuple unpacking is everywhere â€” `enumerate()`, `dict.items()`, function returns, database query results. Master it.

---

## 3. Named Tuples (`collections.namedtuple`)

Regular tuples access by index (`t[0]`, `t[1]`), which is **hard to read**. Named tuples let you access by **name**.

```python
from collections import namedtuple

# Define a named tuple type
Point = namedtuple("Point", ["x", "y"])

# Create instances
p1 = Point(10, 20)
p2 = Point(x=30, y=40)

# Access by name (readable!) or index
print(p1.x)      # 10
print(p1.y)      # 20
print(p1[0])     # 10  (index still works)

# Still immutable
# p1.x = 50      # âŒ AttributeError
```

### Real-World Examples
```python
from collections import namedtuple

# User record from database
User = namedtuple("User", ["id", "name", "email", "role"])

user = User(id=1, name="Sid", email="sid@mail.com", role="admin")
print(user.name)      # Sid
print(user.role)      # admin

# HTTP Response
Response = namedtuple("Response", ["status_code", "body", "headers"])

resp = Response(status_code=200, body={"data": "ok"}, headers={"Content-Type": "json"})
print(resp.status_code)    # 200

# API endpoint config
Endpoint = namedtuple("Endpoint", ["method", "path", "handler"])
routes = [
    Endpoint("GET", "/users", "get_users"),
    Endpoint("POST", "/users", "create_user"),
]

for route in routes:
    print(f"{route.method} {route.path} â†’ {route.handler}")
```

### Useful Methods
```python
User = namedtuple("User", "id name email")

user = User(1, "Sid", "sid@mail.com")

# Convert to dict
print(user._asdict())    # {'id': 1, 'name': 'Sid', 'email': 'sid@mail.com'}

# Create modified copy (since tuples are immutable)
updated = user._replace(name="Siddu", email="siddu@mail.com")
print(updated)    # User(id=1, name='Siddu', email='siddu@mail.com')

# Get field names
print(User._fields)    # ('id', 'name', 'email')

# Create from iterable
data = [2, "Rahul", "rahul@mail.com"]
user2 = User._make(data)
print(user2)    # User(id=2, name='Rahul', email='rahul@mail.com')
```

### Alternative Syntax Options
```python
# Space-separated string
Point = namedtuple("Point", "x y z")

# With defaults (Python 3.6.1+)
User = namedtuple("User", ["name", "role", "active"], defaults=["user", True])
print(User("Sid"))    # User(name='Sid', role='user', active=True)
```

> ğŸ’¡ **Modern alternative**: Use `dataclasses` for mutable named data, use `namedtuple` when you want immutable lightweight records.

---

## 4. When to Use Tuples vs Lists

| Use **Tuple** When... | Use **List** When... |
|----------------------|---------------------|
| Data should NOT change | Data will be modified |
| Representing a "record" (name, age, city) | Representing a collection of same-type items |
| Need it as dict key or set element | Don't need hashability |
| Returning multiple values from function | Building up items dynamically |
| Function arguments (`*args` is a tuple) | Need append/remove/sort |
| Performance matters (slightly faster) | Need flexibility |

### Quick Examples
```python
# âœ… Tuple â€” fixed structure, won't change
coordinates = (12.97, 77.59)
rgb_color = (255, 128, 0)
db_row = (1, "Sid", "sid@mail.com", "admin")
http_response = (200, "OK", {"data": []})

# âœ… List â€” dynamic, will grow/shrink
shopping_cart = ["apple", "milk", "bread"]
log_entries = []
log_entries.append("User logged in")
log_entries.append("User viewed dashboard")
active_users = ["Sid", "Rahul"]
active_users.remove("Sid")
```

### Memory & Performance
```python
import sys

# Tuple uses less memory
t = (1, 2, 3, 4, 5)
l = [1, 2, 3, 4, 5]
print(sys.getsizeof(t))    # 80 bytes
print(sys.getsizeof(l))    # 120 bytes  (40 bytes more!)

# Tuple creation is faster
import timeit
print(timeit.timeit("(1,2,3,4,5)", number=1000000))   # ~0.01s
print(timeit.timeit("[1,2,3,4,5]", number=1000000))    # ~0.05s (5x slower)
```

> ğŸ’¡ **Simple rule**: If the data is a **collection** (items of the same kind) â†’ **list**. If it's a **record** (different fields grouped together) â†’ **tuple**.

---

## ğŸ”— Quick Reference

```python
# Create
t = (1, 2, 3)
t = 1, 2, 3         # Packing
single = (1,)        # Single element (comma!)

# Unpack
x, y, z = t
first, *rest = t
_, value, _ = t      # Ignore with _

# Named tuple
from collections import namedtuple
Point = namedtuple("Point", "x y")
p = Point(10, 20)
p.x                  # 10
p._asdict()          # {'x': 10, 'y': 20}

# Tuple is immutable, hashable, faster, lighter than list
# Use for records, dict keys, function returns
```

---

> ğŸ“ **Next up**: Section 2.3 â€” Dictionaries
