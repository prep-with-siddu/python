# 2.3 Dictionaries â€” Notes

> **Status**: âœ… Completed  
> **Date**: 28 February 2026

---

## 1. Creating Dicts & Accessing Values

### Creating Dictionaries
```python
# Literal syntax (most common)
user = {"name": "Sid", "age": 25, "city": "Bangalore"}

# dict() constructor
user = dict(name="Sid", age=25, city="Bangalore")

# From list of tuples
pairs = [("name", "Sid"), ("age", 25)]
user = dict(pairs)

# From two lists with zip
keys = ["name", "age", "city"]
values = ["Sid", 25, "Bangalore"]
user = dict(zip(keys, values))

# Empty dict
empty = {}
empty = dict()

# dict.fromkeys() â€” same value for all keys
defaults = dict.fromkeys(["host", "port", "debug"], None)
# {'host': None, 'port': None, 'debug': None}

scores = dict.fromkeys(["math", "science", "english"], 0)
# {'math': 0, 'science': 0, 'english': 0}
```

### Accessing Values
```python
user = {"name": "Sid", "age": 25, "city": "Bangalore"}

# Square bracket notation â€” raises KeyError if missing
print(user["name"])       # Sid
# print(user["email"])    # âŒ KeyError: 'email'

# .get() â€” returns None (or default) if missing â€” SAFER!
print(user.get("name"))            # Sid
print(user.get("email"))           # None (no error!)
print(user.get("email", "N/A"))    # N/A (custom default)

# Check if key exists
print("name" in user)      # True
print("email" in user)     # False
print("email" not in user) # True
```

### Adding & Modifying
```python
user = {"name": "Sid"}

# Add new key
user["age"] = 25
user["city"] = "Bangalore"

# Modify existing key
user["age"] = 26

print(user)    # {'name': 'Sid', 'age': 26, 'city': 'Bangalore'}

# Delete
del user["city"]
print(user)    # {'name': 'Sid', 'age': 26}
```

> ğŸ’¡ **Backend rule**: ALWAYS use `.get()` when accessing dict values that might not exist. `KeyError` crashes your server!

---

## 2. Dict Methods

```python
user = {"name": "Sid", "age": 25, "city": "Bangalore"}

# ---- Accessing ----
print(user.get("name"))                 # Sid
print(user.get("email", "not found"))   # not found

print(user.keys())      # dict_keys(['name', 'age', 'city'])
print(user.values())    # dict_values(['Sid', 25, 'Bangalore'])
print(user.items())     # dict_items([('name', 'Sid'), ('age', 25), ('city', 'Bangalore')])

# Convert to lists
print(list(user.keys()))    # ['name', 'age', 'city']

# ---- Modifying ----
# update() â€” merge another dict into this one
user.update({"age": 26, "email": "sid@mail.com"})
print(user)    # {'name': 'Sid', 'age': 26, 'city': 'Bangalore', 'email': 'sid@mail.com'}

# Can also update with keyword args
user.update(role="admin", active=True)

# pop() â€” remove and return value
email = user.pop("email")
print(email)    # sid@mail.com
# user.pop("missing")        # âŒ KeyError
user.pop("missing", None)    # âœ… Returns None (no error)

# popitem() â€” remove and return last inserted pair
last = user.popitem()
print(last)    # ('active', True)

# setdefault() â€” get value, but SET it if missing
config = {"host": "localhost"}
port = config.setdefault("port", 8000)    # Key missing â†’ sets it AND returns 8000
host = config.setdefault("host", "0.0.0.0") # Key exists â†’ returns "localhost" (no change!)
print(config)    # {'host': 'localhost', 'port': 8000}

# clear() â€” remove all
user.clear()
print(user)    # {}
```

### Methods Cheat Sheet
| Method | What it does | Returns |
|--------|-------------|---------|
| `get(key, default)` | Get value safely | Value or default |
| `keys()` | All keys | dict_keys view |
| `values()` | All values | dict_values view |
| `items()` | All (key, value) pairs | dict_items view |
| `update(other)` | Merge other dict | `None` |
| `pop(key, default)` | Remove & return value | Value |
| `popitem()` | Remove & return last pair | (key, value) |
| `setdefault(key, val)` | Get or set-if-missing | Value |
| `clear()` | Remove all | `None` |

> ğŸ’¡ `setdefault()` is super useful for grouping: `groups.setdefault(category, []).append(item)`

---

## 3. Dictionary Comprehensions

```python
# Syntax: {key_expr: value_expr for var in iterable}

# Squares dict
squares = {x: x**2 for x in range(6)}
# {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

# From two lists
keys = ["name", "age", "city"]
values = ["Sid", 25, "Bangalore"]
user = {k: v for k, v in zip(keys, values)}
# {'name': 'Sid', 'age': 25, 'city': 'Bangalore'}

# With condition
even_squares = {x: x**2 for x in range(10) if x % 2 == 0}
# {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}

# Invert a dict (swap keys and values)
original = {"a": 1, "b": 2, "c": 3}
inverted = {v: k for k, v in original.items()}
# {1: 'a', 2: 'b', 3: 'c'}

# Transform values
prices = {"apple": 100, "banana": 40, "cherry": 200}
discounted = {item: price * 0.9 for item, price in prices.items()}
# {'apple': 90.0, 'banana': 36.0, 'cherry': 180.0}

# Filter dict
expensive = {item: price for item, price in prices.items() if price > 50}
# {'apple': 100, 'cherry': 200}

# Backend example â€” extract specific fields
users_raw = [
    {"id": 1, "name": "Sid", "email": "sid@mail.com", "password": "hashed"},
    {"id": 2, "name": "Rahul", "email": "rahul@mail.com", "password": "hashed"},
]
user_map = {u["id"]: {"name": u["name"], "email": u["email"]} for u in users_raw}
# {1: {'name': 'Sid', 'email': 'sid@mail.com'}, 2: {'name': 'Rahul', ...}}
```

---

## 4. Nested Dictionaries

```python
# Dict of dicts â€” very common in APIs!
users = {
    "user_1": {
        "name": "Sid",
        "age": 25,
        "address": {
            "city": "Bangalore",
            "state": "Karnataka",
            "pin": "560001"
        }
    },
    "user_2": {
        "name": "Rahul",
        "age": 30,
        "address": {
            "city": "Mumbai",
            "state": "Maharashtra",
            "pin": "400001"
        }
    }
}

# Accessing nested values
print(users["user_1"]["name"])                    # Sid
print(users["user_1"]["address"]["city"])          # Bangalore

# Safe nested access (avoid KeyError chains)
city = users.get("user_1", {}).get("address", {}).get("city", "Unknown")
print(city)    # Bangalore

# Missing key â€” safe
city = users.get("user_99", {}).get("address", {}).get("city", "Unknown")
print(city)    # Unknown (no error!)

# Modifying nested
users["user_1"]["age"] = 26
users["user_1"]["address"]["pin"] = "560002"

# Adding new nested key
users["user_1"]["phone"] = "+91-9876543210"
```

### Iterating Nested Dicts
```python
for user_id, user_data in users.items():
    print(f"\n{user_id}:")
    for key, value in user_data.items():
        if isinstance(value, dict):
            print(f"  {key}:")
            for k, v in value.items():
                print(f"    {k}: {v}")
        else:
            print(f"  {key}: {value}")
```

> ğŸ’¡ **Backend tip**: API responses are deeply nested dicts (JSON). Master nested dict access â€” it's your daily bread.

---

## 5. `defaultdict` from `collections`

Automatically creates a **default value** for missing keys â€” no more `KeyError`!

```python
from collections import defaultdict

# Regular dict â€” KeyError on missing
regular = {}
# regular["fruits"].append("apple")    # âŒ KeyError!

# defaultdict â€” auto-creates on missing
dd = defaultdict(list)                  # Default = empty list
dd["fruits"].append("apple")            # âœ… Auto-creates [] then appends
dd["fruits"].append("banana")
dd["veggies"].append("carrot")
print(dict(dd))    # {'fruits': ['apple', 'banana'], 'veggies': ['carrot']}

# defaultdict(int) â€” default is 0 (great for counting!)
counter = defaultdict(int)
words = ["apple", "banana", "apple", "cherry", "banana", "apple"]
for word in words:
    counter[word] += 1
print(dict(counter))    # {'apple': 3, 'banana': 2, 'cherry': 1}

# defaultdict(set) â€” default is empty set
tags = defaultdict(set)
tags["user_1"].add("admin")
tags["user_1"].add("editor")
tags["user_2"].add("viewer")
print(dict(tags))    # {'user_1': {'admin', 'editor'}, 'user_2': {'viewer'}}
```

### Grouping Pattern (Very Common!)
```python
from collections import defaultdict

# Group users by city
users = [
    {"name": "Sid", "city": "Bangalore"},
    {"name": "Rahul", "city": "Mumbai"},
    {"name": "Amit", "city": "Bangalore"},
    {"name": "Priya", "city": "Mumbai"},
]

by_city = defaultdict(list)
for user in users:
    by_city[user["city"]].append(user["name"])

print(dict(by_city))
# {'Bangalore': ['Sid', 'Amit'], 'Mumbai': ['Rahul', 'Priya']}
```

---

## 6. `OrderedDict` from `collections`

Maintains **insertion order**. Since Python 3.7+, regular `dict` also maintains order â€” so `OrderedDict` is mostly for older code or when you need `move_to_end()`.

```python
from collections import OrderedDict

od = OrderedDict()
od["banana"] = 2
od["apple"] = 1
od["cherry"] = 3

print(od)    # OrderedDict([('banana', 2), ('apple', 1), ('cherry', 3)])

# Move to end
od.move_to_end("banana")          # Move to LAST
print(list(od.keys()))             # ['apple', 'cherry', 'banana']

od.move_to_end("banana", last=False)  # Move to FIRST
print(list(od.keys()))                 # ['banana', 'apple', 'cherry']

# OrderedDict equality considers ORDER
od1 = OrderedDict([("a", 1), ("b", 2)])
od2 = OrderedDict([("b", 2), ("a", 1)])
print(od1 == od2)    # False  (different order!)

# Regular dict equality ignores order
d1 = {"a": 1, "b": 2}
d2 = {"b": 2, "a": 1}
print(d1 == d2)      # True
```

> ğŸ’¡ Use `OrderedDict` when **order matters for equality** or you need `move_to_end()`. Otherwise, regular `dict` is fine in Python 3.7+.

---

## 7. `Counter` from `collections`

Counts occurrences of elements. **Super useful** for frequencies!

```python
from collections import Counter

# From a list
fruits = ["apple", "banana", "apple", "cherry", "banana", "apple"]
count = Counter(fruits)
print(count)    # Counter({'apple': 3, 'banana': 2, 'cherry': 1})

# From a string
letters = Counter("mississippi")
print(letters)  # Counter({'i': 4, 's': 4, 'p': 2, 'm': 1})

# Access count
print(count["apple"])     # 3
print(count["mango"])     # 0  (no KeyError for missing!)

# Most common
print(count.most_common(2))    # [('apple', 3), ('banana', 2)]

# Arithmetic operations
c1 = Counter(a=3, b=1)
c2 = Counter(a=1, b=2)
print(c1 + c2)    # Counter({'a': 4, 'b': 3})
print(c1 - c2)    # Counter({'a': 2})  (only positive counts)

# Total count (Python 3.10+)
print(count.total())    # 6

# Elements (iterate with repeats)
print(list(count.elements()))    # ['apple', 'apple', 'apple', 'banana', 'banana', 'cherry']
```

### Backend Examples
```python
from collections import Counter

# Count API error codes
error_logs = [404, 500, 404, 403, 500, 404, 500, 500]
error_counts = Counter(error_logs)
print(error_counts.most_common())
# [(500, 4), (404, 3), (403, 1)]

# Word frequency in text
text = "the quick brown fox jumps over the lazy dog the fox"
word_freq = Counter(text.split())
print(word_freq.most_common(3))
# [('the', 3), ('fox', 2), ('quick', 1)]

# Check if one is anagram of another
def is_anagram(s1, s2):
    return Counter(s1.lower()) == Counter(s2.lower())

print(is_anagram("listen", "silent"))    # True
```

> ğŸ’¡ `Counter` is a lifesaver in **DSA problems** (frequency counting) and **backend analytics** (counting events, errors, etc.).

---

## 8. `ChainMap` from `collections`

Groups multiple dicts into one **logical** dict. Searches dicts in order.

```python
from collections import ChainMap

defaults = {"color": "red", "size": "medium", "font": "Arial"}
user_prefs = {"color": "blue", "font": "Helvetica"}
cli_args = {"color": "green"}

# ChainMap searches first â†’ last
config = ChainMap(cli_args, user_prefs, defaults)
print(config["color"])    # green     (found in cli_args â€” first dict)
print(config["font"])     # Helvetica (not in cli_args, found in user_prefs)
print(config["size"])     # medium    (not in first two, found in defaults)

# All keys
print(list(config.keys()))    # ['color', 'size', 'font']

# Writes go to the FIRST dict only
config["theme"] = "dark"
print(cli_args)    # {'color': 'green', 'theme': 'dark'}
print(defaults)    # unchanged!
```

### Backend Use Case â€” Layered Configuration
```python
# Priority: environment vars > config file > defaults
env_config = {"DATABASE_URL": "postgres://prod:5432/mydb", "DEBUG": "false"}
file_config = {"DATABASE_URL": "postgres://localhost/mydb", "SECRET_KEY": "abc123"}
default_config = {"DEBUG": "true", "PORT": "8000", "SECRET_KEY": "change-me"}

config = ChainMap(env_config, file_config, default_config)
print(config["DATABASE_URL"])   # postgres://prod:5432/mydb (env wins)
print(config["DEBUG"])          # false (env wins)
print(config["PORT"])           # 8000 (only in defaults)
```

---

## 9. Dictionary Merge Operator (`|` in Python 3.9+)

```python
# Merge two dicts
defaults = {"color": "red", "size": "medium"}
overrides = {"color": "blue", "font": "Arial"}

# Python 3.9+ â€” | operator (creates new dict)
merged = defaults | overrides
print(merged)    # {'color': 'blue', 'size': 'medium', 'font': 'Arial'}
# Right side wins on conflicts!

# |= operator (in-place update, like .update())
defaults |= overrides
print(defaults)    # {'color': 'blue', 'size': 'medium', 'font': 'Arial'}

# Before Python 3.9 â€” use ** unpacking
merged = {**defaults, **overrides}    # Same result

# Or use .update()
defaults.update(overrides)             # In-place
```

### Chaining Multiple Merges
```python
a = {"x": 1}
b = {"y": 2}
c = {"z": 3}

combined = a | b | c
print(combined)    # {'x': 1, 'y': 2, 'z': 3}
```

---

## 10. Hashability â€” What Can Be a Dict Key

A dict key **must be hashable** (immutable + has `__hash__`).

```python
# âœ… Hashable â€” can be dict keys
d = {
    "string": 1,           # str âœ…
    42: 2,                 # int âœ…
    3.14: 3,               # float âœ…
    True: 4,               # bool âœ…
    (1, 2, 3): 5,          # tuple âœ… (if all elements are hashable)
    None: 6,               # NoneType âœ…
    frozenset({1,2}): 7,   # frozenset âœ…
}

# âŒ Unhashable â€” CANNOT be dict keys
# d = {[1, 2]: "list"}       # âŒ TypeError: unhashable type: 'list'
# d = {{1: 2}: "dict"}       # âŒ TypeError: unhashable type: 'dict'
# d = {{1, 2}: "set"}        # âŒ TypeError: unhashable type: 'set'

# Tuple with mutable element â€” also unhashable!
# d = {(1, [2, 3]): "bad"}   # âŒ TypeError: unhashable type: 'list'

# Check if hashable
print(hash("hello"))      # Works â€” some number
print(hash((1, 2, 3)))    # Works
# print(hash([1, 2, 3]))  # âŒ TypeError
```

### Rule
```
Hashable (immutable):  str, int, float, bool, tuple*, NoneType, frozenset
Unhashable (mutable):  list, dict, set

* tuple is hashable ONLY if ALL its elements are hashable
```

> ğŸ’¡ **Why this matters**: Dict keys and set elements must be hashable. This is why you can't use a list as a dict key, but you can use a tuple.

---

## ğŸ”— Quick Reference

```python
d = {"key": "value"}

# Access
d["key"]                    # KeyError if missing
d.get("key", "default")    # Safe â€” returns default

# Add/Modify
d["new_key"] = "val"
d.update({...})
d.setdefault("key", "val")

# Remove
del d["key"]
d.pop("key", None)
d.clear()

# Iterate
for k in d: ...
for k, v in d.items(): ...

# Comprehension
{k: v for k, v in iterable}

# Merge (3.9+)
merged = d1 | d2

# Special dicts
from collections import defaultdict, OrderedDict, Counter, ChainMap
defaultdict(list)      # Auto-creates on missing
Counter(iterable)      # Count frequencies
ChainMap(d1, d2, d3)   # Layered lookup
```

---

> ğŸ“ **Next up**: Section 2.4 â€” Sets
