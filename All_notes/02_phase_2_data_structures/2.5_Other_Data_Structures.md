# 2.5 Other Data Structures â€” Notes

> **Status**: âœ… Completed  
> **Date**: 28 February 2026

---

## 1. `deque` from `collections` (Double-Ended Queue)

A **deque** (pronounced "deck") supports fast appends and pops from **both ends** â€” O(1) vs O(n) for lists!

```python
from collections import deque

# Create
dq = deque([1, 2, 3, 4, 5])
print(dq)    # deque([1, 2, 3, 4, 5])

# Also from empty
dq = deque()

# Append (right = default)
dq = deque([2, 3, 4])
dq.append(5)          # deque([2, 3, 4, 5])
dq.appendleft(1)      # deque([1, 2, 3, 4, 5])

# Pop
right = dq.pop()      # 5, deque([1, 2, 3, 4])
left = dq.popleft()   # 1, deque([2, 3, 4])

# Extend
dq.extend([5, 6])         # deque([2, 3, 4, 5, 6])
dq.extendleft([1, 0])     # deque([0, 1, 2, 3, 4, 5, 6])
# Note: extendleft reverses the order of insertion!

# Rotate
dq = deque([1, 2, 3, 4, 5])
dq.rotate(2)     # Rotate right by 2: deque([4, 5, 1, 2, 3])
dq.rotate(-2)    # Rotate left by 2:  deque([1, 2, 3, 4, 5])
```

### `maxlen` â€” Fixed-Size Deque (Sliding Window!)
```python
# Auto-discards oldest when full
recent = deque(maxlen=3)
recent.append("page_1")   # deque(['page_1'])
recent.append("page_2")   # deque(['page_1', 'page_2'])
recent.append("page_3")   # deque(['page_1', 'page_2', 'page_3'])
recent.append("page_4")   # deque(['page_2', 'page_3', 'page_4'])  â† page_1 dropped!

print(recent)    # deque(['page_2', 'page_3', 'page_4'], maxlen=3)
```

### Performance Comparison: list vs deque
```python
# O(1) for deque at both ends vs O(n) for list.insert(0, x)
from collections import deque
import time

# Prepending 100k items
n = 100_000

# List â€” O(n) per insert at front â†’ O(nÂ²) total
lst = []
start = time.time()
for i in range(n):
    lst.insert(0, i)       # Shifts all elements every time!
print(f"List: {time.time() - start:.3f}s")

# Deque â€” O(1) per appendleft â†’ O(n) total
dq = deque()
start = time.time()
for i in range(n):
    dq.appendleft(i)       # Instant!
print(f"Deque: {time.time() - start:.3f}s")

# List: ~3-5s  |  Deque: ~0.01s  (300x faster!)
```

### Use Cases
| Use Case | Why deque? |
|----------|-----------|
| Queue (FIFO) | `append()` + `popleft()` â€” both O(1) |
| Stack (LIFO) | `append()` + `pop()` â€” both O(1) |
| Sliding window | `maxlen` auto-drops old elements |
| BFS in graphs | Classic BFS uses a queue |
| Recent history | Keep last N items |

### Queue Implementation
```python
from collections import deque

# Queue (FIFO â€” First In First Out)
queue = deque()
queue.append("task_1")      # Enqueue
queue.append("task_2")
queue.append("task_3")
task = queue.popleft()       # Dequeue â†’ "task_1"
print(task)                  # task_1
print(queue)                 # deque(['task_2', 'task_3'])
```

---

## 2. `heapq` â€” Heap Queue (Priority Queue)

A **min-heap** where the smallest element is always at index 0. Great for "top K" problems and priority queues.

```python
import heapq

# ---- Creating a Heap ----
# From a list (in-place)
nums = [5, 1, 8, 3, 2, 7]
heapq.heapify(nums)
print(nums)    # [1, 2, 7, 3, 5, 8]  (heap property, not fully sorted)

# ---- Push & Pop ----
heap = []
heapq.heappush(heap, 5)
heapq.heappush(heap, 1)
heapq.heappush(heap, 3)
print(heap)    # [1, 5, 3]  (min at index 0)

smallest = heapq.heappop(heap)    # 1
print(smallest)    # 1
print(heap)        # [3, 5]

# Push and pop in one operation (more efficient)
result = heapq.heappushpop(heap, 2)    # Push 2, then pop smallest
print(result)    # 2
print(heap)      # [3, 5]

result = heapq.heapreplace(heap, 10)   # Pop smallest first, then push 10
print(result)    # 3
print(heap)      # [5, 10]
```

### Top K Pattern (Very Common in DSA!)
```python
import heapq

nums = [15, 3, 8, 1, 20, 7, 12, 5]

# K smallest
print(heapq.nsmallest(3, nums))    # [1, 3, 5]

# K largest
print(heapq.nlargest(3, nums))     # [20, 15, 12]

# With key function
students = [
    {"name": "Sid", "score": 85},
    {"name": "Rahul", "score": 92},
    {"name": "Priya", "score": 78},
    {"name": "Amit", "score": 95},
]
top_2 = heapq.nlargest(2, students, key=lambda s: s["score"])
print(top_2)    # [{'name': 'Amit', 'score': 95}, {'name': 'Rahul', 'score': 92}]
```

### Max-Heap Trick (Negate Values)
```python
import heapq

# Python only has min-heap. For max-heap, negate values!
nums = [5, 1, 8, 3, 2]
max_heap = [-x for x in nums]
heapq.heapify(max_heap)

# Pop largest
largest = -heapq.heappop(max_heap)    # 8
print(largest)    # 8
```

### Priority Queue with Tuples
```python
import heapq

# Tuples are compared element-by-element
# (priority, data) â€” lower priority number = higher priority
tasks = []
heapq.heappush(tasks, (2, "write tests"))
heapq.heappush(tasks, (1, "fix critical bug"))
heapq.heappush(tasks, (3, "update docs"))

while tasks:
    priority, task = heapq.heappop(tasks)
    print(f"Priority {priority}: {task}")
# Priority 1: fix critical bug
# Priority 2: write tests
# Priority 3: update docs
```

### Merge Sorted Iterables
```python
import heapq

list1 = [1, 3, 5, 7]
list2 = [2, 4, 6, 8]
list3 = [0, 9, 10]

merged = list(heapq.merge(list1, list2, list3))
print(merged)    # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

---

## 3. `array` Module â€” Typed Arrays

Unlike lists (which store any type), `array` stores elements of **one type** â€” uses less memory.

```python
from array import array

# Create â€” must specify type code
# 'i' = signed int, 'f' = float, 'd' = double
int_arr = array('i', [1, 2, 3, 4, 5])
float_arr = array('f', [1.0, 2.5, 3.7])

print(int_arr)        # array('i', [1, 2, 3, 4, 5])
print(int_arr[0])     # 1
print(int_arr[-1])    # 5

# Slicing works like lists
print(int_arr[1:4])   # array('i', [2, 3, 4])

# Modify
int_arr[0] = 10
print(int_arr)        # array('i', [10, 2, 3, 4, 5])

# Append
int_arr.append(6)     # array('i', [10, 2, 3, 4, 5, 6])

# Extend
int_arr.extend([7, 8])

# âŒ Type enforced!
# int_arr.append(3.14)    # TypeError: 'float' not supported
# int_arr.append("hello") # TypeError
```

### Common Type Codes
| Code | Type | Size (bytes) |
|------|------|-------------|
| `'b'` | signed char | 1 |
| `'B'` | unsigned char | 1 |
| `'i'` | signed int | 2-4 |
| `'I'` | unsigned int | 2-4 |
| `'f'` | float | 4 |
| `'d'` | double | 8 |

### Memory Comparison
```python
import sys
from array import array

lst = list(range(1000))
arr = array('i', range(1000))

print(f"List: {sys.getsizeof(lst)} bytes")     # ~8856 bytes
print(f"Array: {sys.getsizeof(arr)} bytes")     # ~4064 bytes
# Array uses ~50% less memory!
```

> ğŸ’¡ Use `array` for **large collections of same-type numbers** where memory matters. For most cases, use `list`. For heavy math, use **NumPy** instead.

---

## 4. `bisect` Module â€” Binary Search on Sorted Lists

Efficiently find insertion points and maintain sorted order.

```python
import bisect

# ---- Finding Insertion Points ----
sorted_list = [10, 20, 30, 40, 50]

# bisect_left â€” insert BEFORE existing duplicates
pos = bisect.bisect_left(sorted_list, 30)
print(pos)    # 2 (index where 30 is)

# bisect_right (or just bisect) â€” insert AFTER existing duplicates
pos = bisect.bisect_right(sorted_list, 30)
print(pos)    # 3 (after existing 30)

# For non-existing value
pos = bisect.bisect_left(sorted_list, 25)
print(pos)    # 2 (would go between 20 and 30)

# ---- Inserting While Maintaining Sort ----
sorted_list = [10, 20, 40, 50]
bisect.insort(sorted_list, 30)      # Insert 30 in correct position
print(sorted_list)                   # [10, 20, 30, 40, 50]

bisect.insort_left(sorted_list, 30)  # Insert before existing 30
print(sorted_list)                   # [10, 20, 30, 30, 40, 50]
```

### Binary Search Using bisect
```python
import bisect

def binary_search(sorted_list, target):
    """Find index of target, or -1 if not found"""
    i = bisect.bisect_left(sorted_list, target)
    if i < len(sorted_list) and sorted_list[i] == target:
        return i
    return -1

nums = [1, 3, 5, 7, 9, 11, 13]
print(binary_search(nums, 7))     # 3
print(binary_search(nums, 6))     # -1
```

### Grade Classifier (Classic Example)
```python
import bisect

def grade(score):
    breakpoints = [60, 70, 80, 90]    # F < 60, D < 70, C < 80, B < 90, A >= 90
    grades = "FDCBA"
    i = bisect.bisect(breakpoints, score)
    return grades[i]

print(grade(55))    # F
print(grade(65))    # D
print(grade(75))    # C
print(grade(85))    # B
print(grade(95))    # A
```

### Time Complexity
| Operation | list (manual) | bisect |
|-----------|-------------|--------|
| Find insertion point | O(n) | O(log n) |
| Insert in sorted list | O(n) | O(n)* |

> *`insort` is O(n) because the list still shifts elements, but finding the position is O(log n).

---

## 5. `enum` Module â€” Enumerations

Create named constants with meaningful values. Prevents magic numbers!

```python
from enum import Enum, auto

# ---- Basic Enum ----
class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3

# Access
print(Color.RED)         # Color.RED
print(Color.RED.name)    # RED
print(Color.RED.value)   # 1

# Comparison
print(Color.RED == Color.RED)     # True
print(Color.RED == Color.GREEN)   # False
print(Color.RED == 1)             # False! (Enum != int)

# Iterate
for color in Color:
    print(f"{color.name} = {color.value}")
# RED = 1
# GREEN = 2
# BLUE = 3

# Access by value or name
print(Color(2))          # Color.GREEN
print(Color["BLUE"])     # Color.BLUE
```

### `auto()` â€” Auto-Assign Values
```python
from enum import Enum, auto

class Direction(Enum):
    NORTH = auto()    # 1
    SOUTH = auto()    # 2
    EAST = auto()     # 3
    WEST = auto()     # 4

print(Direction.NORTH.value)    # 1
```

### String Enum
```python
from enum import Enum

class Status(str, Enum):
    PENDING = "pending"
    ACTIVE = "active"
    INACTIVE = "inactive"
    BANNED = "banned"

# str + Enum means it acts like a string
print(Status.ACTIVE)             # Status.ACTIVE
print(Status.ACTIVE.value)       # active
print(Status.ACTIVE == "active") # True  (because it's also str)

# Use in f-strings
print(f"User is {Status.ACTIVE.value}")  # User is active
```

### Backend Example â€” API Status Codes
```python
from enum import Enum

class OrderStatus(str, Enum):
    CREATED = "created"
    PROCESSING = "processing"
    SHIPPED = "shipped"
    DELIVERED = "delivered"
    CANCELLED = "cancelled"

# Use in your code
def update_order(order_id, status: OrderStatus):
    print(f"Order {order_id} â†’ {status.value}")

update_order(123, OrderStatus.SHIPPED)  # Order 123 â†’ shipped

# Validate input
def parse_status(status_str):
    try:
        return OrderStatus(status_str)
    except ValueError:
        raise ValueError(f"Invalid status: {status_str}")

parse_status("shipped")     # OrderStatus.SHIPPED
# parse_status("flying")    # ValueError: Invalid status: flying
```

### IntEnum â€” Enum That Acts Like int
```python
from enum import IntEnum

class Priority(IntEnum):
    LOW = 1
    MEDIUM = 2
    HIGH = 3
    CRITICAL = 4

# Can compare with integers
print(Priority.HIGH > 2)         # True
print(Priority.LOW + Priority.MEDIUM)  # 3

# Can sort
tasks = [Priority.HIGH, Priority.LOW, Priority.CRITICAL, Priority.MEDIUM]
print(sorted(tasks))    # [LOW, MEDIUM, HIGH, CRITICAL]
```

### Flag Enum â€” Bitwise Combinations
```python
from enum import Flag, auto

class Permission(Flag):
    READ = auto()       # 1
    WRITE = auto()      # 2
    EXECUTE = auto()    # 4
    DELETE = auto()     # 8

# Combine with |
admin = Permission.READ | Permission.WRITE | Permission.EXECUTE | Permission.DELETE
editor = Permission.READ | Permission.WRITE
viewer = Permission.READ

# Check with &
print(Permission.WRITE in editor)    # True
print(Permission.DELETE in editor)   # False
print(Permission.READ in viewer)     # True
```

> ğŸ’¡ **Backend tip**: Use `str, Enum` for API fields in FastAPI/Pydantic. It auto-validates and generates docs!

---

## ğŸ”— Quick Reference

```python
# ---- deque ----
from collections import deque
dq = deque([1, 2, 3], maxlen=5)
dq.append(4)          # Right
dq.appendleft(0)      # Left
dq.pop()              # Right
dq.popleft()          # Left
dq.rotate(2)          # Rotate right

# ---- heapq ----
import heapq
heap = []
heapq.heappush(heap, 5)
heapq.heappop(heap)          # Smallest
heapq.nlargest(3, nums)
heapq.nsmallest(3, nums)
heapq.heapify(list)

# ---- array ----
from array import array
arr = array('i', [1, 2, 3])  # Typed, memory-efficient

# ---- bisect ----
import bisect
bisect.bisect_left(sorted_list, value)    # Find insert point
bisect.insort(sorted_list, value)          # Insert in order

# ---- enum ----
from enum import Enum, auto, IntEnum
class Status(str, Enum):
    ACTIVE = "active"
```

---

> ğŸ“ **Phase 2 Complete!** Next: Phase 3 â€” Functions (already in `03_phase_3_functions/`)
