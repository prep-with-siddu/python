# Python Data Structures ‚Äî Ultimate Comparison & Deep Dive

> **One file. All data structures. Every comparison you'll ever need.**  
> Great for revision before interviews and quick reference while coding.

---

## 1. The Big Picture ‚Äî All Built-in Data Structures at a Glance

| Data Structure | Ordered? | Mutable? | Duplicates? | Indexed? | Hashable? | Syntax |
|:--------------|:--------:|:--------:|:-----------:|:--------:|:---------:|:------:|
| **list** | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes (`[0]`) | ‚ùå No | `[1, 2, 3]` |
| **tuple** | ‚úÖ Yes | ‚ùå No | ‚úÖ Yes | ‚úÖ Yes (`[0]`) | ‚úÖ Yes* | `(1, 2, 3)` |
| **set** | ‚ùå No | ‚úÖ Yes | ‚ùå No | ‚ùå No | ‚ùå No | `{1, 2, 3}` |
| **frozenset** | ‚ùå No | ‚ùå No | ‚ùå No | ‚ùå No | ‚úÖ Yes | `frozenset({1, 2})` |
| **dict** | ‚úÖ Yes (3.7+) | ‚úÖ Yes | Keys: ‚ùå / Values: ‚úÖ | ‚úÖ By key | ‚ùå No | `{"a": 1}` |
| **str** | ‚úÖ Yes | ‚ùå No | ‚úÖ Yes | ‚úÖ Yes (`[0]`) | ‚úÖ Yes | `"hello"` |
| **bytes** | ‚úÖ Yes | ‚ùå No | ‚úÖ Yes | ‚úÖ Yes (`[0]`) | ‚úÖ Yes | `b"hello"` |
| **bytearray** | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes (`[0]`) | ‚ùå No | `bytearray(b"hi")` |
| **range** | ‚úÖ Yes | ‚ùå No | Depends | ‚úÖ Yes (`[0]`) | ‚ùå No | `range(10)` |

> **\*** A tuple is hashable **only if all its elements are hashable**.  
> `hash((1, 2, 3))` ‚úÖ works | `hash((1, [2], 3))` ‚ùå fails (list inside)

---

## 2. List vs Tuple vs Set vs Dict ‚Äî The Core 4

### Head-to-Head Comparison

| Feature | `list` | `tuple` | `set` | `dict` |
|:--------|:------:|:-------:|:-----:|:------:|
| **Created with** | `[]` or `list()` | `()` or `tuple()` | `{}` or `set()` | `{}` or `dict()` |
| **Empty creation** | `[]` | `()` | `set()` ‚ö†Ô∏è not `{}` | `{}` |
| **Can contain** | Any type | Any type | Hashable only | Key: Hashable, Value: Any |
| **Use when** | Need ordered, changeable collection | Need fixed data (coordinates, DB rows) | Need unique items, fast lookup | Need key-value mapping |
| **Memory** | Medium | Low (less than list) | High (hash table) | High (hash table) |
| **Iteration speed** | Fast | Fast (slightly faster than list) | Fast | Fast (over keys by default) |
| **Can be dict key?** | ‚ùå No | ‚úÖ Yes | ‚ùå No | ‚ùå No |
| **Thread-safe?** | ‚ùå No | ‚úÖ Yes (immutable) | ‚ùå No | ‚ùå No |

### When to Use What ‚Äî Decision Guide

```
Need to store items in order?
‚îú‚îÄ‚îÄ YES ‚Üí Need to change items later?
‚îÇ   ‚îú‚îÄ‚îÄ YES ‚Üí Use LIST
‚îÇ   ‚îî‚îÄ‚îÄ NO  ‚Üí Use TUPLE
‚îî‚îÄ‚îÄ NO  ‚Üí Need key-value pairs?
    ‚îú‚îÄ‚îÄ YES ‚Üí Use DICT
    ‚îî‚îÄ‚îÄ NO  ‚Üí Need unique items only?
        ‚îú‚îÄ‚îÄ YES ‚Üí Use SET
        ‚îî‚îÄ‚îÄ NO  ‚Üí Use LIST
```

---

## 3. Time Complexity Comparison ‚Äî Operations Speed (Big O)

### Core Operations

| Operation | `list` | `tuple` | `set` | `dict` |
|:----------|:------:|:-------:|:-----:|:------:|
| **Access by index** `x[i]` | O(1) | O(1) | ‚ùå N/A | ‚ùå N/A |
| **Access by key** `x[k]` | ‚ùå N/A | ‚ùå N/A | ‚ùå N/A | **O(1)** |
| **Search** `item in x` | **O(n)** üê¢ | **O(n)** üê¢ | **O(1)** üöÄ | **O(1)** üöÄ (keys) |
| **Add at end** | O(1) amortized | ‚ùå Immutable | O(1) | O(1) |
| **Add at beginning** | **O(n)** üê¢ | ‚ùå Immutable | O(1) | O(1) |
| **Insert at position** | O(n) | ‚ùå Immutable | ‚ùå N/A | O(1) |
| **Delete by value** | O(n) | ‚ùå Immutable | O(1) | O(1) |
| **Delete by index** | O(n) | ‚ùå Immutable | ‚ùå N/A | ‚ùå N/A |
| **Pop last** | O(1) | ‚ùå Immutable | ‚ùå N/A | O(1) `.popitem()` |
| **Pop first** | **O(n)** üê¢ | ‚ùå Immutable | ‚ùå N/A | ‚ùå N/A |
| **Sort** | O(n log n) | ‚ùå use `sorted()` | ‚ùå unsorted | ‚ùå use `sorted()` |
| **Length** `len(x)` | O(1) | O(1) | O(1) | O(1) |
| **Copy** | O(n) | O(1)* | O(n) | O(n) |
| **Slice** `x[a:b]` | O(b-a) | O(b-a) | ‚ùå N/A | ‚ùå N/A |

> **\*** Tuple copy is O(1) because tuples are immutable ‚Äî Python reuses the object!

### üèÜ Winner by Operation

| I need to... | Best Choice | Why |
|:-------------|:------------|:----|
| Check if item exists | `set` or `dict` | O(1) lookup via hashing |
| Maintain insertion order | `list` or `dict` | Both preserve order |
| Quick append/pop from end | `list` | O(1) amortized |
| Quick append/pop from both ends | `deque` | O(1) on both sides |
| Store unique items | `set` | Auto-removes duplicates |
| Map keys to values | `dict` | That's what it's for |
| Fixed/constant data | `tuple` | Immutable, memory-efficient |
| Count occurrences | `Counter` | Built for counting |

---

## 4. Memory Comparison

```python
import sys

a = [1, 2, 3, 4, 5]          # list
b = (1, 2, 3, 4, 5)          # tuple
c = {1, 2, 3, 4, 5}          # set
d = {1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e'}  # dict

print(sys.getsizeof(a))  # 120 bytes (list)
print(sys.getsizeof(b))  #  80 bytes (tuple)   ‚Üê smallest!
print(sys.getsizeof(c))  # 216 bytes (set)
print(sys.getsizeof(d))  # 232 bytes (dict)    ‚Üê largest
```

| Data Structure | Memory (5 elements) | Relative Size |
|:--------------|:-------------------:|:-------------:|
| **tuple** | ~80 bytes | ‚≠ê Smallest |
| **list** | ~120 bytes | 1.5√ó tuple |
| **set** | ~216 bytes | 2.7√ó tuple |
| **dict** | ~232 bytes | 2.9√ó tuple |

> **Interview Tip:** "If you don't need to modify the data, use a tuple instead of a list ‚Äî it uses 40% less memory."

---

## 5. Common Methods Comparison

### Adding Elements

| Method | `list` | `set` | `dict` |
|:-------|:------:|:-----:|:------:|
| Add one item | `.append(x)` | `.add(x)` | `d[key] = val` |
| Add multiple | `.extend([1,2])` | `.update({1,2})` | `.update({k:v})` |
| Insert at position | `.insert(i, x)` | ‚ùå unordered | ‚ùå no position |

### Removing Elements

| Method | `list` | `set` | `dict` |
|:-------|:------:|:-----:|:------:|
| Remove by value | `.remove(x)` | `.remove(x)` | ‚ùå use `del d[k]` |
| Remove & return last | `.pop()` | `.pop()` (random) | `.popitem()` |
| Remove by index/key | `.pop(i)` | ‚ùå N/A | `.pop(key)` |
| Safe remove | ‚ùå try/except | `.discard(x)` | `.pop(key, default)` |
| Clear all | `.clear()` | `.clear()` | `.clear()` |

### Searching / Checking

| Operation | `list` | `tuple` | `set` | `dict` |
|:----------|:------:|:-------:|:-----:|:------:|
| **Contains** | `x in list` O(n) | `x in tuple` O(n) | `x in set` **O(1)** | `k in dict` **O(1)** |
| **Count** | `.count(x)` | `.count(x)` | ‚ùå (all unique) | ‚ùå use `Counter` |
| **Index/Find** | `.index(x)` | `.index(x)` | ‚ùå N/A | `.get(k, default)` |

---

## 6. Set Operations ‚Äî Unique to Sets

| Operation | Method | Operator | Example | Result |
|:----------|:-------|:--------:|:--------|:-------|
| **Union** | `a.union(b)` | `a \| b` | `{1,2} \| {2,3}` | `{1, 2, 3}` |
| **Intersection** | `a.intersection(b)` | `a & b` | `{1,2} & {2,3}` | `{2}` |
| **Difference** | `a.difference(b)` | `a - b` | `{1,2} - {2,3}` | `{1}` |
| **Symmetric Diff** | `a.symmetric_difference(b)` | `a ^ b` | `{1,2} ^ {2,3}` | `{1, 3}` |
| **Subset** | `a.issubset(b)` | `a <= b` | `{1} <= {1,2}` | `True` |
| **Superset** | `a.issuperset(b)` | `a >= b` | `{1,2} >= {1}` | `True` |
| **Disjoint** | `a.isdisjoint(b)` | ‚Äî | `{1} & {2}` | `True` (no common) |

> **Interview Favorite:** "Find common elements in two lists"  
> `common = set(list1) & set(list2)` ‚Äî O(n) instead of O(n¬≤) nested loops!

---

## 7. Dict Variants ‚Äî `collections` Module

| Type | Import | Purpose | Example |
|:-----|:-------|:--------|:--------|
| **dict** | built-in | Standard key-value | `{"a": 1}` |
| **defaultdict** | `collections` | Auto-creates missing keys with default value | `defaultdict(list)` ‚Üí `d["new"].append(1)` works! |
| **OrderedDict** | `collections` | Remembers insertion order (before 3.7) + equality checks order | `OrderedDict()` |
| **Counter** | `collections` | Count occurrences of elements | `Counter("banana")` ‚Üí `{'a':3, 'n':2, 'b':1}` |
| **ChainMap** | `collections` | Combine multiple dicts into one view | `ChainMap(d1, d2)` ‚Äî looks up d1 first |

### defaultdict vs dict

| Feature | `dict` | `defaultdict` |
|:--------|:------:|:-------------:|
| Missing key access | ‚ùå Raises `KeyError` | ‚úÖ Returns default value |
| Need `if key in d` check | ‚úÖ Yes | ‚ùå Not needed |
| Use case | General purpose | Grouping, counting, nested structures |

```python
# Without defaultdict (ugly)
d = {}
for word in words:
    if word[0] not in d:
        d[word[0]] = []
    d[word[0]].append(word)

# With defaultdict (clean)
from collections import defaultdict
d = defaultdict(list)
for word in words:
    d[word[0]].append(word)  # Just works!
```

### Counter ‚Äî Quick Reference

```python
from collections import Counter

c = Counter("abracadabra")
# Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})

c.most_common(2)      # [('a', 5), ('b', 2)]
c['a']                 # 5
c['z']                 # 0 (no KeyError!)
c.total()              # 11 (Python 3.10+)
c1 + c2                # Add counts
c1 - c2                # Subtract counts
c1 & c2                # Min of each (intersection)
c1 | c2                # Max of each (union)
```

---

## 8. List vs Deque vs Array ‚Äî Sequential Data

| Feature | `list` | `deque` | `array.array` | `numpy.ndarray` |
|:--------|:------:|:-------:|:-------------:|:---------------:|
| **Module** | built-in | `collections` | `array` | `numpy` |
| **Append right** | O(1) | O(1) | O(1) | ‚ùå fixed size |
| **Append left** | **O(n)** üê¢ | **O(1)** üöÄ | O(n) | ‚ùå fixed size |
| **Pop right** | O(1) | O(1) | O(1) | ‚ùå fixed size |
| **Pop left** | **O(n)** üê¢ | **O(1)** üöÄ | O(n) | ‚ùå fixed size |
| **Random access** `[i]` | **O(1)** üöÄ | **O(n)** üê¢ | O(1) | O(1) |
| **Slicing** | ‚úÖ Yes | ‚ùå No | ‚úÖ Yes | ‚úÖ Yes |
| **Mixed types** | ‚úÖ Yes | ‚úÖ Yes | ‚ùå Same type only | ‚ùå Same type only |
| **Memory** | High | Medium | **Low** ‚≠ê | **Low** ‚≠ê |
| **Use case** | General purpose | Queue/Stack (both ends) | Typed numeric data | Math/ML operations |

> **Rule of thumb:**  
> Need both-end operations ‚Üí `deque`  
> Need random access ‚Üí `list`  
> Need numeric computation ‚Üí `numpy.ndarray`  
> Need memory-efficient typed array ‚Üí `array.array`

---

## 9. Stack vs Queue vs Priority Queue

| Feature | Stack (LIFO) | Queue (FIFO) | Priority Queue |
|:--------|:------------:|:------------:|:--------------:|
| **Concept** | Last In, First Out | First In, First Out | Highest priority out first |
| **Real-world** | Stack of plates | Standing in line | Hospital emergency room |
| **Python: Simple** | `list` (use `.append()` + `.pop()`) | `deque` (use `.append()` + `.popleft()`) | `heapq` module |
| **Python: Thread-safe** | `queue.LifoQueue` | `queue.Queue` | `queue.PriorityQueue` |
| **Push** | `.append(x)` O(1) | `.append(x)` O(1) | `heapq.heappush(h, x)` O(log n) |
| **Pop** | `.pop()` O(1) | `.popleft()` O(1) | `heapq.heappop(h)` O(log n) |
| **Peek** | `stack[-1]` O(1) | `queue[0]` O(1) | `heap[0]` O(1) |

```python
# STACK using list
stack = []
stack.append(1)     # push
stack.append(2)
stack.pop()         # 2 (last in, first out)

# QUEUE using deque
from collections import deque
queue = deque()
queue.append(1)     # enqueue
queue.append(2)
queue.popleft()     # 1 (first in, first out)

# PRIORITY QUEUE using heapq
import heapq
heap = []
heapq.heappush(heap, 3)
heapq.heappush(heap, 1)
heapq.heappush(heap, 2)
heapq.heappop(heap)     # 1 (smallest first = min-heap)
```

---

## 10. Tuple vs Named Tuple vs Dataclass

| Feature | `tuple` | `namedtuple` | `dataclass` |
|:--------|:-------:|:------------:|:-----------:|
| **Module** | built-in | `collections` | `dataclasses` |
| **Access by index** | ‚úÖ `t[0]` | ‚úÖ `t[0]` | ‚ùå No |
| **Access by name** | ‚ùå No | ‚úÖ `t.name` | ‚úÖ `t.name` |
| **Mutable** | ‚ùå No | ‚ùå No | ‚úÖ Yes (‚ùå if `frozen=True`) |
| **Type hints** | ‚ùå No | ‚ùå No | ‚úÖ Yes |
| **Default values** | ‚ùå No | ‚úÖ Yes (Python 3.6.1+) | ‚úÖ Yes |
| **Methods** | ‚ùå No | ‚ùå Limited | ‚úÖ Yes (add any method) |
| **Inheritance** | ‚ùå No | ‚ö†Ô∏è Limited | ‚úÖ Yes |
| **Hashable** | ‚úÖ Yes* | ‚úÖ Yes* | Only if `frozen=True` |
| **Auto `__repr__`** | Basic | ‚úÖ Readable | ‚úÖ Readable |
| **Auto `__eq__`** | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes |
| **Memory** | ‚≠ê Lowest | ‚≠ê Low | Medium |
| **Use case** | Quick fixed data | Readable fixed records | Rich data objects |

```python
# Regular tuple ‚Äî hard to read
user = ("Sid", 25, "Bengaluru")
print(user[0])  # "Sid" ‚Äî but what is [0]? Name? Age?

# Named tuple ‚Äî readable, still immutable
from collections import namedtuple
User = namedtuple("User", ["name", "age", "city"])
user = User("Sid", 25, "Bengaluru")
print(user.name)  # "Sid" ‚Äî much clearer!

# Dataclass ‚Äî full power, mutable, methods allowed
from dataclasses import dataclass

@dataclass
class User:
    name: str
    age: int
    city: str = "Bengaluru"  # default value

user = User("Sid", 25)
user.age = 26  # ‚úÖ mutable
print(user)    # User(name='Sid', age=26, city='Bengaluru')
```

---

## 11. String vs Bytes vs Bytearray

| Feature | `str` | `bytes` | `bytearray` |
|:--------|:-----:|:-------:|:-----------:|
| **Contains** | Unicode characters | Raw bytes (0-255) | Raw bytes (0-255) |
| **Mutable** | ‚ùå No | ‚ùå No | ‚úÖ Yes |
| **Literal** | `"hello"` | `b"hello"` | `bytearray(b"hello")` |
| **Use case** | Text data | Binary data (files, network) | Mutable binary buffer |
| **Encoding** | Unicode (UTF-8 default) | Raw bytes | Raw bytes |
| **Convert to bytes** | `.encode("utf-8")` | ‚Äî | `bytes(ba)` |
| **Convert to str** | ‚Äî | `.decode("utf-8")` | `.decode("utf-8")` |

```python
text = "Hello"              # str
data = text.encode("utf-8") # b'Hello' ‚Üí bytes
back = data.decode("utf-8") # 'Hello' ‚Üí str

# Mutable binary data
buf = bytearray(b"Hello")
buf[0] = 74  # ASCII for 'J'
print(buf)   # bytearray(b'Jello')
```

---

## 12. Shallow Copy vs Deep Copy

| | Assignment (`=`) | Shallow Copy | Deep Copy |
|:--|:----------------:|:------------:|:---------:|
| **Creates new object?** | ‚ùå Same object | ‚úÖ New outer object | ‚úÖ New everything |
| **Nested objects?** | Same references | **Same references** ‚ö†Ô∏è | **New copies** ‚úÖ |
| **Method** | `b = a` | `b = a.copy()` or `list(a)` or `a[:]` | `copy.deepcopy(a)` |
| **Speed** | ‚≠ê O(1) | O(n) | O(n√óm) slowest |
| **Memory** | ‚≠ê None extra | Some extra | Most extra |

```python
import copy

# Shallow copy TRAP!
a = [[1, 2], [3, 4]]
b = a.copy()      # shallow copy
b[0][0] = 99      # modifies BOTH a and b!
print(a)  # [[99, 2], [3, 4]]  ‚Üê also changed! üò±

# Deep copy ‚Äî safe
a = [[1, 2], [3, 4]]
c = copy.deepcopy(a)
c[0][0] = 99      # only modifies c
print(a)  # [[1, 2], [3, 4]]  ‚Üê untouched ‚úÖ
```

---

## 13. Hashable vs Unhashable ‚Äî Why It Matters

| Type | Hashable? | Can be dict key? | Can be in set? |
|:-----|:---------:|:-----------------:|:--------------:|
| `int` | ‚úÖ | ‚úÖ | ‚úÖ |
| `float` | ‚úÖ | ‚úÖ | ‚úÖ |
| `str` | ‚úÖ | ‚úÖ | ‚úÖ |
| `bool` | ‚úÖ | ‚úÖ | ‚úÖ |
| `tuple` | ‚úÖ* | ‚úÖ* | ‚úÖ* |
| `frozenset` | ‚úÖ | ‚úÖ | ‚úÖ |
| `None` | ‚úÖ | ‚úÖ | ‚úÖ |
| `bytes` | ‚úÖ | ‚úÖ | ‚úÖ |
| `list` | ‚ùå | ‚ùå | ‚ùå |
| `dict` | ‚ùå | ‚ùå | ‚ùå |
| `set` | ‚ùå | ‚ùå | ‚ùå |
| `bytearray` | ‚ùå | ‚ùå | ‚ùå |

> **Rule:** Mutable objects are **NOT hashable**. Immutable objects **ARE hashable**.  
> **\*** Tuple is hashable only if ALL its elements are hashable.

```python
# This works
d = {(1, 2): "point"}  # tuple as key ‚úÖ

# This fails
d = {[1, 2]: "point"}  # TypeError: unhashable type: 'list' ‚ùå
```

---

## 14. Mutable vs Immutable ‚Äî Complete Reference

| Mutable (Can Change) | Immutable (Cannot Change) |
|:---------------------:|:-------------------------:|
| `list` | `tuple` |
| `dict` | `str` |
| `set` | `int`, `float`, `bool` |
| `bytearray` | `bytes` |
| `deque` | `frozenset` |
| Custom objects (default) | `range` |
| | `None` |
| | `namedtuple` |

### Why Does Mutability Matter?

```python
# Immutable ‚Äî "change" creates NEW object
a = "hello"
b = a
a = a + " world"  # creates NEW string
print(b)  # "hello" ‚Äî unchanged

# Mutable ‚Äî modifying affects ALL references
a = [1, 2, 3]
b = a           # b points to SAME list
a.append(4)
print(b)        # [1, 2, 3, 4] ‚Äî also changed! üò±
```

> **Interview trap:** "What happens when you pass a list to a function?"  
> Answer: The function gets a **reference** to the same list. Changes inside the function **affect the original**.

---

## 15. Conversion Between Data Structures

| From ‚Üí To | `list` | `tuple` | `set` | `dict` | `str` |
|:----------|:------:|:-------:|:-----:|:------:|:-----:|
| **list** | ‚Äî | `tuple(lst)` | `set(lst)` | `dict(enumerate(lst))` | `str(lst)` |
| **tuple** | `list(tup)` | ‚Äî | `set(tup)` | `dict(enumerate(tup))` | `str(tup)` |
| **set** | `list(s)` | `tuple(s)` | ‚Äî | ‚ùå Need pairs | `str(s)` |
| **dict** | `list(d)` ‚Üí keys | `tuple(d)` ‚Üí keys | `set(d)` ‚Üí keys | ‚Äî | `str(d)` |
| **str** | `list(s)` ‚Üí chars | `tuple(s)` ‚Üí chars | `set(s)` ‚Üí unique chars | ‚ùå Need `json` | ‚Äî |

```python
# Quick conversions
lst = [1, 2, 3, 2, 1]
print(list(set(lst)))       # [1, 2, 3] ‚Äî remove duplicates
print(sorted(set(lst)))     # [1, 2, 3] ‚Äî unique + sorted

# Dict from two lists
keys = ["a", "b", "c"]
vals = [1, 2, 3]
d = dict(zip(keys, vals))   # {'a': 1, 'b': 2, 'c': 3}

# String to list of words
"hello world".split()       # ['hello', 'world']
# List of words to string
" ".join(["hello", "world"])  # 'hello world'
```

---

## 16. Comprehensions Comparison

| Type | Syntax | Example | Result |
|:-----|:-------|:--------|:-------|
| **List** | `[expr for x in iterable]` | `[x**2 for x in range(5)]` | `[0, 1, 4, 9, 16]` |
| **Set** | `{expr for x in iterable}` | `{x%3 for x in range(6)}` | `{0, 1, 2}` |
| **Dict** | `{k:v for k,v in iterable}` | `{x: x**2 for x in range(4)}` | `{0:0, 1:1, 2:4, 3:9}` |
| **Generator** | `(expr for x in iterable)` | `(x**2 for x in range(5))` | Generator object (lazy) |
| **Tuple** | ‚ùå No comprehension | Use `tuple(x for x in ...)` | Explicit conversion needed |

```python
# With condition (filter)
evens = [x for x in range(10) if x % 2 == 0]      # [0, 2, 4, 6, 8]

# Nested comprehension (matrix to flat)
matrix = [[1,2], [3,4], [5,6]]
flat = [x for row in matrix for x in row]           # [1, 2, 3, 4, 5, 6]

# Dict comprehension (swap keys and values)
d = {"a": 1, "b": 2}
swapped = {v: k for k, v in d.items()}              # {1: 'a', 2: 'b'}
```

---

## 17. Generator vs List ‚Äî Memory Comparison

| Feature | `list` | `generator` |
|:--------|:------:|:-----------:|
| **Memory** | Stores ALL items in memory | Stores **one item at a time** ‚≠ê |
| **Syntax** | `[x for x in range(n)]` | `(x for x in range(n))` |
| **Access** | Random access `lst[5]` | Sequential only (one direction) |
| **Reusable** | ‚úÖ Yes, iterate multiple times | ‚ùå No, exhausted after one pass |
| **Speed (create)** | Slower (builds entire list) | ‚≠ê Instant (lazy) |
| **Speed (iterate)** | Same | Same |
| **Use case** | Small data, need re-access | Large/infinite data, single pass |

```python
import sys

# List: stores 1 million items ‚Üí lots of memory
lst = [x for x in range(1_000_000)]
print(sys.getsizeof(lst))  # ~8,448,728 bytes (8 MB!)

# Generator: stores nothing until asked ‚Üí tiny memory
gen = (x for x in range(1_000_000))
print(sys.getsizeof(gen))  # ~200 bytes! üöÄ
```

---

## 18. Interview Quick-Fire ‚Äî Common Gotchas

| Gotcha | What Happens | Why |
|:-------|:-------------|:----|
| `{} is NOT a set` | `type({})` ‚Üí `dict` | Use `set()` for empty set |
| `(1)` is NOT a tuple | `type((1))` ‚Üí `int` | Use `(1,)` ‚Äî trailing comma! |
| `a = b = []` shared | Both point to SAME list | Use `a, b = [], []` |
| `[x]*3` nested trap | `[[1]]*3` ‚Üí 3 same references! | Use `[[1] for _ in range(3)]` |
| `dict.keys()` is a view | Changes when dict changes | Convert: `list(d.keys())` for snapshot |
| `set` ordering random | `{3,1,2}` might print `{1,2,3}` | Sets have no guaranteed order |
| `sorted(dict)` gives keys | Not key-value pairs | Use `sorted(d.items())` |
| Default mutable arg trap | `def f(x=[]):` ‚Üí shared across calls! | Use `def f(x=None):` |
| `tuple + tuple` creates new | `(1,) + (2,)` = `(1, 2)` | Tuples are immutable, can't modify |
| `in` on dict checks KEYS | `1 in {1: "a"}` ‚Üí True | Use `1 in d.values()` for values |

---

## 19. Real Backend Use Cases

| Data Structure | Backend Use Case |
|:--------------|:-----------------|
| `list` | API response arrays, batch processing, ordered results |
| `tuple` | Database row, function return values, dict keys (composite) |
| `set` | Removing duplicates, tag systems, permission checks |
| `dict` | JSON payloads, config files, caching, session storage |
| `defaultdict(list)` | Grouping (group users by city, orders by status) |
| `Counter` | Analytics (word frequency, vote counting, log analysis) |
| `deque` | Rate limiting (sliding window), task queue, undo/redo |
| `OrderedDict` | LRU cache implementation |
| `namedtuple` | Lightweight data transfer objects (DTOs) |
| `dataclass` | Domain models, request/response schemas |
| `frozenset` | Immutable permission sets, cache keys |
| `heapq` | Job scheduling, top-K queries, priority task queues |

---

## 20. Cheat Sheet ‚Äî One-Line Summary for Each

```
list      ‚Üí Ordered, mutable, allows duplicates, O(1) index, O(n) search
tuple     ‚Üí Ordered, immutable, allows duplicates, hashable, memory-efficient
set       ‚Üí Unordered, mutable, NO duplicates, O(1) search, math operations
frozenset ‚Üí Immutable set, can be dict key
dict      ‚Üí Key-value pairs, O(1) lookup, ordered since 3.7+
str       ‚Üí Immutable sequence of Unicode characters
bytes     ‚Üí Immutable sequence of bytes (0-255)
bytearray ‚Üí Mutable sequence of bytes
deque     ‚Üí Double-ended queue, O(1) both ends
Counter   ‚Üí Dict subclass for counting
defaultdict ‚Üí Dict with auto-default for missing keys
OrderedDict ‚Üí Dict that compares order in equality
namedtuple ‚Üí Tuple with named fields
dataclass ‚Üí Class with auto __init__, __repr__, __eq__
heapq     ‚Üí Min-heap (priority queue)
array     ‚Üí Memory-efficient typed array
```

---

> **Pro tip:** Don't just read this. Open a Python shell and **test every example**.  
> Interviewers ask "what's the difference between X and Y" in almost **every** Python interview.

