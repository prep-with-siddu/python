# Python Data Structures ‚Äî Complete Table Comparison

> **Every comparison in TABLE format. No fluff. Just tables.**

---

## TABLE 1: All Data Structures at a Glance

| Data Structure | Ordered? | Mutable? | Duplicates? | Indexed? | Hashable? | Syntax | Memory |
|:--|:--:|:--:|:--:|:--:|:--:|:--|:--:|
| `list` | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ `[0]` | ‚ùå | `[1, 2, 3]` | Medium |
| `tuple` | ‚úÖ | ‚ùå | ‚úÖ | ‚úÖ `[0]` | ‚úÖ* | `(1, 2, 3)` | ‚≠ê Low |
| `set` | ‚ùå | ‚úÖ | ‚ùå | ‚ùå | ‚ùå | `{1, 2, 3}` | High |
| `frozenset` | ‚ùå | ‚ùå | ‚ùå | ‚ùå | ‚úÖ | `frozenset({1,2})` | High |
| `dict` | ‚úÖ (3.7+) | ‚úÖ | Keys ‚ùå / Values ‚úÖ | By key | ‚ùå | `{"a": 1}` | High |
| `str` | ‚úÖ | ‚ùå | ‚úÖ | ‚úÖ `[0]` | ‚úÖ | `"hello"` | Low |
| `bytes` | ‚úÖ | ‚ùå | ‚úÖ | ‚úÖ `[0]` | ‚úÖ | `b"hello"` | Low |
| `bytearray` | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ `[0]` | ‚ùå | `bytearray(b"hi")` | Low |
| `deque` | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ `[0]` | ‚ùå | `deque([1,2])` | Medium |
| `namedtuple` | ‚úÖ | ‚ùå | ‚úÖ | ‚úÖ `[0]` + `.name` | ‚úÖ* | `Point(1, 2)` | ‚≠ê Low |
| `dataclass` | ‚úÖ | ‚úÖ (‚ùå if frozen) | ‚úÖ | By `.name` | Only frozen | `User("Sid")` | Medium |
| `Counter` | ‚úÖ | ‚úÖ | N/A (counts) | By key | ‚ùå | `Counter("aab")` | High |
| `defaultdict` | ‚úÖ | ‚úÖ | Keys ‚ùå / Values ‚úÖ | By key | ‚ùå | `defaultdict(list)` | High |
| `OrderedDict` | ‚úÖ | ‚úÖ | Keys ‚ùå / Values ‚úÖ | By key | ‚ùå | `OrderedDict()` | High |
| `array.array` | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ `[0]` | ‚ùå | `array('i',[1,2])` | ‚≠ê Low |
| `heapq` | ‚úÖ (heap order) | ‚úÖ | ‚úÖ | ‚ùå (peek `[0]`) | ‚ùå | `heappush(h, x)` | Low |

> `*` Tuple/namedtuple are hashable **only if ALL elements inside are hashable**

---

## TABLE 2: list vs tuple vs set vs dict ‚Äî Head to Head

| Feature | `list` | `tuple` | `set` | `dict` |
|:--|:--|:--|:--|:--|
| **Create empty** | `[]` or `list()` | `()` or `tuple()` | `set()` ‚ö†Ô∏è NOT `{}` | `{}` or `dict()` |
| **Can contain** | Any type | Any type | Hashable only | Key: Hashable, Value: Any |
| **Best for** | Ordered changeable data | Fixed/constant data | Unique items, fast lookup | Key-value mapping |
| **Preserves order** | ‚úÖ Always | ‚úÖ Always | ‚ùå Never | ‚úÖ Since Python 3.7 |
| **Allows duplicates** | ‚úÖ Yes | ‚úÖ Yes | ‚ùå No (auto-removes) | Keys ‚ùå / Values ‚úÖ |
| **Can modify** | ‚úÖ Add/remove/change | ‚ùå Immutable | ‚úÖ Add/remove | ‚úÖ Add/remove/change |
| **Can be dict key** | ‚ùå | ‚úÖ | ‚ùå | ‚ùå |
| **Can be in set** | ‚ùå | ‚úÖ | ‚ùå | ‚ùå |
| **Thread-safe** | ‚ùå | ‚úÖ (immutable) | ‚ùå | ‚ùå |
| **Memory (5 items)** | ~120 bytes | ~80 bytes ‚≠ê | ~216 bytes | ~232 bytes |

---

## TABLE 3: Time Complexity (Big O) ‚Äî Every Operation

| Operation | `list` | `tuple` | `set` | `dict` | `deque` |
|:--|:--:|:--:|:--:|:--:|:--:|
| **Access by index** `x[i]` | O(1) ‚úÖ | O(1) ‚úÖ | ‚ùå N/A | ‚ùå N/A | O(n) üê¢ |
| **Access by key** `x[k]` | ‚ùå N/A | ‚ùå N/A | ‚ùå N/A | O(1) ‚úÖ | ‚ùå N/A |
| **Search** `item in x` | O(n) üê¢ | O(n) üê¢ | **O(1)** üöÄ | **O(1)** üöÄ | O(n) üê¢ |
| **Append right** | O(1) | ‚ùå | O(1) | O(1) | O(1) |
| **Append left** | O(n) üê¢ | ‚ùå | N/A | N/A | **O(1)** üöÄ |
| **Insert at middle** | O(n) | ‚ùå | N/A | O(1) | O(n) |
| **Delete by value** | O(n) | ‚ùå | O(1) | O(1) | O(n) |
| **Delete by index** | O(n) | ‚ùå | ‚ùå | ‚ùå | O(n) |
| **Pop last** | O(1) | ‚ùå | N/A | O(1) | O(1) |
| **Pop first** | O(n) üê¢ | ‚ùå | N/A | N/A | **O(1)** üöÄ |
| **Sort** | O(n log n) | Use `sorted()` | ‚ùå | Use `sorted()` | ‚ùå |
| **Length** `len()` | O(1) | O(1) | O(1) | O(1) | O(1) |
| **Copy** | O(n) | O(1)* | O(n) | O(n) | O(n) |
| **Slice** `x[a:b]` | O(b-a) | O(b-a) | ‚ùå | ‚ùå | ‚ùå |

> `*` Tuple copy is O(1) ‚Äî Python reuses the same immutable object!

---

## TABLE 4: Best Data Structure for Each Task

| I need to... | Best Choice | Why |
|:--|:--|:--|
| Store items in order, change them later | `list` | Ordered + mutable |
| Store fixed data that won't change | `tuple` | Immutable + memory-efficient |
| Check if item exists (fast) | `set` or `dict` | O(1) hash lookup |
| Remove duplicates from a list | `set` | `list(set(my_list))` |
| Map keys to values | `dict` | That's its job |
| Count occurrences | `Counter` | `Counter("banana")` ‚Üí `{'a':3}` |
| Group items by category | `defaultdict(list)` | No KeyError on missing keys |
| Fast append/pop from both ends | `deque` | O(1) on both sides |
| Store numeric data memory-efficiently | `array.array` | Same type, compact |
| Priority queue / get min fast | `heapq` | O(log n) push/pop, O(1) peek min |
| Tuple with named fields | `namedtuple` | `user.name` instead of `user[0]` |
| Class with auto __init__, __repr__ | `dataclass` | Less boilerplate |
| Immutable set (use as dict key) | `frozenset` | Hashable version of set |
| LRU cache | `OrderedDict` | `move_to_end()` + `popitem()` |

---

## TABLE 5: Adding Elements

| Method | `list` | `set` | `dict` | `deque` |
|:--|:--|:--|:--|:--|
| **Add one** | `.append(x)` | `.add(x)` | `d[key] = val` | `.append(x)` / `.appendleft(x)` |
| **Add multiple** | `.extend([1,2])` | `.update({1,2})` | `.update({k:v})` | `.extend([1,2])` |
| **Insert at pos** | `.insert(i, x)` | ‚ùå unordered | ‚ùå | `.insert(i, x)` |
| **Merge** | `a + b` | `a \| b` | `a \| b` (3.9+) | ‚ùå use `.extend()` |

---

## TABLE 6: Removing Elements

| Method | `list` | `set` | `dict` | `deque` |
|:--|:--|:--|:--|:--|
| **Remove by value** | `.remove(x)` raises `ValueError` | `.remove(x)` raises `KeyError` | `del d[k]` raises `KeyError` | `.remove(x)` |
| **Safe remove** | try/except | `.discard(x)` ‚úÖ no error | `.pop(k, default)` ‚úÖ | try/except |
| **Pop last** | `.pop()` | `.pop()` (random!) | `.popitem()` | `.pop()` |
| **Pop first** | `.pop(0)` üê¢ O(n) | ‚ùå | ‚ùå | `.popleft()` üöÄ O(1) |
| **Pop by key/index** | `.pop(i)` | ‚ùå | `.pop(key)` | ‚ùå |
| **Clear all** | `.clear()` | `.clear()` | `.clear()` | `.clear()` |

---

## TABLE 7: Set Operations

| Operation | Method | Operator | `{1,2,3}` OP `{2,3,4}` = |
|:--|:--|:--:|:--|
| **Union** (all from both) | `.union(b)` | `a \| b` | `{1, 2, 3, 4}` |
| **Intersection** (common) | `.intersection(b)` | `a & b` | `{2, 3}` |
| **Difference** (in a, not b) | `.difference(b)` | `a - b` | `{1}` |
| **Symmetric Diff** (not common) | `.symmetric_difference(b)` | `a ^ b` | `{1, 4}` |
| **Subset** (a inside b?) | `.issubset(b)` | `a <= b` | `False` |
| **Superset** (a contains b?) | `.issuperset(b)` | `a >= b` | `False` |
| **Disjoint** (no common?) | `.isdisjoint(b)` | ‚Äî | `False` |

---

## TABLE 8: Dict Variants from `collections`

| Type | Missing Key Behavior | Order Matters in `==`? | Extra Superpower | When to Use |
|:--|:--|:--:|:--|:--|
| `dict` | ‚ùå `KeyError` | ‚ùå No | Standard, built-in | General purpose |
| `defaultdict` | ‚úÖ Returns default | ‚ùå No | Auto-creates missing keys | Grouping, counting |
| `OrderedDict` | ‚ùå `KeyError` | ‚úÖ **Yes** | `.move_to_end()` | LRU cache, order-sensitive |
| `Counter` | ‚úÖ Returns `0` | ‚ùå No | `.most_common(n)`, math ops | Counting, frequency |
| `ChainMap` | Searches multiple dicts | ‚ùå No | Priority lookup across dicts | Config layering |

---

## TABLE 9: list vs deque vs array

| Feature | `list` | `deque` | `array.array` |
|:--|:--:|:--:|:--:|
| **Module** | built-in | `collections` | `array` |
| **Append right** | O(1) | O(1) | O(1) |
| **Append left** | O(n) üê¢ | **O(1)** üöÄ | O(n) üê¢ |
| **Pop right** | O(1) | O(1) | O(1) |
| **Pop left** | O(n) üê¢ | **O(1)** üöÄ | O(n) üê¢ |
| **Random access** `[i]` | **O(1)** üöÄ | O(n) üê¢ | O(1) |
| **Slicing** | ‚úÖ | ‚ùå | ‚úÖ |
| **Mixed types** | ‚úÖ | ‚úÖ | ‚ùå Same type only |
| **Memory** | High | Medium | **Low** ‚≠ê |
| **Best for** | General use | Queue/Deque | Typed numeric data |

---

## TABLE 10: Stack vs Queue vs Priority Queue

| Feature | Stack (LIFO) | Queue (FIFO) | Priority Queue |
|:--|:--:|:--:|:--:|
| **Meaning** | Last In, First Out | First In, First Out | Highest priority out first |
| **Real example** | Stack of plates | Standing in line | Hospital ER |
| **Python (simple)** | `list` | `deque` | `heapq` |
| **Python (thread-safe)** | `queue.LifoQueue` | `queue.Queue` | `queue.PriorityQueue` |
| **Push** | `.append(x)` O(1) | `.append(x)` O(1) | `heappush(h,x)` O(log n) |
| **Pop** | `.pop()` O(1) | `.popleft()` O(1) | `heappop(h)` O(log n) |
| **Peek** | `stack[-1]` O(1) | `queue[0]` O(1) | `heap[0]` O(1) |

---

## TABLE 11: tuple vs namedtuple vs dataclass

| Feature | `tuple` | `namedtuple` | `dataclass` |
|:--|:--:|:--:|:--:|
| **Module** | built-in | `collections` | `dataclasses` |
| **Access by index** | ‚úÖ `t[0]` | ‚úÖ `t[0]` | ‚ùå |
| **Access by name** | ‚ùå | ‚úÖ `t.name` | ‚úÖ `t.name` |
| **Mutable** | ‚ùå | ‚ùå | ‚úÖ (‚ùå if `frozen=True`) |
| **Type hints** | ‚ùå | ‚ùå | ‚úÖ |
| **Default values** | ‚ùå | ‚úÖ | ‚úÖ |
| **Custom methods** | ‚ùå | ‚ùå | ‚úÖ |
| **Inheritance** | ‚ùå | ‚ö†Ô∏è Limited | ‚úÖ |
| **Hashable** | ‚úÖ* | ‚úÖ* | Only if `frozen=True` |
| **Auto `__repr__`** | Basic | ‚úÖ Readable | ‚úÖ Readable |
| **Auto `__eq__`** | ‚úÖ | ‚úÖ | ‚úÖ |
| **Memory** | ‚≠ê Lowest | ‚≠ê Low | Medium |
| **Best for** | Quick fixed data | Readable fixed records | Rich data objects |

---

## TABLE 12: str vs bytes vs bytearray

| Feature | `str` | `bytes` | `bytearray` |
|:--|:--:|:--:|:--:|
| **Contains** | Unicode characters | Raw bytes (0-255) | Raw bytes (0-255) |
| **Mutable** | ‚ùå | ‚ùå | ‚úÖ |
| **Literal** | `"hello"` | `b"hello"` | `bytearray(b"hi")` |
| **Hashable** | ‚úÖ | ‚úÖ | ‚ùå |
| **Use case** | Text data | Binary data (files, network) | Mutable binary buffer |
| **Convert to bytes** | `.encode("utf-8")` | ‚Äî | `bytes(ba)` |
| **Convert to str** | ‚Äî | `.decode("utf-8")` | `.decode("utf-8")` |

---

## TABLE 13: Shallow Copy vs Deep Copy

| Type | New object? | Nested objects? | How to do it | Speed |
|:--|:--:|:--:|:--|:--:|
| **Assignment** `b = a` | ‚ùå Same object | Same references | `b = a` | O(1) ‚≠ê |
| **Shallow copy** | ‚úÖ New outer | ‚ö†Ô∏è **Still shared** | `a.copy()`, `list(a)`, `a[:]` | O(n) |
| **Deep copy** | ‚úÖ New everything | ‚úÖ **New copies** | `copy.deepcopy(a)` | O(n√óm) üê¢ |

```python
# Shallow copy TRAP
a = [[1, 2], [3, 4]]
b = a.copy()
b[0][0] = 99
print(a)  # [[99, 2], [3, 4]] ‚Üê ALSO changed! üò±

# Deep copy SAFE
import copy
c = copy.deepcopy(a)
c[0][0] = 99
print(a)  # [[1, 2], [3, 4]] ‚Üê Untouched ‚úÖ
```

---

## TABLE 14: Mutable vs Immutable

| Mutable (Can Change) | Immutable (Cannot Change) |
|:--|:--|
| `list` | `tuple` |
| `dict` | `str` |
| `set` | `int`, `float`, `bool` |
| `bytearray` | `bytes` |
| `deque` | `frozenset` |
| Custom objects (default) | `range` |
| `defaultdict`, `Counter`, `OrderedDict` | `None` |
| | `namedtuple` |
| | `dataclass(frozen=True)` |

---

## TABLE 15: Hashable vs Unhashable

| Type | Hashable? | Can be dict key? | Can be in set? |
|:--|:--:|:--:|:--:|
| `int`, `float`, `bool` | ‚úÖ | ‚úÖ | ‚úÖ |
| `str` | ‚úÖ | ‚úÖ | ‚úÖ |
| `tuple` (if all elements hashable) | ‚úÖ | ‚úÖ | ‚úÖ |
| `frozenset` | ‚úÖ | ‚úÖ | ‚úÖ |
| `bytes` | ‚úÖ | ‚úÖ | ‚úÖ |
| `None` | ‚úÖ | ‚úÖ | ‚úÖ |
| `list` | ‚ùå | ‚ùå | ‚ùå |
| `dict` | ‚ùå | ‚ùå | ‚ùå |
| `set` | ‚ùå | ‚ùå | ‚ùå |
| `bytearray` | ‚ùå | ‚ùå | ‚ùå |

> **Rule:** Mutable = NOT hashable. Immutable = hashable.

---

## TABLE 16: Comprehension Types

| Type | Syntax | Example | Result |
|:--|:--|:--|:--|
| **List** | `[expr for x in iter]` | `[x**2 for x in range(5)]` | `[0, 1, 4, 9, 16]` |
| **Set** | `{expr for x in iter}` | `{x%3 for x in range(6)}` | `{0, 1, 2}` |
| **Dict** | `{k:v for k,v in iter}` | `{x: x**2 for x in range(4)}` | `{0:0, 1:1, 2:4, 3:9}` |
| **Generator** | `(expr for x in iter)` | `(x**2 for x in range(5))` | Generator (lazy, low memory) |
| **Tuple** | ‚ùå None | Use `tuple(x for x in ...)` | Must convert explicitly |

---

## TABLE 17: Generator vs List

| Feature | `list` | `generator` |
|:--|:--:|:--:|
| **Memory** | ALL items in RAM | **One at a time** ‚≠ê |
| **1M items memory** | ~8 MB | ~200 bytes üöÄ |
| **Syntax** | `[x for x in range(n)]` | `(x for x in range(n))` |
| **Random access** `[5]` | ‚úÖ | ‚ùå Sequential only |
| **Reusable** | ‚úÖ Multiple iterations | ‚ùå Exhausted after one pass |
| **Creation speed** | Slower (builds all) | ‚≠ê Instant (lazy) |
| **Best for** | Small data, re-access | Large/infinite data, single pass |

---

## TABLE 18: Conversion Between Types

| From ‚Üì ‚Üí To ‚Üí | `list` | `tuple` | `set` | `dict` | `str` |
|:--|:--|:--|:--|:--|:--|
| **list** | ‚Äî | `tuple(lst)` | `set(lst)` | `dict(enumerate(lst))` | `str(lst)` |
| **tuple** | `list(tup)` | ‚Äî | `set(tup)` | `dict(enumerate(tup))` | `str(tup)` |
| **set** | `list(s)` | `tuple(s)` | ‚Äî | ‚ùå Need key-value pairs | `str(s)` |
| **dict** | `list(d)` ‚Üí keys | `tuple(d)` ‚Üí keys | `set(d)` ‚Üí keys | ‚Äî | `str(d)` |
| **str** | `list(s)` ‚Üí chars | `tuple(s)` ‚Üí chars | `set(s)` ‚Üí unique chars | ‚ùå Use `json` | ‚Äî |

---

## TABLE 19: Interview Gotchas

| Gotcha | What Happens | Correct Way |
|:--|:--|:--|
| `{}` is NOT a set | `type({})` ‚Üí `dict` | Use `set()` for empty set |
| `(1)` is NOT a tuple | `type((1))` ‚Üí `int` | Use `(1,)` ‚Äî trailing comma! |
| `a = b = []` | Both point to SAME list | `a, b = [], []` |
| `[[1]] * 3` | 3 references to SAME inner list | `[[1] for _ in range(3)]` |
| `dict.keys()` is a view | Changes when dict changes | `list(d.keys())` for snapshot |
| `set` ordering | `{3,1,2}` might print `{1,2,3}` | No guaranteed order |
| `sorted(dict)` | Returns only keys | `sorted(d.items())` for pairs |
| `def f(x=[]):` | Default list shared across calls! | `def f(x=None):` then `x = x or []` |
| `in` on dict | Checks KEYS, not values | `in d.values()` for values |
| `tuple + tuple` | Creates NEW tuple | Can't modify in-place (immutable) |

---

## TABLE 20: Real Backend Use Cases

| Data Structure | Backend Use Case |
|:--|:--|
| `list` | API response arrays, batch processing, ordered results |
| `tuple` | DB row, function returns, composite dict keys |
| `set` | Remove duplicates, tag systems, permission checks |
| `dict` | JSON payloads, config, caching, session storage |
| `defaultdict(list)` | Grouping (users by city, orders by status) |
| `Counter` | Analytics (word frequency, vote counting, logs) |
| `deque` | Rate limiting (sliding window), task queue, undo/redo |
| `OrderedDict` | LRU cache implementation |
| `namedtuple` | Lightweight DTOs (data transfer objects) |
| `dataclass` | Domain models, request/response schemas |
| `frozenset` | Immutable permission sets, cache keys |
| `heapq` | Job scheduling, top-K queries, priority tasks |
| `array.array` | Binary protocols, memory-critical numeric storage |

---

## TABLE 21: One-Line Cheat Sheet

| Data Structure | One-Line Summary |
|:--|:--|
| `list` | Ordered, mutable, duplicates OK, O(1) index, O(n) search |
| `tuple` | Ordered, immutable, duplicates OK, hashable, memory-efficient |
| `set` | Unordered, mutable, NO duplicates, O(1) search |
| `frozenset` | Immutable set, can be dict key |
| `dict` | Key-value, O(1) lookup, ordered since 3.7+ |
| `str` | Immutable Unicode sequence |
| `bytes` | Immutable byte sequence (0-255) |
| `bytearray` | Mutable byte sequence |
| `deque` | Double-ended queue, O(1) both ends |
| `Counter` | Dict for counting, `.most_common(n)` |
| `defaultdict` | Dict with auto-default for missing keys |
| `OrderedDict` | Dict where order matters in equality |
| `namedtuple` | Tuple with named fields |
| `dataclass` | Class with auto `__init__`, `__repr__`, `__eq__` |
| `heapq` | Min-heap (priority queue) |
| `array.array` | Memory-efficient typed array |

---

> **Revision tip:** Read these tables once daily for a week. You'll never forget them.
