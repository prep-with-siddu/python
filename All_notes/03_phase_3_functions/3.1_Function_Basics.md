# 3.1 Function Basics â€” Notes

> **Status**: âœ… Completed  
> **Date**: 28 February 2026

---

## 1. Defining Functions (`def`)

A function is a **reusable block of code** that performs a specific task.

```python
# Basic syntax
def function_name():
    """What this function does"""
    # code here
    pass

# Example
def greet():
    print("Hello, World!")

greet()         # Output: Hello, World!
greet()         # Can call it multiple times
```

### Key Rules
| Rule | Example |
|------|---------|
| Use `def` keyword | `def my_func():` |
| Name in `snake_case` | `def calculate_total():` âœ… not `def CalculateTotal():` âŒ |
| Must have `()` and `:` | `def greet():` |
| Body is indented (4 spaces) | Standard Python indentation |
| Function must be defined BEFORE calling it | Define first, call later |

```python
# Function with logic
def is_even(number):
    if number % 2 == 0:
        return True
    return False

print(is_even(4))   # True
print(is_even(7))   # False
```

> ğŸ’¡ **Naming tip**: Functions should be verbs or verb phrases â€” `get_user()`, `calculate_tax()`, `send_email()`, not `user()` or `tax()`.

---

## 2. Parameters and Arguments

**Parameters** = variables in the function definition (placeholders).  
**Arguments** = actual values passed when calling the function.

```python
#         parameters â†“
def greet(name, age):
    print(f"Hi {name}, you are {age} years old!")

#     arguments â†“
greet("Sid", 25)      # Hi Sid, you are 25 years old!
greet("Rahul", 30)    # Hi Rahul, you are 30 years old!
```

### Parameter vs Argument â€” Don't Confuse!
```python
def add(a, b):       # a, b are PARAMETERS (definition)
    return a + b

add(5, 3)            # 5, 3 are ARGUMENTS (call)
```

### Multiple Parameters
```python
def create_user(name, email, role):
    print(f"Created {role}: {name} ({email})")

create_user("Sid", "sid@mail.com", "admin")
# Output: Created admin: Sid (sid@mail.com)
```

> ğŸ’¡ **Parameters** = what the function expects. **Arguments** = what you actually give it.

---

## 3. `return` Statement

`return` sends a value **back** to the caller. Without `return`, a function returns `None`.

```python
# With return â€” gives back a value
def add(a, b):
    return a + b

result = add(5, 3)
print(result)          # 8

# Without return â€” returns None
def greet(name):
    print(f"Hello {name}")

x = greet("Sid")       # Prints: Hello Sid
print(x)               # None  (no return statement!)
```

### Return Stops the Function
```python
def check_age(age):
    if age < 0:
        return "Invalid age"     # Function STOPS here if age < 0
    if age >= 18:
        return "Adult"           # Function STOPS here if age >= 18
    return "Minor"               # Only reaches here if age is 0-17

print(check_age(25))    # Adult
print(check_age(-5))    # Invalid age
print(check_age(10))    # Minor
```

### Returning Multiple Values (Tuple Unpacking)
```python
def get_user_info():
    name = "Sid"
    age = 25
    city = "Bangalore"
    return name, age, city     # Returns a tuple

# Unpack the returned values
name, age, city = get_user_info()
print(name)    # Sid
print(age)     # 25
print(city)    # Bangalore

# Or capture as a tuple
result = get_user_info()
print(result)  # ('Sid', 25, 'Bangalore')
```

### Return a Dictionary (Common in Backend)
```python
def get_response(data, status="success"):
    return {
        "status": status,
        "data": data,
        "count": len(data) if isinstance(data, list) else 1
    }

response = get_response(["item1", "item2"])
print(response)
# {'status': 'success', 'data': ['item1', 'item2'], 'count': 2}
```

> ğŸ’¡ **Backend tip**: Functions that process data should **always return**, not just `print()`. Printing is for debugging, returning is for building APIs.

---

## 4. Default Parameter Values

You can set **default values** for parameters. If no argument is passed, the default is used.

```python
def greet(name, greeting="Hello"):
    print(f"{greeting}, {name}!")

greet("Sid")              # Hello, Sid!       (uses default)
greet("Sid", "Namaste")   # Namaste, Sid!     (overrides default)
```

### Rules for Default Parameters
```python
# âœ… Correct â€” defaults come AFTER non-defaults
def create_user(name, role="user", is_active=True):
    print(f"{name} | Role: {role} | Active: {is_active}")

create_user("Sid")                          # Sid | Role: user | Active: True
create_user("Sid", "admin")                 # Sid | Role: admin | Active: True
create_user("Sid", "admin", False)          # Sid | Role: admin | Active: False

# âŒ Wrong â€” default before non-default causes SyntaxError
# def create_user(role="user", name):   # SyntaxError!
```

### âš ï¸ DANGER: Mutable Default Arguments (Common Interview Question!)
```python
# âŒ BUG â€” mutable default (list) is shared across ALL calls!
def add_item(item, cart=[]):
    cart.append(item)
    return cart

print(add_item("apple"))    # ['apple']
print(add_item("banana"))   # ['apple', 'banana']  ğŸ˜± NOT ['banana']!
# The same list object is reused!

# âœ… FIX â€” use None as default, create new list inside
def add_item(item, cart=None):
    if cart is None:
        cart = []
    cart.append(item)
    return cart

print(add_item("apple"))    # ['apple']
print(add_item("banana"))   # ['banana']  âœ… Correct!
```

> ğŸš¨ **This is a top Python interview question!** Never use mutable objects (`list`, `dict`, `set`) as default parameter values. Always use `None` and create inside the function.

---

## 5. Keyword Arguments vs Positional Arguments

### Positional Arguments â€” Order matters
```python
def power(base, exponent):
    return base ** exponent

power(2, 3)     # 8  â†’ base=2, exponent=3
power(3, 2)     # 9  â†’ base=3, exponent=2  (different result! order matters)
```

### Keyword Arguments â€” Name matters, order doesn't
```python
power(base=2, exponent=3)     # 8
power(exponent=3, base=2)     # 8  (same result! order doesn't matter)
```

### Mixing Both (Positional FIRST, then Keyword)
```python
def create_user(name, age, city="Unknown", role="user"):
    print(f"{name}, {age}, {city}, {role}")

# âœ… Valid combinations
create_user("Sid", 25)                          # Positional only
create_user("Sid", 25, city="Bangalore")        # Mix: positional + keyword
create_user("Sid", 25, role="admin")            # Skip city, use keyword
create_user(name="Sid", age=25, role="admin")   # All keywords

# âŒ Invalid
# create_user(name="Sid", 25)                   # SyntaxError! Keyword before positional
# create_user("Sid", name="Sid")                # TypeError! Duplicate argument
```

### Forcing Keyword-Only or Positional-Only (Python 3.8+)
```python
# Everything after * must be keyword-only
def greet(name, *, greeting="Hello", punctuation="!"):
    print(f"{greeting}, {name}{punctuation}")

greet("Sid")                                # Hello, Sid!
greet("Sid", greeting="Hey")                # Hey, Sid!
# greet("Sid", "Hey")                       # âŒ TypeError! Must use keyword

# Everything before / must be positional-only (Python 3.8+)
def add(a, b, /):
    return a + b

add(5, 3)           # âœ… 8
# add(a=5, b=3)     # âŒ TypeError! Must be positional

# Combined
def func(pos_only, /, normal, *, kw_only):
    print(pos_only, normal, kw_only)

func(1, 2, kw_only=3)        # âœ…
func(1, normal=2, kw_only=3) # âœ…
```

> ğŸ’¡ **Backend tip**: In APIs, forcing keyword-only arguments makes function calls more readable â€” `create_order(user_id=5, product_id=10)` is clearer than `create_order(5, 10)`.

---

## 6. `*args` and `**kwargs`

### `*args` â€” Variable Positional Arguments (Tuple)
```python
def add(*args):
    print(type(args))    # <class 'tuple'>
    print(args)          # (1, 2, 3, 4, 5)
    return sum(args)

print(add(1, 2, 3))           # 6
print(add(1, 2, 3, 4, 5))     # 15
print(add(10))                 # 10
print(add())                   # 0
```

### `**kwargs` â€” Variable Keyword Arguments (Dictionary)
```python
def print_info(**kwargs):
    print(type(kwargs))    # <class 'dict'>
    for key, value in kwargs.items():
        print(f"  {key}: {value}")

print_info(name="Sid", age=25, city="Bangalore")
# name: Sid
# age: 25
# city: Bangalore
```

### Combining Everything (Order Matters!)
```python
#                  â†“ positional  â†“ *args   â†“ keyword  â†“ **kwargs
def mega_function(required, *args, default="hi", **kwargs):
    print(f"required: {required}")
    print(f"args: {args}")
    print(f"default: {default}")
    print(f"kwargs: {kwargs}")

mega_function("hello", 1, 2, 3, default="bye", x=10, y=20)
# required: hello
# args: (1, 2, 3)
# default: bye
# kwargs: {'x': 10, 'y': 20}
```

### Order Rule
```
def func(positional, default=val, *args, **kwargs)
# OR more commonly:
def func(positional, *args, default=val, **kwargs)
```

### Real-World Usage â€” Backend Example
```python
def log_event(event_type, *tags, severity="info", **metadata):
    """Log an event with flexible parameters"""
    print(f"[{severity.upper()}] {event_type}")
    if tags:
        print(f"  Tags: {', '.join(tags)}")
    for key, value in metadata.items():
        print(f"  {key}: {value}")

log_event("user_login", "auth", "security", 
          severity="info", user_id=42, ip="192.168.1.1")
# [INFO] user_login
#   Tags: auth, security
#   user_id: 42
#   ip: 192.168.1.1
```

### Unpacking with `*` and `**`
```python
# Unpacking a list into positional args
nums = [1, 2, 3]
print(add(*nums))    # Same as add(1, 2, 3) â†’ 6

# Unpacking a dict into keyword args
user_data = {"name": "Sid", "age": 25, "city": "Bangalore"}
print_info(**user_data)   # Same as print_info(name="Sid", age=25, city="Bangalore")
```

> ğŸ’¡ **When to use**:
> - `*args` â†’ When you don't know how many arguments will be passed (like `print()` itself!)
> - `**kwargs` â†’ When you want to accept any keyword argument (common in decorators, wrappers, configs)

---

## 7. Docstrings and Function Documentation

Docstrings are **triple-quoted strings** right after `def` that document what a function does.

```python
def calculate_tax(amount, tax_rate=0.18):
    """
    Calculate tax for a given amount.
    
    Args:
        amount (float): The base amount before tax.
        tax_rate (float): Tax rate as decimal. Default is 0.18 (18% GST).
    
    Returns:
        float: The tax amount.
    
    Raises:
        ValueError: If amount is negative.
    
    Examples:
        >>> calculate_tax(1000)
        180.0
        >>> calculate_tax(1000, 0.05)
        50.0
    """
    if amount < 0:
        raise ValueError("Amount cannot be negative")
    return amount * tax_rate
```

### Accessing Docstrings
```python
# Method 1: help()
help(calculate_tax)

# Method 2: __doc__ attribute
print(calculate_tax.__doc__)

# Method 3: In REPL
# >>> calculate_tax?         (IPython/Jupyter)
```

### Common Docstring Styles

#### Google Style (Recommended â€” most readable)
```python
def fetch_user(user_id, include_posts=False):
    """Fetch a user from the database.

    Args:
        user_id (int): The unique ID of the user.
        include_posts (bool): Whether to include user's posts. Defaults to False.

    Returns:
        dict: User data with optional posts.

    Raises:
        UserNotFoundError: If no user exists with the given ID.
    """
    pass
```

#### NumPy/Sphinx Style
```python
def fetch_user(user_id, include_posts=False):
    """
    Fetch a user from the database.

    Parameters
    ----------
    user_id : int
        The unique ID of the user.
    include_posts : bool, optional
        Whether to include user's posts (default is False).

    Returns
    -------
    dict
        User data with optional posts.
    """
    pass
```

### One-Line Docstrings (for simple functions)
```python
def add(a, b):
    """Return the sum of a and b."""
    return a + b
```

### Why Docstrings Matter in Backend
1. **API documentation** â€” Tools like Swagger auto-generate docs from docstrings
2. **Team collaboration** â€” Others understand your code without reading implementation
3. **IDE support** â€” VS Code / PyCharm show docstrings on hover
4. **`help()`** â€” Built-in way to read documentation

> ğŸ’¡ **Rule of thumb**: Every function that will be used by other developers (or your future self) should have a docstring. At minimum: what it does, what it takes, what it returns.

---

## ğŸ”— Quick Reference

```python
# Define a function
def func_name(param1, param2="default"):
    """Docstring"""
    return result

# Keyword vs Positional
func(1, 2)                    # Positional
func(param1=1, param2=2)     # Keyword
func(1, param2=2)            # Mixed

# *args and **kwargs
def flex(*args, **kwargs):    # Accept anything
    pass

# Unpacking
func(*list_var)               # Unpack list â†’ positional
func(**dict_var)              # Unpack dict â†’ keyword

# Force keyword-only (after *)
def func(a, *, b):           # b MUST be keyword
    pass

# Force positional-only (before /)
def func(a, /, b):           # a MUST be positional
    pass
```

---

> ğŸ“ **Next up**: Section 3.2 â€” Advanced Functions (lambda, closures, decorators, generators, itertools)
