# 3.2 Advanced Functions ‚Äî Notes

> **Status**: üìù Not Started  
> **Date**: 28 February 2026

---

## 1. First-Class Functions (Functions as Objects)

In Python, functions are **first-class citizens** ‚Äî they can be:
- Assigned to variables
- Passed as arguments
- Returned from other functions
- Stored in data structures

```python
# 1. Assign a function to a variable
def greet(name):
    return f"Hello, {name}!"

say_hello = greet          # No parentheses! Assigning the function itself
print(say_hello("Sid"))    # Hello, Sid!
print(type(say_hello))     # <class 'function'>

# 2. Store functions in a list
def add(a, b): return a + b
def sub(a, b): return a - b
def mul(a, b): return a * b

operations = [add, sub, mul]

for op in operations:
    print(op(10, 5))       # 15, 5, 50

# 3. Store in a dictionary (very useful in backend!)
handlers = {
    "add": add,
    "sub": sub,
    "mul": mul,
}

action = "add"
result = handlers[action](10, 5)    # 15
# This pattern is used instead of long if-elif chains!
```

### Real-World Backend Example
```python
# Instead of this:
def process_event(event_type, data):
    if event_type == "user_created":
        handle_user_created(data)
    elif event_type == "order_placed":
        handle_order_placed(data)
    elif event_type == "payment_done":
        handle_payment_done(data)

# Do this (cleaner, extensible):
event_handlers = {
    "user_created": handle_user_created,
    "order_placed": handle_order_placed,
    "payment_done": handle_payment_done,
}

def process_event(event_type, data):
    handler = event_handlers.get(event_type)
    if handler:
        handler(data)
    else:
        print(f"Unknown event: {event_type}")
```

> üí° Functions being first-class is what makes **decorators**, **callbacks**, and **strategy patterns** possible in Python.

---

## 2. Higher-Order Functions

A **higher-order function** either:
- **Takes** a function as an argument, OR
- **Returns** a function

```python
# Takes a function as argument
def apply_operation(func, a, b):
    return func(a, b)

def add(x, y): return x + y
def mul(x, y): return x * y

print(apply_operation(add, 5, 3))    # 8
print(apply_operation(mul, 5, 3))    # 15

# Returns a function
def create_multiplier(factor):
    def multiply(number):
        return number * factor
    return multiply                  # Returns the inner function

double = create_multiplier(2)
triple = create_multiplier(3)

print(double(5))     # 10
print(triple(5))     # 15
print(double(100))   # 200
```

### Built-in Higher-Order Functions
Python has several built-in higher-order functions: `map()`, `filter()`, `sorted()`, `min()`, `max()` ‚Äî all accept a function as argument.

```python
names = ["sid", "rahul", "amit"]

# sorted() takes a key function
print(sorted(names, key=len))          # ['sid', 'amit', 'rahul']
print(sorted(names, key=str.upper))    # ['amit', 'rahul', 'sid']

# min/max with key
users = [{"name": "Sid", "age": 25}, {"name": "Rahul", "age": 30}]
youngest = min(users, key=lambda u: u["age"])
print(youngest)    # {'name': 'Sid', 'age': 25}
```

> üí° If a function takes another function as input or returns one ‚Äî it's a higher-order function.

---

## 3. Lambda Functions

**Lambda** = anonymous (nameless), single-expression function.

```python
# Syntax: lambda arguments: expression

# Regular function
def add(a, b):
    return a + b

# Same thing as lambda
add = lambda a, b: a + b

print(add(5, 3))    # 8
```

### Lambda is Best Used Inline (Not Assigned to Variables)
```python
# ‚úÖ Good ‚Äî lambda used inline
numbers = [1, -2, 3, -4, 5]
sorted_nums = sorted(numbers, key=lambda x: abs(x))
print(sorted_nums)   # [1, -2, 3, -4, 5]

users = [("Sid", 25), ("Rahul", 30), ("Amit", 22)]
users.sort(key=lambda user: user[1])   # Sort by age
print(users)   # [('Amit', 22), ('Sid', 25), ('Rahul', 30)]

# ‚ùå Bad practice ‚Äî don't assign lambda to a variable
# square = lambda x: x ** 2   # Use def instead for named functions
```

### Lambda Limitations
- Only **one expression** (no `if` blocks, no loops, no multiple statements)
- Can use ternary though: `lambda x: "even" if x % 2 == 0 else "odd"`
- No docstrings
- Harder to debug (shows as `<lambda>` in tracebacks)

```python
# Ternary in lambda
classify = lambda x: "even" if x % 2 == 0 else "odd"
print(classify(4))    # even
print(classify(7))    # odd
```

> üí° **Rule**: Use `lambda` for short, throwaway functions (especially in `sorted()`, `map()`, `filter()`). Use `def` for anything else.

---

## 4. `map()`, `filter()`, `reduce()`

### `map()` ‚Äî Apply a function to every element
```python
numbers = [1, 2, 3, 4, 5]

# map(function, iterable) ‚Üí returns map object (lazy)
squared = list(map(lambda x: x ** 2, numbers))
print(squared)    # [1, 4, 9, 16, 25]

# Same with a named function
def double(x):
    return x * 2

doubled = list(map(double, numbers))
print(doubled)    # [2, 4, 6, 8, 10]

# map with multiple iterables
a = [1, 2, 3]
b = [10, 20, 30]
sums = list(map(lambda x, y: x + y, a, b))
print(sums)    # [11, 22, 33]

# üí° Pythonic alternative ‚Äî list comprehension (preferred!)
squared = [x ** 2 for x in numbers]    # Same result, more readable
```

### `filter()` ‚Äî Keep elements that pass a test
```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# filter(function, iterable) ‚Üí keeps items where function returns True
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(evens)    # [2, 4, 6, 8, 10]

# Remove empty strings
words = ["hello", "", "world", "", "python"]
non_empty = list(filter(None, words))    # None removes falsy values
print(non_empty)    # ['hello', 'world', 'python']

# üí° Pythonic alternative ‚Äî list comprehension (preferred!)
evens = [x for x in numbers if x % 2 == 0]    # Same result
```

### `reduce()` ‚Äî Reduce all elements to a single value
```python
from functools import reduce

numbers = [1, 2, 3, 4, 5]

# reduce(function, iterable, [initial])
total = reduce(lambda acc, x: acc + x, numbers)
print(total)    # 15

# How it works step by step:
# Step 1: acc=1, x=2 ‚Üí 3
# Step 2: acc=3, x=3 ‚Üí 6
# Step 3: acc=6, x=4 ‚Üí 10
# Step 4: acc=10, x=5 ‚Üí 15

# With initial value
total = reduce(lambda acc, x: acc + x, numbers, 100)
print(total)    # 115  (starts from 100)

# Find max (manual way)
maximum = reduce(lambda a, b: a if a > b else b, numbers)
print(maximum)    # 5

# üí° Prefer built-in sum(), max(), min() over reduce for simple cases
print(sum(numbers))    # 15 ‚Äî much cleaner!
```

### When to Use What?
| Function | Use When | Pythonic Alternative |
|----------|----------|---------------------|
| `map()` | Transform each element | List comprehension `[f(x) for x in lst]` |
| `filter()` | Keep elements matching condition | `[x for x in lst if cond(x)]` |
| `reduce()` | Combine all into one value | `sum()`, `max()`, `min()`, or a loop |

> üí° **In modern Python, list comprehensions are preferred** over `map()`/`filter()`. But know both ‚Äî they appear in interviews and legacy code.

---

## 5. Closures (Nested Function with Enclosing Scope)

A **closure** is a function that **remembers** variables from its enclosing scope, even after the outer function has finished.

```python
def outer(message):
    # 'message' is in the enclosing scope
    
    def inner():
        print(message)    # inner "closes over" message
    
    return inner          # Return the inner function

hello_func = outer("Hello!")
hello_func()              # Hello!  ‚Äî remembers "Hello!" even though outer() finished!

bye_func = outer("Goodbye!")
bye_func()                # Goodbye!  ‚Äî different closure with different message
```

### How Closures Work
```python
def counter():
    count = 0              # Enclosing variable
    
    def increment():
        nonlocal count     # Required to modify enclosing variable
        count += 1
        return count
    
    return increment

c1 = counter()
print(c1())    # 1
print(c1())    # 2
print(c1())    # 3

c2 = counter()   # New closure, fresh count!
print(c2())    # 1 (independent from c1)
print(c1())    # 4 (c1 continues its own count)
```

### Three Conditions for a Closure
1. There must be a **nested function** (function inside a function)
2. The inner function must **reference a variable** from the outer function
3. The outer function must **return** the inner function

### Checking if Something is a Closure
```python
def outer(x):
    def inner(y):
        return x + y
    return inner

closure = outer(10)
print(closure.__closure__)                    # (<cell ...>,)
print(closure.__closure__[0].cell_contents)   # 10  ‚Äî the captured value!
```

> üí° Closures are the **foundation of decorators**. Understand closures first, and decorators will make perfect sense.

---

## 6. `nonlocal` Keyword

`nonlocal` lets you **modify** a variable from the enclosing (outer) function's scope.

```python
# Without nonlocal ‚Äî creates a NEW local variable
def outer():
    count = 0
    def inner():
        count = 10         # This creates a NEW local variable, doesn't modify outer's count
        print(f"Inner count: {count}")
    inner()
    print(f"Outer count: {count}")

outer()
# Inner count: 10
# Outer count: 0  ‚Üê outer's count was NOT modified!

# With nonlocal ‚Äî modifies the enclosing variable
def outer():
    count = 0
    def inner():
        nonlocal count     # Tells Python: use the count from outer
        count = 10
        print(f"Inner count: {count}")
    inner()
    print(f"Outer count: {count}")

outer()
# Inner count: 10
# Outer count: 10  ‚Üê outer's count WAS modified!
```

### `nonlocal` vs `global`
| Keyword | Scope it accesses |
|---------|------------------|
| `global` | Module-level (top-level) variable |
| `nonlocal` | Enclosing function's variable (one level up) |

```python
x = "global"

def outer():
    x = "enclosing"
    
    def inner():
        nonlocal x        # Refers to outer's x ("enclosing")
        x = "modified by inner"
    
    inner()
    print(x)              # "modified by inner"

outer()
print(x)                  # "global"  ‚Äî global x was NOT touched
```

> üí° Use `nonlocal` sparingly. It's mainly needed in closures and decorators when you need to maintain state.

---

## 7. Decorators ‚Äî Creating and Using

A **decorator** is a function that **wraps** another function to add behavior, without modifying the original function.

```python
# A decorator is just a function that takes a function and returns a new function

def my_decorator(func):
    def wrapper():
        print("Before the function")
        func()                          # Call the original function
        print("After the function")
    return wrapper

# Using the decorator
@my_decorator
def say_hello():
    print("Hello!")

say_hello()
# Before the function
# Hello!
# After the function
```

### What `@decorator` Actually Does
```python
# This:
@my_decorator
def say_hello():
    print("Hello!")

# Is exactly the same as:
def say_hello():
    print("Hello!")
say_hello = my_decorator(say_hello)     # Replaces say_hello with wrapper
```

### Decorator with Arguments to the Wrapped Function
```python
def log_function_call(func):
    def wrapper(*args, **kwargs):         # Accept ANY arguments
        print(f"Calling {func.__name__} with args={args}, kwargs={kwargs}")
        result = func(*args, **kwargs)    # Pass them to the original function
        print(f"{func.__name__} returned {result}")
        return result                      # Don't forget to return!
    return wrapper

@log_function_call
def add(a, b):
    return a + b

@log_function_call
def greet(name, greeting="Hello"):
    return f"{greeting}, {name}!"

print(add(5, 3))
# Calling add with args=(5, 3), kwargs={}
# add returned 8
# 8

print(greet("Sid", greeting="Namaste"))
# Calling greet with args=('Sid',), kwargs={'greeting': 'Namaste'}
# greet returned Namaste, Sid!
# Namaste, Sid!
```

### Real-World Backend Decorators
```python
import time

# Timer decorator
def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.4f} seconds")
        return result
    return wrapper

@timer
def slow_function():
    time.sleep(1)
    return "Done!"

slow_function()    # slow_function took 1.0012 seconds

# Auth check decorator (common in Django/FastAPI)
def require_auth(func):
    def wrapper(request, *args, **kwargs):
        if not request.get("user"):
            return {"error": "Unauthorized", "status": 401}
        return func(request, *args, **kwargs)
    return wrapper

@require_auth
def get_profile(request):
    return {"user": request["user"], "status": 200}

print(get_profile({"user": "Sid"}))      # {'user': 'Sid', 'status': 200}
print(get_profile({}))                    # {'error': 'Unauthorized', 'status': 401}
```

---

## 8. Decorators with Arguments

To pass arguments to a decorator, you need **three levels of nesting**.

```python
# Decorator WITHOUT arguments: 2 levels (decorator ‚Üí wrapper)
# Decorator WITH arguments: 3 levels (decorator_factory ‚Üí decorator ‚Üí wrapper)

def repeat(times):                        # Decorator factory
    def decorator(func):                  # Actual decorator
        def wrapper(*args, **kwargs):     # Wrapper
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(times=3)
def say_hello(name):
    print(f"Hello, {name}!")

say_hello("Sid")
# Hello, Sid!
# Hello, Sid!
# Hello, Sid!
```

### Another Example ‚Äî Rate Limiting
```python
import time

def rate_limit(max_calls, period):
    """Allow max_calls within period seconds"""
    calls = []
    
    def decorator(func):
        def wrapper(*args, **kwargs):
            now = time.time()
            # Remove old calls outside the period
            while calls and calls[0] < now - period:
                calls.pop(0)
            
            if len(calls) >= max_calls:
                print(f"Rate limit exceeded! Try after {period} seconds.")
                return None
            
            calls.append(now)
            return func(*args, **kwargs)
        return wrapper
    return decorator

@rate_limit(max_calls=3, period=60)
def api_call(endpoint):
    print(f"Calling {endpoint}")
    return {"status": "success"}
```

---

## 9. Stacking Multiple Decorators

You can apply multiple decorators. They wrap from **bottom to top**.

```python
def bold(func):
    def wrapper(*args, **kwargs):
        return f"<b>{func(*args, **kwargs)}</b>"
    return wrapper

def italic(func):
    def wrapper(*args, **kwargs):
        return f"<i>{func(*args, **kwargs)}</i>"
    return wrapper

@bold        # Applied second (outermost)
@italic      # Applied first (innermost)
def greet(name):
    return f"Hello, {name}"

print(greet("Sid"))    # <b><i>Hello, Sid</i></b>

# Execution order:
# 1. italic wraps greet ‚Üí italic_wrapper
# 2. bold wraps italic_wrapper ‚Üí bold_wrapper
# Same as: greet = bold(italic(greet))
```

> üí° **Read decorators bottom-to-top** ‚Äî the one closest to `def` runs first.

---

## 10. `functools.wraps`

Without `@wraps`, the decorated function **loses its identity** (name, docstring).

```python
from functools import wraps

# ‚ùå Without @wraps
def my_decorator(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def add(a, b):
    """Add two numbers."""
    return a + b

print(add.__name__)    # 'wrapper'  üò± Not 'add'!
print(add.__doc__)     # None       üò± Lost the docstring!

# ‚úÖ With @wraps
def my_decorator(func):
    @wraps(func)                       # Preserves original function's metadata
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def add(a, b):
    """Add two numbers."""
    return a + b

print(add.__name__)    # 'add'             ‚úÖ
print(add.__doc__)     # 'Add two numbers.' ‚úÖ
```

> üö® **Always use `@wraps(func)`** in every decorator you write. It's a best practice.

---

## 11. `functools.lru_cache` (Memoization)

**Memoization** = caching the results of function calls to avoid recomputation.

```python
from functools import lru_cache

# Without cache ‚Äî SLOW (recalculates same values repeatedly)
def fib(n):
    if n <= 1:
        return n
    return fib(n - 1) + fib(n - 2)

# fib(35) takes several seconds!

# With lru_cache ‚Äî FAST (caches results)
@lru_cache(maxsize=128)     # Cache up to 128 unique calls
def fib(n):
    if n <= 1:
        return n
    return fib(n - 1) + fib(n - 2)

print(fib(100))    # Instant! 354224848179261915075

# Check cache stats
print(fib.cache_info())    # CacheInfo(hits=98, misses=101, maxsize=128, currsize=101)

# Clear cache
fib.cache_clear()
```

### `@cache` (Python 3.9+) ‚Äî Simpler, Unbounded
```python
from functools import cache

@cache    # Same as @lru_cache(maxsize=None)
def expensive_computation(x):
    print(f"Computing for {x}...")
    return x ** 2

print(expensive_computation(5))    # Computing for 5... ‚Üí 25
print(expensive_computation(5))    # 25 (no "Computing..." ‚Äî cached!)
```

> üí° **Backend use case**: Cache database queries, API responses, or expensive calculations. But be careful with memory usage ‚Äî use `maxsize` to limit cache.

---

## 12. `functools.partial`

`partial` creates a **new function** with some arguments pre-filled.

```python
from functools import partial

def power(base, exponent):
    return base ** exponent

# Create specialized versions
square = partial(power, exponent=2)
cube = partial(power, exponent=3)

print(square(5))    # 25
print(cube(5))      # 125

# Backend example ‚Äî pre-configured logger
import logging

def log_message(level, module, message):
    print(f"[{level}] [{module}] {message}")

# Create module-specific loggers
auth_logger = partial(log_message, module="auth")
db_logger = partial(log_message, module="database")

auth_logger("INFO", message="User logged in")      # [INFO] [auth] User logged in
db_logger("ERROR", message="Connection failed")     # [ERROR] [database] Connection failed
```

> üí° `partial` is great when you need a function with **fewer arguments** than the original ‚Äî e.g., passing to `map()`, `sorted()`, or callback handlers.

---

## 13. Recursion and Recursive Thinking

A function that **calls itself** to solve a smaller version of the same problem.

```python
# Factorial: n! = n √ó (n-1) √ó (n-2) √ó ... √ó 1
def factorial(n):
    # Base case ‚Äî stops recursion
    if n <= 1:
        return 1
    # Recursive case ‚Äî calls itself with a smaller problem
    return n * factorial(n - 1)

print(factorial(5))    # 120 (5 √ó 4 √ó 3 √ó 2 √ó 1)

# How it works:
# factorial(5) ‚Üí 5 * factorial(4)
#                    ‚Üí 4 * factorial(3)
#                         ‚Üí 3 * factorial(2)
#                              ‚Üí 2 * factorial(1)
#                                   ‚Üí 1  (base case!)
#                              ‚Üí 2 * 1 = 2
#                         ‚Üí 3 * 2 = 6
#                    ‚Üí 4 * 6 = 24
#                ‚Üí 5 * 24 = 120
```

### Key Parts of Recursion
1. **Base case** ‚Äî when to STOP (prevents infinite recursion)
2. **Recursive case** ‚Äî call yourself with a SMALLER problem
3. **Progress** ‚Äî each call must move closer to the base case

### More Examples
```python
# Sum of a list
def sum_list(lst):
    if not lst:              # Base case: empty list
        return 0
    return lst[0] + sum_list(lst[1:])    # First element + sum of rest

print(sum_list([1, 2, 3, 4, 5]))    # 15

# Flatten nested list
def flatten(lst):
    result = []
    for item in lst:
        if isinstance(item, list):
            result.extend(flatten(item))   # Recurse for nested lists
        else:
            result.append(item)
    return result

print(flatten([1, [2, [3, 4], 5], 6]))    # [1, 2, 3, 4, 5, 6]
```

### Python's Recursion Limit
```python
import sys
print(sys.getrecursionlimit())     # 1000 (default)
sys.setrecursionlimit(5000)        # Increase if needed (be careful!)

# Too deep recursion ‚Üí RecursionError
```

> üí° **In backend work**, recursion is used for tree traversals (nested comments, categories), parsing nested JSON, and graph algorithms. But for simple problems, **prefer loops** ‚Äî they're faster and don't hit the recursion limit.

---

## 14. Tail Recursion

**Tail recursion** = the recursive call is the **very last** operation. Some languages optimize this, but **Python does NOT**.

```python
# Not tail recursive ‚Äî has pending multiplication after recursive call
def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)    # After factorial returns, still need to multiply by n

# Tail recursive version ‚Äî result built up in accumulator
def factorial_tail(n, accumulator=1):
    if n <= 1:
        return accumulator
    return factorial_tail(n - 1, accumulator * n)    # Nothing to do after this call

print(factorial_tail(5))    # 120
```

### Why Python Doesn't Optimize Tail Recursion
- Guido van Rossum (Python creator) intentionally chose NOT to implement TCO
- Python values **readable tracebacks** over performance optimization
- Use **loops or `@lru_cache`** instead for large inputs

> üí° **Know the concept** for interviews, but in practice use iterative solutions or memoization in Python.

---

## 15. Generator Functions (`yield`)

A **generator** is a function that returns values **one at a time** using `yield`, instead of all at once with `return`. It's **lazy** ‚Äî computes values on demand.

```python
# Regular function ‚Äî stores ALL values in memory
def get_squares(n):
    result = []
    for i in range(n):
        result.append(i ** 2)
    return result                     # Returns entire list

# Generator function ‚Äî yields ONE value at a time
def get_squares_gen(n):
    for i in range(n):
        yield i ** 2                  # Pauses here, resumes on next call

# Usage
squares = get_squares_gen(5)
print(type(squares))    # <class 'generator'>

print(next(squares))    # 0
print(next(squares))    # 1
print(next(squares))    # 4
print(next(squares))    # 9
print(next(squares))    # 16
# print(next(squares))  # StopIteration error ‚Äî exhausted!

# Usually used in a for loop
for sq in get_squares_gen(5):
    print(sq, end=" ")    # 0 1 4 9 16
```

### Why Generators? ‚Äî Memory Efficiency!
```python
import sys

# List ‚Äî stores ALL 1 million numbers in memory
big_list = [i for i in range(1_000_000)]
print(sys.getsizeof(big_list))    # ~8,000,056 bytes (8MB!)

# Generator ‚Äî stores only the logic, not the data
big_gen = (i for i in range(1_000_000))
print(sys.getsizeof(big_gen))     # ~112 bytes (tiny!)
```

### Real-World Backend Use Cases
```python
# Reading large files line by line (don't load entire file into memory)
def read_large_file(filepath):
    with open(filepath, "r") as f:
        for line in f:
            yield line.strip()

# Processing large database results in chunks
def fetch_users_in_batches(batch_size=100):
    offset = 0
    while True:
        users = db.query(f"SELECT * FROM users LIMIT {batch_size} OFFSET {offset}")
        if not users:
            break
        yield users
        offset += batch_size

# Infinite sequence
def infinite_ids():
    id = 1
    while True:
        yield id
        id += 1

id_gen = infinite_ids()
print(next(id_gen))    # 1
print(next(id_gen))    # 2
# Never runs out!
```

> üí° **Generators are crucial for backend** ‚Äî reading large files, streaming data, processing database results without loading everything into memory.

---

## 16. Generator Expressions

Like list comprehensions, but with **parentheses** instead of brackets. Returns a generator (lazy).

```python
# List comprehension ‚Äî creates full list in memory
squares_list = [x ** 2 for x in range(10)]       # [0, 1, 4, 9, ...]

# Generator expression ‚Äî creates lazy generator
squares_gen = (x ** 2 for x in range(10))         # <generator object>

# Can be used directly in functions
total = sum(x ** 2 for x in range(10))            # No extra parentheses needed!
print(total)    # 285

# Check if any user is admin
users = [{"name": "Sid", "role": "user"}, {"name": "Admin", "role": "admin"}]
has_admin = any(u["role"] == "admin" for u in users)
print(has_admin)    # True
```

> üí° Use **generator expressions** when you only need to iterate once and don't need the full list stored in memory.

---

## 17. `yield from`

Delegates to another generator (simplifies nested generators).

```python
# Without yield from ‚Äî manual delegation
def gen1():
    for i in range(3):
        yield i

def gen2():
    for i in range(3, 6):
        yield i

def combined():
    for item in gen1():
        yield item
    for item in gen2():
        yield item

# With yield from ‚Äî cleaner!
def combined():
    yield from gen1()        # Delegates to gen1
    yield from gen2()        # Then delegates to gen2

print(list(combined()))    # [0, 1, 2, 3, 4, 5]

# Flatten nested iterables
def flatten(nested):
    for item in nested:
        if isinstance(item, (list, tuple)):
            yield from flatten(item)    # Recursively delegate
        else:
            yield item

print(list(flatten([1, [2, [3, 4]], 5])))    # [1, 2, 3, 4, 5]
```

> üí° `yield from` is cleaner than looping and yielding manually. It also properly handles the generator's `return` value and exceptions.

---

## 18. `itertools` Module

A standard library module with powerful **iterator building blocks**.

```python
import itertools

# --- Infinite Iterators ---

# count(start, step) ‚Äî infinite counter
for i in itertools.count(10, 2):    # 10, 12, 14, 16, ...
    if i > 20:
        break
    print(i, end=" ")    # 10 12 14 16 18 20

# cycle(iterable) ‚Äî infinite cycling
colors = itertools.cycle(["red", "green", "blue"])
for _ in range(7):
    print(next(colors), end=" ")    # red green blue red green blue red

# repeat(value, times) ‚Äî repeat a value
print(list(itertools.repeat("hello", 3)))    # ['hello', 'hello', 'hello']

# --- Combinatorics ---

# product ‚Äî cartesian product (nested loops)
print(list(itertools.product("AB", "12")))
# [('A', '1'), ('A', '2'), ('B', '1'), ('B', '2')]

# permutations ‚Äî all orderings
print(list(itertools.permutations("ABC", 2)))
# [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]

# combinations ‚Äî subsets (order doesn't matter)
print(list(itertools.combinations("ABCD", 2)))
# [('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'C'), ('B', 'D'), ('C', 'D')]

# combinations_with_replacement
print(list(itertools.combinations_with_replacement("AB", 2)))
# [('A', 'A'), ('A', 'B'), ('B', 'B')]

# --- Merging ---

# chain ‚Äî concatenate iterables
print(list(itertools.chain([1, 2], [3, 4], [5, 6])))    # [1, 2, 3, 4, 5, 6]

# chain.from_iterable ‚Äî flatten one level
nested = [[1, 2], [3, 4], [5, 6]]
print(list(itertools.chain.from_iterable(nested)))    # [1, 2, 3, 4, 5, 6]

# zip_longest ‚Äî zip with fill value for unequal lengths
a = [1, 2, 3]
b = ["a", "b"]
print(list(itertools.zip_longest(a, b, fillvalue="?")))
# [(1, 'a'), (2, 'b'), (3, '?')]

# --- Slicing & Filtering ---

# islice ‚Äî slice a generator (can't use [start:stop] on generators!)
gen = itertools.count(0)
print(list(itertools.islice(gen, 5, 10)))    # [5, 6, 7, 8, 9]

# starmap ‚Äî like map() but unpacks arguments
pairs = [(2, 3), (4, 5), (6, 7)]
print(list(itertools.starmap(lambda a, b: a * b, pairs)))    # [6, 20, 42]

# groupby ‚Äî group consecutive elements by key
data = [("fruit", "apple"), ("fruit", "banana"), ("veggie", "carrot"), ("veggie", "pea")]
for key, group in itertools.groupby(data, key=lambda x: x[0]):
    print(f"{key}: {[item[1] for item in group]}")
# fruit: ['apple', 'banana']
# veggie: ['carrot', 'pea']
```

### `itertools` Cheat Sheet
| Function | What it does | Example |
|----------|-------------|---------|
| `count(start, step)` | Infinite counter | `count(10, 2)` ‚Üí 10, 12, 14... |
| `cycle(iterable)` | Infinite cycling | `cycle("AB")` ‚Üí A, B, A, B... |
| `repeat(val, n)` | Repeat n times | `repeat("x", 3)` ‚Üí x, x, x |
| `chain(*iterables)` | Concatenate | `chain([1,2],[3,4])` ‚Üí 1,2,3,4 |
| `product(A, B)` | Cartesian product | All pairs |
| `permutations(A, r)` | r-length orderings | Order matters |
| `combinations(A, r)` | r-length subsets | Order doesn't matter |
| `groupby(data, key)` | Group by key | Consecutive groups |
| `islice(gen, start, stop)` | Slice a generator | Like `gen[5:10]` |
| `starmap(func, iterable)` | Map with unpacked args | `starmap(add, [(1,2),(3,4)])` |
| `zip_longest(*its)` | Zip with fill | Fills shorter with None |

> üí° `itertools` is heavily used in **DSA problems** and **data processing** in backend. Master `chain`, `groupby`, `product`, `combinations`, and `islice`.

---

## 19. Type Hints in Functions (PEP 484)

Type hints tell Python (and your IDE) **what types** a function expects and returns.

```python
# Without type hints ‚Äî unclear
def add(a, b):
    return a + b

# With type hints ‚Äî crystal clear
def add(a: int, b: int) -> int:
    return a + b

# Common type hints
def greet(name: str) -> str:
    return f"Hello, {name}!"

def process_items(items: list[str], limit: int = 10) -> dict[str, int]:
    return {"processed": min(len(items), limit)}

# Optional (can be None)
from typing import Optional

def find_user(user_id: int) -> Optional[dict]:   # Returns dict or None
    user = db.get(user_id)
    return user    # Could be None if not found

# Union ‚Äî multiple types (Python 3.10+: use |)
def process(value: int | str) -> str:    # Python 3.10+
    return str(value)

# For older Python
from typing import Union
def process(value: Union[int, str]) -> str:
    return str(value)
```

### Common Type Hints
```python
from typing import Optional, Union, Any

# Basic types
x: int = 5
y: float = 3.14
z: str = "hello"
flag: bool = True

# Collections (Python 3.9+)
names: list[str] = ["Sid", "Rahul"]
scores: dict[str, int] = {"math": 90}
unique: set[int] = {1, 2, 3}
pair: tuple[str, int] = ("Sid", 25)

# Function that takes and returns specific types
def create_user(
    name: str,
    age: int,
    email: Optional[str] = None,
    roles: list[str] | None = None
) -> dict[str, Any]:
    return {
        "name": name,
        "age": age,
        "email": email,
        "roles": roles or ["user"]
    }
```

### Type Hints Don't Enforce ‚Äî They're Just Hints!
```python
def add(a: int, b: int) -> int:
    return a + b

# Python WON'T stop you from doing this:
print(add("hello", " world"))    # "hello world"  ‚Äî works, no error!

# Use mypy for enforcement:
# $ pip install mypy
# $ mypy your_file.py
# error: Argument 1 to "add" has incompatible type "str"; expected "int"
```

### Why Type Hints Matter for Backend
1. **IDE support** ‚Äî autocompletion, error detection in VS Code/PyCharm
2. **Pydantic** ‚Äî FastAPI uses type hints for automatic request validation
3. **Documentation** ‚Äî anyone reading your code knows what types are expected
4. **`mypy`** ‚Äî catches type bugs before runtime
5. **Team collaboration** ‚Äî essential in professional codebases

```python
# FastAPI example ‚Äî type hints become API validation!
from fastapi import FastAPI
from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int
    email: str | None = None

app = FastAPI()

@app.post("/users/")
async def create_user(user: User) -> dict:    # Type hints = auto validation!
    return {"message": f"Created {user.name}"}
```

> üí° **Start using type hints NOW.** It's a habit that will make you a better backend developer. FastAPI is entirely built around type hints.

---

## üîó Quick Reference

```python
# Lambda
lambda x, y: x + y

# map, filter, reduce
list(map(func, iterable))
list(filter(func, iterable))
from functools import reduce
reduce(func, iterable)

# Closure
def outer(x):
    def inner(y):
        return x + y        # Remembers x
    return inner

# Decorator
from functools import wraps
def deco(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        # before
        result = func(*args, **kwargs)
        # after
        return result
    return wrapper

# Generator
def gen():
    yield value

# Memoization
from functools import lru_cache
@lru_cache(maxsize=128)
def expensive(n): ...

# Type hints
def func(a: int, b: str = "hi") -> dict[str, Any]: ...
```

---

> üìù **Next up**: Phase 4 ‚Äî Object-Oriented Programming (OOP)
