# 4.1 OOP Basics ‚Äî Notes

> **Status**: ‚úÖ Completed  
> **Date**: 28 February 2026

---

## 1. Classes and Objects

A **class** is a blueprint. An **object** is an instance of that blueprint.

```python
# ---- Defining a Class ----
class User:
    pass    # Empty class (placeholder)

# ---- Creating Objects (Instances) ----
user1 = User()
user2 = User()

print(type(user1))    # <class '__main__.User'>
print(user1)          # <__main__.User object at 0x...>

# Each object is unique
print(user1 is user2)    # False (different objects in memory)
print(id(user1))         # Some memory address
print(id(user2))         # Different memory address
```

### Class with Attributes
```python
class User:
    def __init__(self, name, age):
        self.name = name    # Instance attribute
        self.age = age      # Instance attribute

user1 = User("Sid", 25)
user2 = User("Rahul", 30)

print(user1.name)    # Sid
print(user2.age)     # 30
```

### Real-World Analogy
```
Class = Blueprint of a house
Object = Actual house built from the blueprint

Class "User" ‚Üí blueprint with name, email, age
Object user1 ‚Üí Sid, sid@mail.com, 25
Object user2 ‚Üí Rahul, rahul@mail.com, 30
```

> üí° **Backend context**: In Django/FastAPI, your Models are classes. Each database row becomes an object.

---

## 2. `__init__` Constructor

`__init__` is called **automatically** when you create an object. It **initializes** the object's attributes.

```python
class Product:
    def __init__(self, name, price, quantity=0):
        self.name = name
        self.price = price
        self.quantity = quantity
        print(f"Product '{name}' created!")    # Runs on creation

# Creating objects triggers __init__
p1 = Product("Laptop", 75000, 10)     # Product 'Laptop' created!
p2 = Product("Mouse", 500)            # Product 'Mouse' created! (quantity=0 default)

print(p1.name)        # Laptop
print(p2.quantity)    # 0
```

### Common Mistakes
```python
class Bad:
    # ‚ùå Forgetting self ‚Äî this is a local variable, NOT an attribute
    def __init__(self, name):
        name = name          # Does nothing! Lost after __init__

class Good:
    # ‚úÖ Use self.name to store as attribute
    def __init__(self, name):
        self.name = name     # Stored on the object

b = Bad("Sid")
# print(b.name)    # ‚ùå AttributeError: 'Bad' object has no attribute 'name'

g = Good("Sid")
print(g.name)      # ‚úÖ Sid
```

### Validation in `__init__`
```python
class User:
    def __init__(self, name, age, email):
        if not name:
            raise ValueError("Name cannot be empty")
        if age < 0 or age > 150:
            raise ValueError(f"Invalid age: {age}")
        if "@" not in email:
            raise ValueError(f"Invalid email: {email}")
        
        self.name = name
        self.age = age
        self.email = email

# ‚úÖ Valid
user = User("Sid", 25, "sid@mail.com")

# ‚ùå Raises ValueError
# user = User("", 25, "sid@mail.com")      # Name cannot be empty
# user = User("Sid", -5, "sid@mail.com")   # Invalid age: -5
# user = User("Sid", 25, "invalid")        # Invalid email: invalid
```

> üí° `__init__` is NOT the constructor ‚Äî `__new__` is. `__init__` is the **initializer**. But everyone calls it "constructor" ‚Äî that's fine for daily use.

---

## 3. `self` Keyword

`self` refers to the **current instance** of the class. It's how an object accesses its own attributes and methods.

```python
class User:
    def __init__(self, name, age):
        self.name = name    # self.name = attribute on THIS object
        self.age = age
    
    def greet(self):
        # self.name ‚Üí accesses THIS object's name
        return f"Hi, I'm {self.name} and I'm {self.age} years old"
    
    def have_birthday(self):
        self.age += 1       # Modify THIS object's age
        return f"Happy Birthday {self.name}! Now {self.age}"

user1 = User("Sid", 25)
user2 = User("Rahul", 30)

print(user1.greet())    # Hi, I'm Sid and I'm 25 years old
print(user2.greet())    # Hi, I'm Rahul and I'm 30 years old

# self ensures each object tracks its OWN data
print(user1.have_birthday())    # Happy Birthday Sid! Now 26
print(user1.age)                # 26
print(user2.age)                # 30 (unchanged!)
```

### How `self` Works Under the Hood
```python
class User:
    def greet(self):
        return f"Hi, I'm {self.name}"

user = User()
user.name = "Sid"

# These two are IDENTICAL:
print(user.greet())         # Hi, I'm Sid  (Python passes user as self)
print(User.greet(user))     # Hi, I'm Sid  (explicitly passing the object)
```

### `self` is Just a Convention
```python
# You CAN name it anything (but DON'T ‚Äî always use "self")
class Weird:
    def __init__(this, name):    # Works but NEVER do this
        this.name = name

w = Weird("test")
print(w.name)    # test
```

> üí° **Rule**: ALWAYS name it `self`. It's not enforced by Python, but it's universal convention. Breaking it confuses everyone.

---

## 4. Instance Variables vs Class Variables

```python
class User:
    # Class variable ‚Äî shared by ALL instances
    platform = "MyApp"
    user_count = 0
    
    def __init__(self, name, age):
        # Instance variables ‚Äî unique to EACH instance
        self.name = name
        self.age = age
        User.user_count += 1    # Modify class var through the class

user1 = User("Sid", 25)
user2 = User("Rahul", 30)

# Instance variables ‚Äî different per object
print(user1.name)    # Sid
print(user2.name)    # Rahul

# Class variable ‚Äî same for all
print(user1.platform)      # MyApp
print(user2.platform)      # MyApp
print(User.platform)       # MyApp

# user_count tracks all instances
print(User.user_count)     # 2
```

### The Shadowing Trap ‚ö†Ô∏è
```python
class Config:
    debug = False    # Class variable

c1 = Config()
c2 = Config()

print(c1.debug)    # False (reads from class)
print(c2.debug)    # False

# Modify through class ‚Üí affects ALL
Config.debug = True
print(c1.debug)    # True
print(c2.debug)    # True

# Modify through instance ‚Üí creates INSTANCE variable (shadows class var!)
c1.debug = False   # ‚ö†Ô∏è Creates c1's OWN debug attribute
print(c1.debug)    # False (instance variable)
print(c2.debug)    # True  (still reading class variable!)
print(Config.debug) # True  (class variable unchanged)
```

### Mutable Class Variable Trap ‚ö†Ô∏è‚ö†Ô∏è
```python
# ‚ùå DANGEROUS ‚Äî mutable class variable shared between ALL instances!
class BadUser:
    tags = []    # Shared list!
    
    def add_tag(self, tag):
        self.tags.append(tag)

u1 = BadUser()
u2 = BadUser()
u1.add_tag("admin")
print(u2.tags)    # ['admin'] ‚Üê ‚ö†Ô∏è u2 also got it! They share the SAME list!

# ‚úÖ CORRECT ‚Äî initialize mutable objects in __init__
class GoodUser:
    def __init__(self):
        self.tags = []    # Each instance gets its OWN list
    
    def add_tag(self, tag):
        self.tags.append(tag)

u1 = GoodUser()
u2 = GoodUser()
u1.add_tag("admin")
print(u1.tags)    # ['admin']
print(u2.tags)    # []  ‚úÖ Separate!
```

### Quick Rule
| Type | Where Defined | Shared? | Use For |
|------|--------------|---------|---------|
| Class variable | In class body | ‚úÖ All instances | Constants, counters, defaults |
| Instance variable | In `__init__` (via `self`) | ‚ùå Per instance | Object-specific data |

> üí° **Interview favorite**: "What happens if you have a mutable class variable?" Know the trap!

---

## 5. Instance Methods

Methods defined inside a class that take `self` as first parameter. They can access and modify instance data.

```python
class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self.balance = balance
        self.transactions = []
    
    # Instance methods
    def deposit(self, amount):
        if amount <= 0:
            raise ValueError("Deposit must be positive")
        self.balance += amount
        self.transactions.append(f"+‚Çπ{amount}")
        return self
    
    def withdraw(self, amount):
        if amount <= 0:
            raise ValueError("Withdrawal must be positive")
        if amount > self.balance:
            raise ValueError("Insufficient funds")
        self.balance -= amount
        self.transactions.append(f"-‚Çπ{amount}")
        return self
    
    def get_balance(self):
        return f"‚Çπ{self.balance}"
    
    def get_statement(self):
        print(f"\n--- Statement for {self.owner} ---")
        for t in self.transactions:
            print(f"  {t}")
        print(f"  Balance: ‚Çπ{self.balance}")
        print("---")

# Usage
acc = BankAccount("Sid", 1000)
acc.deposit(5000)
acc.withdraw(2000)
acc.deposit(500)
acc.get_statement()
# --- Statement for Sid ---
#   +‚Çπ5000
#   -‚Çπ2000
#   +‚Çπ500
#   Balance: ‚Çπ4500
# ---
```

### Method Chaining (return self)
```python
# When methods return self, you can chain them!
acc = BankAccount("Sid", 1000)
acc.deposit(5000).withdraw(2000).deposit(500)    # Chained!
print(acc.get_balance())    # ‚Çπ4500

# This works because deposit() and withdraw() return self
```

### Methods Calling Other Methods
```python
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email
        self.is_verified = False
    
    def verify_email(self):
        # Simulate verification
        self.is_verified = True
        self._send_welcome()    # Call another method via self
    
    def _send_welcome(self):    # "Private" helper method (convention)
        print(f"Welcome email sent to {self.email}")

user = User("Sid", "sid@mail.com")
user.verify_email()    # Welcome email sent to sid@mail.com
print(user.is_verified)  # True
```

---

## 6. `__str__` and `__repr__`

Two special methods to control how your object is displayed as a string.

```python
class User:
    def __init__(self, name, age, email):
        self.name = name
        self.age = age
        self.email = email

# Without __str__ or __repr__
user = User("Sid", 25, "sid@mail.com")
print(user)    # <__main__.User object at 0x...>  ‚Üê Useless!
```

### Adding `__str__` ‚Äî Human-Friendly
```python
class User:
    def __init__(self, name, age, email):
        self.name = name
        self.age = age
        self.email = email
    
    def __str__(self):
        return f"{self.name} ({self.email})"

user = User("Sid", 25, "sid@mail.com")
print(user)           # Sid (sid@mail.com)      ‚Üê Nice!
print(str(user))      # Sid (sid@mail.com)
print(f"User: {user}") # User: Sid (sid@mail.com)
```

### Adding `__repr__` ‚Äî Developer-Friendly (Recreatable)
```python
class User:
    def __init__(self, name, age, email):
        self.name = name
        self.age = age
        self.email = email
    
    def __str__(self):
        return f"{self.name} ({self.email})"
    
    def __repr__(self):
        return f"User(name='{self.name}', age={self.age}, email='{self.email}')"

user = User("Sid", 25, "sid@mail.com")

print(user)          # Sid (sid@mail.com)                          ‚Üê __str__
print(repr(user))    # User(name='Sid', age=25, email='sid@mail.com')  ‚Üê __repr__

# In the REPL / debugger:
# >>> user
# User(name='Sid', age=25, email='sid@mail.com')   ‚Üê __repr__ is used

# In a list:
users = [User("Sid", 25, "sid@mail.com"), User("Rahul", 30, "rahul@mail.com")]
print(users)    # [User(name='Sid', ...), User(name='Rahul', ...)]  ‚Üê __repr__ for each!
```

### Key Differences

| Feature | `__str__` | `__repr__` |
|---------|----------|-----------|
| Purpose | User-friendly display | Developer/debug display |
| Called by | `print()`, `str()`, f-strings | `repr()`, REPL, debugger, containers |
| Goal | Readable | Unambiguous, ideally recreatable |
| If missing | Falls back to `__repr__` | Shows `<ClassName object at 0x...>` |

### If You Only Define One ‚Äî Define `__repr__`
```python
class Product:
    def __init__(self, name, price):
        self.name = name
        self.price = price
    
    def __repr__(self):
        return f"Product('{self.name}', {self.price})"

p = Product("Laptop", 75000)
print(p)       # Product('Laptop', 75000)  ‚Üê __repr__ used as fallback for __str__
print(repr(p)) # Product('Laptop', 75000)
```

### Backend Example ‚Äî Django-Style Model
```python
class Order:
    """Mimics how you'd define __str__ in a Django model"""
    def __init__(self, order_id, user, total, status="pending"):
        self.order_id = order_id
        self.user = user
        self.total = total
        self.status = status
    
    def __str__(self):
        return f"Order #{self.order_id} - {self.user} (‚Çπ{self.total})"
    
    def __repr__(self):
        return (f"Order(order_id={self.order_id}, user='{self.user}', "
                f"total={self.total}, status='{self.status}')")

order = Order(1001, "Sid", 4500, "shipped")
print(order)         # Order #1001 - Sid (‚Çπ4500)
print(repr(order))   # Order(order_id=1001, user='Sid', total=4500, status='shipped')

# In Django Admin, __str__ is what shows in dropdown lists and admin pages!
```

> üí° **Django rule**: ALWAYS define `__str__` on your models ‚Äî it's what shows in Django Admin.

---

## üîó Quick Reference

```python
class MyClass:
    class_var = "shared"              # Class variable
    
    def __init__(self, val):          # Initializer (constructor)
        self.val = val                # Instance variable
    
    def method(self):                 # Instance method
        return self.val
    
    def __str__(self):                # print(), str(), f-string
        return f"MyClass: {self.val}"
    
    def __repr__(self):               # repr(), REPL, debugger
        return f"MyClass({self.val!r})"

obj = MyClass("hello")
print(obj)           # __str__
print(repr(obj))     # __repr__
print(obj.method())  # Instance method
print(obj.class_var) # Class variable
```

---

> üìù **Next up**: Section 4.2 ‚Äî OOP Core Concepts (Encapsulation, Inheritance, MRO, Polymorphism, Abstraction)
