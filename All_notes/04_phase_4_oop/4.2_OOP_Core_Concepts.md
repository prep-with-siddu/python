# 4.2 OOP Core Concepts ‚Äî Notes

> **Status**: ‚úÖ Completed  
> **Date**: 28 February 2026

---

## 1. Encapsulation (Private `_`, Name Mangling `__`)

Encapsulation = **bundling data + methods** together and **controlling access** to internal state.

### Public, Protected, Private Convention
```python
class User:
    def __init__(self, name, email, password):
        self.name = name           # Public ‚Äî anyone can access
        self._email = email        # Protected ‚Äî "please don't touch" (convention only)
        self.__password = password # Private ‚Äî name mangling (harder to access)

user = User("Sid", "sid@mail.com", "secret123")

# ‚úÖ Public ‚Äî direct access
print(user.name)          # Sid

# ‚ö†Ô∏è Protected ‚Äî works, but signals "internal use"
print(user._email)        # sid@mail.com  (Python doesn't enforce it)

# ‚ùå Private ‚Äî name mangled!
# print(user.__password)  # AttributeError: 'User' object has no attribute '__password'

# üîì But you CAN access it via name mangling (don't do this!)
print(user._User__password)    # secret123  (Python renames it to _ClassName__attr)
```

### Proper Encapsulation with Methods
```python
class BankAccount:
    def __init__(self, owner, balance):
        self._owner = owner
        self.__balance = balance    # Private ‚Äî protect from direct modification
    
    def get_balance(self):
        """Getter ‚Äî controlled read access"""
        return self.__balance
    
    def deposit(self, amount):
        """Controlled write access with validation"""
        if amount <= 0:
            raise ValueError("Amount must be positive")
        self.__balance += amount
    
    def withdraw(self, amount):
        if amount > self.__balance:
            raise ValueError("Insufficient funds")
        self.__balance -= amount

acc = BankAccount("Sid", 10000)

# ‚úÖ Access through methods (controlled)
print(acc.get_balance())    # 10000
acc.deposit(5000)
print(acc.get_balance())    # 15000

# ‚ùå Cannot directly set balance (no bypassing validation!)
# acc.__balance = 999999    # Creates a NEW attribute, doesn't modify the real one
# acc.withdraw(999999)      # ValueError: Insufficient funds (real balance unchanged)
```

### Quick Reference
| Prefix | Name | Access | Enforced? |
|--------|------|--------|-----------|
| `name` | Public | Anyone | ‚Äî |
| `_name` | Protected | Internal/subclass | ‚ùå Convention only |
| `__name` | Private | Name mangled | ‚ö†Ô∏è Partially (`_Class__name`) |
| `__name__` | Dunder/Magic | Python special methods | ‚Äî |

> üí° Python philosophy: **"We're all consenting adults here."** Single underscore `_` is the most common convention for "private".

---

## 2. Inheritance (Single, Multiple, Multilevel, Hierarchical)

Inheritance = a class **inherits** attributes and methods from another class.

### Single Inheritance
```python
class Animal:
    def __init__(self, name, sound):
        self.name = name
        self.sound = sound
    
    def speak(self):
        return f"{self.name} says {self.sound}!"
    
    def __repr__(self):
        return f"{self.__class__.__name__}('{self.name}')"

class Dog(Animal):    # Dog inherits from Animal
    def __init__(self, name, breed):
        super().__init__(name, "Woof")    # Call parent's __init__
        self.breed = breed
    
    def fetch(self):
        return f"{self.name} fetches the ball!"

class Cat(Animal):
    def __init__(self, name):
        super().__init__(name, "Meow")

dog = Dog("Bruno", "Labrador")
cat = Cat("Whiskers")

print(dog.speak())    # Bruno says Woof!        (inherited from Animal)
print(dog.fetch())    # Bruno fetches the ball!  (Dog's own method)
print(cat.speak())    # Whiskers says Meow!      (inherited from Animal)

# Check inheritance
print(isinstance(dog, Dog))       # True
print(isinstance(dog, Animal))    # True  (Dog IS an Animal)
print(issubclass(Dog, Animal))    # True
```

### Backend Example ‚Äî Base Model Pattern
```python
from datetime import datetime

class BaseModel:
    """Common fields for all models ‚Äî like Django's abstract model"""
    def __init__(self):
        self.id = None
        self.created_at = datetime.now()
        self.updated_at = datetime.now()
    
    def save(self):
        self.updated_at = datetime.now()
        print(f"Saved {self.__class__.__name__} (id={self.id})")

class User(BaseModel):
    def __init__(self, name, email):
        super().__init__()    # Get id, created_at, updated_at
        self.name = name
        self.email = email

class Product(BaseModel):
    def __init__(self, name, price):
        super().__init__()
        self.name = name
        self.price = price

user = User("Sid", "sid@mail.com")
user.id = 1
user.save()    # Saved User (id=1)
print(user.created_at)    # 2026-02-28 ...
```

### Multilevel Inheritance
```python
class Animal:
    def breathe(self):
        return "Breathing..."

class Mammal(Animal):    # Inherits from Animal
    def feed_young(self):
        return "Feeding milk..."

class Dog(Mammal):       # Inherits from Mammal (which inherits from Animal)
    def bark(self):
        return "Woof!"

dog = Dog()
print(dog.bark())         # Woof!         (own method)
print(dog.feed_young())   # Feeding milk... (from Mammal)
print(dog.breathe())      # Breathing...   (from Animal ‚Äî 2 levels up!)
```

### Hierarchical Inheritance
```python
class Shape:
    def __init__(self, color="black"):
        self.color = color

class Circle(Shape):
    def __init__(self, radius, color="black"):
        super().__init__(color)
        self.radius = radius
    
    def area(self):
        return 3.14159 * self.radius ** 2

class Rectangle(Shape):
    def __init__(self, width, height, color="black"):
        super().__init__(color)
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height

# Circle and Rectangle both inherit from Shape (hierarchical)
c = Circle(5, "red")
r = Rectangle(4, 6, "blue")
print(c.area())    # 78.53975
print(r.area())    # 24
print(c.color)     # red (inherited)
```

### Multiple Inheritance
```python
class Flyable:
    def fly(self):
        return f"{self.name} is flying!"

class Swimmable:
    def swim(self):
        return f"{self.name} is swimming!"

class Duck(Animal, Flyable, Swimmable):    # Inherits from THREE classes!
    def __init__(self, name):
        Animal.__init__(self, name, "Quack")    # Explicit parent call

duck = Duck("Donald")
print(duck.speak())    # Donald says Quack!   (from Animal)
print(duck.fly())      # Donald is flying!    (from Flyable)
print(duck.swim())     # Donald is swimming!  (from Swimmable)
```

> üí° Multiple inheritance is powerful but can get messy. Prefer **composition** or **mixins** for cleaner code.

---

## 3. Method Resolution Order (MRO) and `super()`

When a class has multiple parents, Python needs to know **which method to call first**. The MRO defines this order.

### The Diamond Problem
```python
class A:
    def greet(self):
        return "Hello from A"

class B(A):
    def greet(self):
        return "Hello from B"

class C(A):
    def greet(self):
        return "Hello from C"

class D(B, C):    # Diamond: D ‚Üí B ‚Üí C ‚Üí A
    pass

d = D()
print(d.greet())    # Hello from B  (B comes first in MRO)

# Check MRO
print(D.__mro__)
# (<class 'D'>, <class 'B'>, <class 'C'>, <class 'A'>, <class 'object'>)

# Or more readable:
print(D.mro())
# [<class 'D'>, <class 'B'>, <class 'C'>, <class 'A'>, <class 'object'>]
```

### MRO uses C3 Linearization
```
Rule: Go left-to-right in parent list, depth-first, but skip duplicates.

class D(B, C):
  MRO: D ‚Üí B ‚Üí C ‚Üí A ‚Üí object

Python checks in this ORDER for any method call on D.
```

### `super()` Follows the MRO
```python
class A:
    def __init__(self):
        print("A.__init__")

class B(A):
    def __init__(self):
        print("B.__init__")
        super().__init__()    # Calls NEXT in MRO, not always the direct parent!

class C(A):
    def __init__(self):
        print("C.__init__")
        super().__init__()

class D(B, C):
    def __init__(self):
        print("D.__init__")
        super().__init__()

d = D()
# D.__init__
# B.__init__
# C.__init__    ‚Üê super() in B calls C (not A!) because MRO is D‚ÜíB‚ÜíC‚ÜíA
# A.__init__
```

### Cooperative Multiple Inheritance with `super()`
```python
class Base:
    def __init__(self, **kwargs):
        print(f"Base.__init__")

class Logger:
    def __init__(self, **kwargs):
        print(f"Logger.__init__")
        super().__init__(**kwargs)

class Serializable:
    def __init__(self, **kwargs):
        print(f"Serializable.__init__")
        super().__init__(**kwargs)

class User(Logger, Serializable, Base):
    def __init__(self, name, **kwargs):
        self.name = name
        print(f"User.__init__")
        super().__init__(**kwargs)

user = User("Sid")
# User.__init__
# Logger.__init__
# Serializable.__init__
# Base.__init__

print(User.mro())
# [User, Logger, Serializable, Base, object]
```

> üí° **Interview tip**: Always know MRO. It's the #1 multiple inheritance question. Use `ClassName.mro()` or `ClassName.__mro__` to check.

---

## 4. Polymorphism (Method Overriding, Duck Typing)

Polymorphism = **same interface, different behavior** depending on the object.

### Method Overriding
```python
class Shape:
    def area(self):
        raise NotImplementedError("Subclass must implement area()")
    
    def describe(self):
        return f"{self.__class__.__name__} with area = {self.area():.2f}"

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):    # Override parent's area()
        return 3.14159 * self.radius ** 2

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):    # Override parent's area()
        return self.width * self.height

class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height
    
    def area(self):    # Override parent's area()
        return 0.5 * self.base * self.height

# Polymorphism in action ‚Äî same method name, different behavior!
shapes = [Circle(5), Rectangle(4, 6), Triangle(3, 8)]

for shape in shapes:
    print(shape.describe())
# Circle with area = 78.54
# Rectangle with area = 24.00
# Triangle with area = 12.00
```

### Duck Typing ("If it quacks like a duck...")
Python doesn't care about the **type** ‚Äî it cares about the **behavior** (methods/attributes).

```python
class Dog:
    def speak(self):
        return "Woof!"

class Cat:
    def speak(self):
        return "Meow!"

class Robot:
    def speak(self):
        return "Beep boop!"

# No common parent class needed! Duck typing doesn't care about inheritance.
def make_it_speak(thing):
    print(thing.speak())    # Just needs a .speak() method

make_it_speak(Dog())      # Woof!
make_it_speak(Cat())      # Meow!
make_it_speak(Robot())    # Beep boop!

# Works with ANYTHING that has .speak() ‚Äî no inheritance required!
```

### Duck Typing ‚Äî Real-World Example
```python
class FileLogger:
    def write(self, message):
        with open("app.log", "a") as f:
            f.write(message + "\n")

class ConsoleLogger:
    def write(self, message):
        print(f"[LOG] {message}")

class DatabaseLogger:
    def write(self, message):
        print(f"[DB] Saved: {message}")    # Simulate DB write

# Function doesn't care WHAT the logger is ‚Äî just that it has .write()
def process_order(order_id, logger):
    logger.write(f"Processing order {order_id}")
    # ... process ...
    logger.write(f"Order {order_id} completed")

# All work ‚Äî duck typing!
process_order(101, ConsoleLogger())
process_order(102, FileLogger())
process_order(103, DatabaseLogger())
```

### Polymorphism with Built-in Functions
```python
# len() works on any object with __len__ ‚Äî polymorphism!
print(len("hello"))       # 5  (str)
print(len([1, 2, 3]))     # 3  (list)
print(len({"a": 1}))      # 1  (dict)

# + operator works differently for different types ‚Äî polymorphism!
print(1 + 2)              # 3        (int addition)
print("a" + "b")          # ab       (string concatenation)
print([1] + [2])          # [1, 2]   (list concatenation)

# for loop works on any iterable ‚Äî duck typing!
for x in [1, 2, 3]: pass     # list
for x in (1, 2, 3): pass     # tuple
for x in "abc": pass          # string
for x in {1, 2, 3}: pass     # set
```

> üí° **Python motto**: "It's easier to ask forgiveness than permission" (EAFP). Try calling the method, catch the exception if it fails.

---

## 5. Abstraction (`abc` Module, `ABC`, `abstractmethod`)

Abstraction = **hide complex details**, show only what's necessary. Abstract classes **define the contract** ‚Äî subclasses **must implement** the abstract methods.

```python
from abc import ABC, abstractmethod

class PaymentProcessor(ABC):    # Abstract Base Class ‚Äî CANNOT be instantiated
    
    @abstractmethod
    def process_payment(self, amount):
        """Every subclass MUST implement this"""
        pass
    
    @abstractmethod
    def refund(self, transaction_id):
        """Every subclass MUST implement this"""
        pass
    
    def validate_amount(self, amount):
        """Concrete method ‚Äî shared by all subclasses"""
        if amount <= 0:
            raise ValueError("Amount must be positive")
        return True

# ‚ùå Cannot instantiate abstract class
# processor = PaymentProcessor()    # TypeError: Can't instantiate abstract class

# ‚úÖ Must implement ALL abstract methods
class RazorpayProcessor(PaymentProcessor):
    def process_payment(self, amount):
        self.validate_amount(amount)
        print(f"Razorpay: Processing ‚Çπ{amount}")
        return {"status": "success", "gateway": "razorpay"}
    
    def refund(self, transaction_id):
        print(f"Razorpay: Refunding {transaction_id}")
        return {"status": "refunded"}

class StripeProcessor(PaymentProcessor):
    def process_payment(self, amount):
        self.validate_amount(amount)
        print(f"Stripe: Processing ‚Çπ{amount}")
        return {"status": "success", "gateway": "stripe"}
    
    def refund(self, transaction_id):
        print(f"Stripe: Refunding {transaction_id}")
        return {"status": "refunded"}

# ‚ùå Missing refund() ‚Äî will raise TypeError
# class IncompleteProcessor(PaymentProcessor):
#     def process_payment(self, amount):
#         pass
# p = IncompleteProcessor()    # TypeError: Can't instantiate abstract class
```

### Using Abstraction in Your Code
```python
# Function accepts ANY PaymentProcessor ‚Äî doesn't care which gateway
def checkout(processor: PaymentProcessor, amount: float):
    result = processor.process_payment(amount)
    print(f"Result: {result}")

# Works with any implementation!
checkout(RazorpayProcessor(), 999)    # Razorpay: Processing ‚Çπ999
checkout(StripeProcessor(), 999)      # Stripe: Processing ‚Çπ999
```

### Abstract Properties
```python
from abc import ABC, abstractmethod

class Vehicle(ABC):
    @property
    @abstractmethod
    def fuel_type(self):
        pass
    
    @abstractmethod
    def start(self):
        pass

class ElectricCar(Vehicle):
    @property
    def fuel_type(self):
        return "Electric"
    
    def start(self):
        return "Silent start..."

class PetrolCar(Vehicle):
    @property
    def fuel_type(self):
        return "Petrol"
    
    def start(self):
        return "Vroom!"

ev = ElectricCar()
print(ev.fuel_type)    # Electric
print(ev.start())      # Silent start...
```

### When to Use Abstract Classes
| Scenario | Use |
|----------|-----|
| Define a contract/interface | ‚úÖ ABC |
| Share common code + enforce methods | ‚úÖ ABC |
| Just need shared behavior (no enforcement) | Regular inheritance |
| Multiple unrelated behaviors | Duck typing / Protocol |

> üí° **Backend pattern**: Abstract base classes are perfect for defining **interfaces** ‚Äî PaymentProcessor, NotificationSender, StorageBackend, etc. Swap implementations without changing the calling code.

---

## üîó Quick Reference

```python
from abc import ABC, abstractmethod

# ---- Encapsulation ----
class MyClass:
    public = "anyone"       # Public
    _protected = "internal" # Protected (convention)
    __private = "mangled"   # Private (name mangling ‚Üí _MyClass__private)

# ---- Inheritance ----
class Parent:
    pass
class Child(Parent):        # Single
    pass
class Child2(A, B, C):      # Multiple
    pass

# ---- MRO ----
Child2.mro()                # See resolution order
super().__init__()          # Call next in MRO

# ---- Polymorphism ----
# Method overriding: redefine parent method in child
# Duck typing: no class check, just call the method

# ---- Abstraction ----
class Interface(ABC):
    @abstractmethod
    def must_implement(self):
        pass
```

---

> üìù **Next up**: Section 4.3 ‚Äî OOP Advanced (classmethod, staticmethod, properties, dunder methods, dataclasses, SOLID)
