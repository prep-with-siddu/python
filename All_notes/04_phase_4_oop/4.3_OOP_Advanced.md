# 4.3 OOP Advanced ‚Äî Notes

> **Status**: ‚úÖ Completed  
> **Date**: 28 February 2026

---

## 1. `@classmethod` and `@staticmethod`

### `@classmethod` ‚Äî Receives the **class** (`cls`) Instead of Instance
```python
class User:
    user_count = 0
    
    def __init__(self, name, email):
        self.name = name
        self.email = email
        User.user_count += 1
    
    # Instance method ‚Äî gets self (the object)
    def greet(self):
        return f"Hi, I'm {self.name}"
    
    # Class method ‚Äî gets cls (the class itself)
    @classmethod
    def get_user_count(cls):
        return f"Total users: {cls.user_count}"
    
    # Class method as alternative constructor (factory method)
    @classmethod
    def from_string(cls, user_string):
        """Create User from 'name|email' format"""
        name, email = user_string.split("|")
        return cls(name, email)    # cls() = User() ‚Äî works with subclasses too!
    
    @classmethod
    def from_dict(cls, data):
        """Create User from dictionary"""
        return cls(data["name"], data["email"])

# Usage
user1 = User("Sid", "sid@mail.com")
user2 = User.from_string("Rahul|rahul@mail.com")    # Alternative constructor!
user3 = User.from_dict({"name": "Priya", "email": "priya@mail.com"})

print(user2.name)               # Rahul
print(User.get_user_count())    # Total users: 3
```

### Why `cls` Instead of `User`? ‚Äî Inheritance-Safe
```python
class User:
    @classmethod
    def create(cls, name):
        return cls(name)    # cls = whatever class calls it!

class AdminUser(User):
    def __init__(self, name):
        self.name = name
        self.role = "admin"

# cls = AdminUser here (not User!) ‚Äî returns AdminUser instance
admin = AdminUser.create("Sid")
print(type(admin))    # <class 'AdminUser'>  ‚úÖ
print(admin.role)     # admin
```

### `@staticmethod` ‚Äî No `self` or `cls`, Just a Regular Function Inside a Class
```python
class MathUtils:
    @staticmethod
    def add(a, b):
        return a + b
    
    @staticmethod
    def is_even(n):
        return n % 2 == 0
    
    @staticmethod
    def celsius_to_fahrenheit(c):
        return (c * 9/5) + 32

# Call on class (no instance needed)
print(MathUtils.add(3, 5))                # 8
print(MathUtils.is_even(4))               # True
print(MathUtils.celsius_to_fahrenheit(37)) # 98.6

# Can also call on instance (but no point)
m = MathUtils()
print(m.add(3, 5))    # 8
```

### Comparison Table
| Feature | Instance Method | `@classmethod` | `@staticmethod` |
|---------|----------------|----------------|-----------------|
| First arg | `self` (instance) | `cls` (class) | Nothing |
| Access instance? | ‚úÖ Yes | ‚ùå No | ‚ùå No |
| Access class? | ‚úÖ Via `self.__class__` | ‚úÖ Via `cls` | ‚ùå No |
| Use case | Object behavior | Factory methods, class-level ops | Utility/helper functions |

> üí° **Rule of thumb**: If the method doesn't use `self` ‚Üí make it `@staticmethod`. If it needs the class but not the instance ‚Üí `@classmethod`.

---

## 2. Properties (`@property`, `@setter`, `@deleter`)

Properties let you **use methods like attributes** ‚Äî add validation/logic without changing the API.

```python
class User:
    def __init__(self, name, age):
        self._name = name
        self._age = age    # Underscore = "don't access directly"
    
    @property
    def age(self):
        """Getter ‚Äî called when you READ user.age"""
        return self._age
    
    @age.setter
    def age(self, value):
        """Setter ‚Äî called when you WRITE user.age = x"""
        if not isinstance(value, int):
            raise TypeError("Age must be an integer")
        if value < 0 or value > 150:
            raise ValueError("Age must be between 0 and 150")
        self._age = value
    
    @age.deleter
    def age(self):
        """Deleter ‚Äî called when you do del user.age"""
        print("Deleting age...")
        self._age = None
    
    @property
    def name(self):
        return self._name
    
    @name.setter
    def name(self, value):
        if not value or not value.strip():
            raise ValueError("Name cannot be empty")
        self._name = value.strip().title()

# Usage ‚Äî looks like regular attribute access!
user = User("sid", 25)

print(user.age)     # 25    (calls @property getter)
user.age = 26       # OK    (calls @age.setter)
print(user.age)     # 26

# Validation kicks in
# user.age = -5     # ValueError: Age must be between 0 and 150
# user.age = "old"  # TypeError: Age must be an integer

print(user.name)    # Sid   (auto-title-cased!)
user.name = "rahul kumar"
print(user.name)    # Rahul Kumar

del user.age        # Deleting age...
print(user.age)     # None
```

### Computed/Read-Only Properties
```python
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height
    
    @property
    def width(self):
        return self._width
    
    @width.setter
    def width(self, value):
        if value <= 0:
            raise ValueError("Width must be positive")
        self._width = value
    
    @property
    def height(self):
        return self._height
    
    @height.setter
    def height(self, value):
        if value <= 0:
            raise ValueError("Height must be positive")
        self._height = value
    
    @property
    def area(self):
        """Read-only computed property ‚Äî no setter!"""
        return self._width * self._height
    
    @property
    def perimeter(self):
        return 2 * (self._width + self._height)

r = Rectangle(5, 3)
print(r.area)        # 15  (computed, not stored!)
print(r.perimeter)   # 16

r.width = 10
print(r.area)        # 30  (auto-recalculated!)

# r.area = 50        # ‚ùå AttributeError: can't set attribute (read-only!)
```

> üí° **Backend tip**: Properties are used everywhere in Django models and Pydantic models. They let you add logic without breaking existing code.

---

## 3. Dunder/Magic Methods

"Dunder" = **D**ouble **UNDER**score. These methods let your objects work with Python's built-in syntax.

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    # ---- String representation ----
    def __str__(self):
        return f"Vector({self.x}, {self.y})"
    
    def __repr__(self):
        return f"Vector({self.x}, {self.y})"
    
    # ---- Arithmetic ----
    def __add__(self, other):            # v1 + v2
        return Vector(self.x + other.x, self.y + other.y)
    
    def __sub__(self, other):            # v1 - v2
        return Vector(self.x - other.x, self.y - other.y)
    
    def __mul__(self, scalar):           # v * 3
        return Vector(self.x * scalar, self.y * scalar)
    
    # ---- Comparison ----
    def __eq__(self, other):             # v1 == v2
        return self.x == other.x and self.y == other.y
    
    def __lt__(self, other):             # v1 < v2 (by magnitude)
        return (self.x**2 + self.y**2) < (other.x**2 + other.y**2)
    
    def __hash__(self):                  # hash(v) ‚Äî needed for sets/dict keys
        return hash((self.x, self.y))
    
    # ---- Length ----
    def __len__(self):                   # len(v)
        return 2    # 2D vector
    
    def __abs__(self):                   # abs(v) ‚Äî magnitude
        return (self.x**2 + self.y**2) ** 0.5
    
    # ---- Container behavior ----
    def __getitem__(self, index):        # v[0], v[1]
        if index == 0: return self.x
        if index == 1: return self.y
        raise IndexError("Vector index out of range")
    
    def __setitem__(self, index, value): # v[0] = 5
        if index == 0: self.x = value
        elif index == 1: self.y = value
        else: raise IndexError("Vector index out of range")
    
    def __contains__(self, value):       # 3 in v
        return value == self.x or value == self.y
    
    # ---- Callable ----
    def __call__(self):                  # v() ‚Äî treat object like a function
        return (self.x, self.y)
    
    # ---- Iteration ----
    def __iter__(self):                  # for i in v
        yield self.x
        yield self.y
    
    def __next__(self):
        pass    # Usually paired with __iter__ on custom iterators
    
    # ---- Boolean ----
    def __bool__(self):                  # bool(v), if v:
        return self.x != 0 or self.y != 0

# ---- Usage ----
v1 = Vector(3, 4)
v2 = Vector(1, 2)

print(v1 + v2)         # Vector(4, 6)       __add__
print(v1 - v2)         # Vector(2, 2)       __sub__
print(v1 * 3)          # Vector(9, 12)      __mul__
print(v1 == v2)        # False              __eq__
print(v1 < v2)         # False              __lt__
print(len(v1))         # 2                  __len__
print(abs(v1))         # 5.0                __abs__
print(v1[0])           # 3                  __getitem__
print(3 in v1)         # True               __contains__
print(v1())            # (3, 4)             __call__
print(list(v1))        # [3, 4]             __iter__
print(bool(v1))        # True               __bool__
print(bool(Vector(0,0))) # False
```

### Context Manager Dunder Methods (`__enter__`, `__exit__`)
```python
class DatabaseConnection:
    def __init__(self, db_url):
        self.db_url = db_url
        self.connected = False
    
    def __enter__(self):
        print(f"Connecting to {self.db_url}...")
        self.connected = True
        return self    # This is what `as` binds to
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Closing connection...")
        self.connected = False
        return False    # Don't suppress exceptions

# Usage with `with` statement
with DatabaseConnection("postgres://localhost/mydb") as db:
    print(f"Connected: {db.connected}")    # Connected: True
    # Do database stuff...
# Connecting to postgres://localhost/mydb...
# Connected: True
# Closing connection...

print(db.connected)    # False (auto-cleaned up!)
```

### Complete Dunder Methods Cheat Sheet
| Method | Triggered By | Example |
|--------|-------------|---------|
| `__init__` | Object creation | `obj = MyClass()` |
| `__str__` | `str()`, `print()`, f-string | `print(obj)` |
| `__repr__` | `repr()`, REPL, containers | `repr(obj)` |
| `__len__` | `len()` | `len(obj)` |
| `__getitem__` | `obj[key]` | `obj[0]` |
| `__setitem__` | `obj[key] = val` | `obj[0] = 5` |
| `__delitem__` | `del obj[key]` | `del obj[0]` |
| `__iter__` | `for x in obj` | `for x in obj:` |
| `__next__` | `next()` | `next(obj)` |
| `__contains__` | `in` | `5 in obj` |
| `__call__` | `obj()` | `obj(args)` |
| `__add__` | `+` | `obj + other` |
| `__sub__` | `-` | `obj - other` |
| `__mul__` | `*` | `obj * 3` |
| `__eq__` | `==` | `obj == other` |
| `__lt__` | `<` | `obj < other` |
| `__le__` | `<=` | `obj <= other` |
| `__gt__` | `>` | `obj > other` |
| `__hash__` | `hash()` | `hash(obj)` |
| `__bool__` | `bool()`, `if` | `if obj:` |
| `__enter__` | `with` (enter) | `with obj as x:` |
| `__exit__` | `with` (exit) | End of `with` block |

---

## 4. Operator Overloading

Making operators (`+`, `-`, `*`, `==`, `<`, etc.) work with your objects.

```python
class Money:
    def __init__(self, amount, currency="INR"):
        self.amount = amount
        self.currency = currency
    
    def __add__(self, other):
        if self.currency != other.currency:
            raise ValueError(f"Cannot add {self.currency} and {other.currency}")
        return Money(self.amount + other.amount, self.currency)
    
    def __sub__(self, other):
        if self.currency != other.currency:
            raise ValueError(f"Cannot subtract different currencies")
        return Money(self.amount - other.amount, self.currency)
    
    def __mul__(self, factor):
        return Money(self.amount * factor, self.currency)
    
    def __rmul__(self, factor):    # Handles: 3 * money (reversed)
        return self.__mul__(factor)
    
    def __eq__(self, other):
        return self.amount == other.amount and self.currency == other.currency
    
    def __lt__(self, other):
        if self.currency != other.currency:
            raise ValueError("Cannot compare different currencies")
        return self.amount < other.amount
    
    def __le__(self, other):
        return self == other or self < other
    
    def __repr__(self):
        return f"‚Çπ{self.amount}" if self.currency == "INR" else f"{self.currency} {self.amount}"

# Usage
price = Money(500)
tax = Money(90)
total = price + tax
print(total)           # ‚Çπ590

discount = Money(50)
final = total - discount
print(final)           # ‚Çπ540

doubled = price * 2
print(doubled)         # ‚Çπ1000

tripled = 3 * price    # Uses __rmul__
print(tripled)         # ‚Çπ1500

print(price < total)   # True
print(price == Money(500))  # True
```

---

## 5. Descriptors (`__get__`, `__set__`, `__delete__`)

Descriptors let you **customize attribute access** at the class level. They power `@property`, `@classmethod`, and `@staticmethod` internally.

```python
class Validator:
    """Reusable descriptor for validated attributes"""
    def __init__(self, min_value=None, max_value=None):
        self.min_value = min_value
        self.max_value = max_value
    
    def __set_name__(self, owner, name):
        self.name = name    # Auto-set by Python (the attribute name)
    
    def __get__(self, obj, objtype=None):
        if obj is None:
            return self
        return obj.__dict__.get(self.name)
    
    def __set__(self, obj, value):
        if self.min_value is not None and value < self.min_value:
            raise ValueError(f"{self.name} must be >= {self.min_value}, got {value}")
        if self.max_value is not None and value > self.max_value:
            raise ValueError(f"{self.name} must be <= {self.max_value}, got {value}")
        obj.__dict__[self.name] = value
    
    def __delete__(self, obj):
        del obj.__dict__[self.name]

class Product:
    # Descriptors ‚Äî reusable validation!
    price = Validator(min_value=0)
    quantity = Validator(min_value=0, max_value=10000)
    rating = Validator(min_value=0, max_value=5)

p = Product()
p.price = 499         # ‚úÖ
p.quantity = 50        # ‚úÖ
p.rating = 4.5         # ‚úÖ

# p.price = -10        # ‚ùå ValueError: price must be >= 0
# p.rating = 6         # ‚ùå ValueError: rating must be <= 5
```

> üí° Descriptors are the mechanism behind `@property`. You rarely write them directly, but understanding them helps you understand Python's internals.

---

## 6. Metaclasses (`type`, `__new__`)

A metaclass is the **class of a class**. Just as objects are instances of classes, classes are instances of metaclasses.

```python
# Every class is an instance of `type`
class User:
    pass

print(type(User))        # <class 'type'>
print(type(42))          # <class 'int'>
print(type(int))         # <class 'type'>

# Creating a class dynamically with type()
# type(name, bases, dict)
Animal = type("Animal", (), {"sound": "generic", "speak": lambda self: self.sound})
a = Animal()
print(a.speak())    # generic
```

### `__new__` vs `__init__`
```python
class Singleton:
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        """__new__ creates the instance (before __init__)"""
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self, name="default"):
        self.name = name

# Only ONE instance ever created
s1 = Singleton("first")
s2 = Singleton("second")
print(s1 is s2)        # True  (same object!)
print(s1.name)         # second (re-initialized)
print(id(s1) == id(s2))  # True
```

### Custom Metaclass (Advanced)
```python
class AutoRepr(type):
    """Metaclass that auto-adds __repr__ to classes"""
    def __new__(mcs, name, bases, namespace):
        cls = super().__new__(mcs, name, bases, namespace)
        
        def auto_repr(self):
            attrs = ", ".join(f"{k}={v!r}" for k, v in self.__dict__.items())
            return f"{self.__class__.__name__}({attrs})"
        
        cls.__repr__ = auto_repr
        return cls

class User(metaclass=AutoRepr):
    def __init__(self, name, age):
        self.name = name
        self.age = age

user = User("Sid", 25)
print(user)    # User(name='Sid', age=25)  ‚Üê auto-generated!
```

> üí° **Practical rule**: You'll rarely write metaclasses. But know they exist ‚Äî Django ORM, SQLAlchemy, and Pydantic all use them internally.

---

## 7. `__slots__` for Memory Optimization

By default, Python stores instance attributes in a `__dict__` (a dict per object). `__slots__` replaces it with a fixed structure ‚Äî saves memory.

```python
class UserWithDict:
    def __init__(self, name, age):
        self.name = name
        self.age = age

class UserWithSlots:
    __slots__ = ("name", "age")    # Only these attributes allowed!
    
    def __init__(self, name, age):
        self.name = name
        self.age = age

# ---- Memory comparison ----
import sys

u1 = UserWithDict("Sid", 25)
u2 = UserWithSlots("Sid", 25)

print(sys.getsizeof(u1.__dict__))    # ~104 bytes (dict overhead)
# u2 has no __dict__!
# print(u2.__dict__)                 # ‚ùå AttributeError

# ---- Slots prevent dynamic attributes ----
u1.email = "sid@mail.com"    # ‚úÖ Works (dict-based)
# u2.email = "sid@mail.com"  # ‚ùå AttributeError: 'UserWithSlots' has no attribute 'email'

# ---- When it matters ----
# Creating 1,000,000 objects ‚Üí __slots__ can save ~40-50% memory
```

### When to Use `__slots__`
| Use `__slots__` | Don't Use `__slots__` |
|-----------------|----------------------|
| Millions of instances | Few instances |
| Memory-critical code | Need dynamic attributes |
| Fixed set of attributes | Using `__dict__` features |

---

## 8. Dataclasses (`@dataclass` Decorator)

Dataclasses auto-generate `__init__`, `__repr__`, `__eq__`, and more ‚Äî less boilerplate!

```python
from dataclasses import dataclass, field, asdict, astuple
from typing import List, Optional

@dataclass
class User:
    name: str
    age: int
    email: str
    active: bool = True    # Default value

# ‚úÖ Auto-generated __init__, __repr__, __eq__
user = User("Sid", 25, "sid@mail.com")
print(user)              # User(name='Sid', age=25, email='sid@mail.com', active=True)
print(user == User("Sid", 25, "sid@mail.com"))  # True (auto __eq__)
```

### Advanced Dataclass Features
```python
from dataclasses import dataclass, field
from typing import List
from datetime import datetime

@dataclass
class Product:
    name: str
    price: float
    tags: List[str] = field(default_factory=list)    # Mutable default ‚Üí use field()
    created_at: datetime = field(default_factory=datetime.now)
    _internal: str = field(default="", repr=False)    # Hidden from repr
    
    def __post_init__(self):
        """Runs after __init__ ‚Äî good for validation"""
        if self.price < 0:
            raise ValueError("Price cannot be negative")
        self.name = self.name.strip().title()

p = Product("  laptop  ", 75000, ["electronics", "sale"])
print(p)    # Product(name='Laptop', price=75000, tags=['electronics', 'sale'], created_at=...)
```

### Frozen (Immutable) Dataclass
```python
@dataclass(frozen=True)
class Point:
    x: float
    y: float

p = Point(3.0, 4.0)
# p.x = 5.0    # ‚ùå FrozenInstanceError: cannot assign to field 'x'
print(hash(p))  # ‚úÖ Can be used as dict key / set element
```

### Ordering
```python
@dataclass(order=True)
class Student:
    gpa: float
    name: str = field(compare=False)    # Don't use name for comparisons

students = [
    Student(3.5, "Sid"),
    Student(3.9, "Rahul"),
    Student(3.2, "Priya"),
]
print(sorted(students))
# [Student(gpa=3.2, name='Priya'), Student(gpa=3.5, name='Sid'), Student(gpa=3.9, name='Rahul')]
```

### Converting Dataclass to Dict/Tuple
```python
from dataclasses import asdict, astuple

@dataclass
class User:
    name: str
    age: int

user = User("Sid", 25)
print(asdict(user))     # {'name': 'Sid', 'age': 25}
print(astuple(user))    # ('Sid', 25)
```

> üí° **Backend essential**: Dataclasses are used in FastAPI request/response models, configuration objects, DTOs (Data Transfer Objects).

---

## 9. `attrs` Library (Alternative to Dataclasses)

`attrs` is a third-party library (older than dataclasses) with more features.

```python
# pip install attrs
import attr

@attr.s(auto_attribs=True)
class User:
    name: str
    age: int = attr.ib(validator=attr.validators.instance_of(int))
    email: str = ""
    
    @age.validator
    def check_age(self, attribute, value):
        if value < 0 or value > 150:
            raise ValueError(f"Invalid age: {value}")

user = User("Sid", 25, "sid@mail.com")
print(user)    # User(name='Sid', age=25, email='sid@mail.com')

# user = User("Sid", -5)    # ValueError: Invalid age: -5
```

### Dataclass vs attrs
| Feature | `dataclass` | `attrs` |
|---------|-------------|---------|
| Built-in? | ‚úÖ Python 3.7+ | ‚ùå pip install |
| Validators | Manual (`__post_init__`) | ‚úÖ Built-in |
| Converters | ‚ùå No | ‚úÖ Yes |
| Slots | Manual | ‚úÖ `@attr.s(slots=True)` |
| Recommendation | Use for simple cases | Use for complex validation |

> üí° For backend: Use **Pydantic** instead of attrs (it does validation + serialization). Dataclasses for simple DTOs.

---

## 10. Mixins

Mixins are small classes with specific behavior that you **mix into** other classes via multiple inheritance.

```python
import json
from datetime import datetime

class JsonMixin:
    """Adds JSON serialization to any class"""
    def to_json(self):
        return json.dumps(self.__dict__, default=str)
    
    @classmethod
    def from_json(cls, json_str):
        data = json.loads(json_str)
        return cls(**data)

class TimestampMixin:
    """Adds timestamp tracking"""
    def __init_subclass__(cls, **kwargs):
        super().__init_subclass__(**kwargs)
    
    def touch(self):
        self.updated_at = datetime.now().isoformat()

class LogMixin:
    """Adds logging capability"""
    def log(self, message):
        print(f"[{self.__class__.__name__}] {message}")

# Mix them in!
class User(JsonMixin, TimestampMixin, LogMixin):
    def __init__(self, name, email):
        self.name = name
        self.email = email
        self.created_at = datetime.now().isoformat()
    
    def save(self):
        self.touch()               # From TimestampMixin
        self.log(f"Saved {self.name}")  # From LogMixin
        return self.to_json()      # From JsonMixin

user = User("Sid", "sid@mail.com")
print(user.save())
# [User] Saved Sid
# {"name": "Sid", "email": "sid@mail.com", "created_at": "...", "updated_at": "..."}
```

> üí° **Mixin rules**: (1) Mixins should be small, single-purpose. (2) They should NOT have `__init__`. (3) Name them `XxxMixin`.

---

## 11. Composition vs Inheritance (When to Use Which)

### Inheritance ‚Äî "IS-A" Relationship
```python
# Dog IS-A Animal (makes sense)
class Animal:
    def breathe(self):
        return "Breathing..."

class Dog(Animal):
    def bark(self):
        return "Woof!"
```

### Composition ‚Äî "HAS-A" Relationship
```python
# Car HAS-A Engine (NOT: Car IS-A Engine)
class Engine:
    def __init__(self, horsepower):
        self.horsepower = horsepower
    
    def start(self):
        return f"Engine ({self.horsepower}HP) started!"

class GPS:
    def navigate(self, destination):
        return f"Navigating to {destination}..."

class Car:
    def __init__(self, brand, horsepower):
        self.brand = brand
        self.engine = Engine(horsepower)    # Composition ‚Äî HAS-A
        self.gps = GPS()                    # Composition ‚Äî HAS-A
    
    def start(self):
        return f"{self.brand}: {self.engine.start()}"
    
    def go_to(self, place):
        return self.gps.navigate(place)

car = Car("Toyota", 150)
print(car.start())            # Toyota: Engine (150HP) started!
print(car.go_to("Mumbai"))    # Navigating to Mumbai...
```

### Backend Example ‚Äî Composition Over Inheritance
```python
# ‚ùå Bad: Inheritance for code reuse ‚Üí tight coupling
class UserRepository(DatabaseConnection, CacheManager, Logger):
    pass    # Inherits from 3 things ‚Äî messy!

# ‚úÖ Good: Composition ‚Üí loose coupling, flexible
class UserRepository:
    def __init__(self, db, cache, logger):
        self.db = db          # HAS-A database
        self.cache = cache    # HAS-A cache
        self.logger = logger  # HAS-A logger
    
    def get_user(self, user_id):
        # Check cache first
        user = self.cache.get(f"user:{user_id}")
        if user:
            self.logger.info(f"Cache hit for user {user_id}")
            return user
        
        # Fall back to database
        user = self.db.query(f"SELECT * FROM users WHERE id={user_id}")
        self.cache.set(f"user:{user_id}", user)
        return user
```

### Decision Guide
| Question | Answer |
|----------|--------|
| IS-A relationship? | Use inheritance |
| HAS-A relationship? | Use composition |
| Need code reuse only? | Prefer composition |
| Tight logical hierarchy? | Inheritance OK |
| Want flexibility/swappable parts? | Composition |
| Multiple behaviors needed? | Mixins or composition |

> üí° **Golden rule**: "Favor composition over inheritance." ‚Äî Gang of Four Design Patterns

---

## 12. SOLID Principles in Python

### S ‚Äî Single Responsibility Principle
Each class should have **one reason to change**.

```python
# ‚ùå BAD ‚Äî UserManager does EVERYTHING
class UserManager:
    def create_user(self, data): ...
    def send_email(self, user): ...
    def generate_report(self, user): ...
    def save_to_db(self, user): ...

# ‚úÖ GOOD ‚Äî Each class has ONE responsibility
class UserService:
    def create_user(self, data): ...

class EmailService:
    def send_email(self, user): ...

class ReportGenerator:
    def generate_report(self, user): ...

class UserRepository:
    def save(self, user): ...
```

### O ‚Äî Open/Closed Principle
Open for **extension**, closed for **modification**.

```python
from abc import ABC, abstractmethod

# ‚úÖ New payment methods = new class, no modification of existing code
class PaymentProcessor(ABC):
    @abstractmethod
    def pay(self, amount): ...

class CreditCardPayment(PaymentProcessor):
    def pay(self, amount):
        print(f"Paid ‚Çπ{amount} via Credit Card")

class UPIPayment(PaymentProcessor):
    def pay(self, amount):
        print(f"Paid ‚Çπ{amount} via UPI")

# Adding new payment ‚Üí just add a new class!
class CryptoPayment(PaymentProcessor):
    def pay(self, amount):
        print(f"Paid ‚Çπ{amount} via Crypto")

def checkout(processor: PaymentProcessor, amount):
    processor.pay(amount)    # Works with ANY processor ‚Äî past, present, future
```

### L ‚Äî Liskov Substitution Principle
Subclasses should be **substitutable** for their parent class.

```python
# ‚ùå BAD ‚Äî Penguin breaks the contract of Bird
class Bird:
    def fly(self): return "Flying!"

class Penguin(Bird):
    def fly(self): raise Exception("Can't fly!")  # Breaks LSP!

# ‚úÖ GOOD ‚Äî Separate flying from non-flying
class Bird:
    def eat(self): return "Eating..."

class FlyingBird(Bird):
    def fly(self): return "Flying!"

class Penguin(Bird):
    def swim(self): return "Swimming!"
```

### I ‚Äî Interface Segregation Principle
Don't force classes to implement methods they don't use.

```python
from abc import ABC, abstractmethod

# ‚ùå BAD ‚Äî Fat interface
class Worker(ABC):
    @abstractmethod
    def work(self): ...
    @abstractmethod
    def eat(self): ...

class Robot(Worker):
    def work(self): return "Working..."
    def eat(self): pass    # Robots don't eat! Forced to implement.

# ‚úÖ GOOD ‚Äî Segregated interfaces
class Workable(ABC):
    @abstractmethod
    def work(self): ...

class Eatable(ABC):
    @abstractmethod
    def eat(self): ...

class Human(Workable, Eatable):
    def work(self): return "Working..."
    def eat(self): return "Eating..."

class Robot(Workable):    # Only implements what it needs
    def work(self): return "Working..."
```

### D ‚Äî Dependency Inversion Principle
Depend on **abstractions**, not concrete implementations.

```python
from abc import ABC, abstractmethod

# ‚ùå BAD ‚Äî Directly depends on MySQL
class UserService:
    def __init__(self):
        self.db = MySQLDatabase()    # Tight coupling!

# ‚úÖ GOOD ‚Äî Depends on abstraction
class Database(ABC):
    @abstractmethod
    def save(self, data): ...
    @abstractmethod
    def find(self, id): ...

class PostgresDB(Database):
    def save(self, data): print(f"Postgres: saving {data}")
    def find(self, id): print(f"Postgres: finding {id}")

class MongoDB(Database):
    def save(self, data): print(f"Mongo: saving {data}")
    def find(self, id): print(f"Mongo: finding {id}")

class UserService:
    def __init__(self, db: Database):    # Accepts ANY Database!
        self.db = db
    
    def create_user(self, data):
        self.db.save(data)

# Swap databases without changing UserService!
service = UserService(PostgresDB())
service.create_user({"name": "Sid"})    # Postgres: saving {'name': 'Sid'}

service = UserService(MongoDB())
service.create_user({"name": "Sid"})    # Mongo: saving {'name': 'Sid'}
```

### SOLID Summary
| Principle | Short Rule |
|-----------|-----------|
| **S**ingle Responsibility | One class = one job |
| **O**pen/Closed | Extend, don't modify |
| **L**iskov Substitution | Subclass = substitutable |
| **I**nterface Segregation | Small interfaces > fat interfaces |
| **D**ependency Inversion | Depend on abstractions |

---

## üîó Quick Reference

```python
from dataclasses import dataclass, field
from abc import ABC, abstractmethod

# @classmethod ‚Äî alternative constructors, class-level ops
# @staticmethod ‚Äî utility functions (no self/cls)
# @property ‚Äî attribute-like access with getter/setter logic
# Dunder methods ‚Äî customize built-in behavior (__add__, __eq__, __len__, etc.)
# __slots__ ‚Äî memory optimization (no __dict__)
# @dataclass ‚Äî auto-generate __init__, __repr__, __eq__
# Mixins ‚Äî small, focused classes mixed via multiple inheritance
# Composition ‚Äî "HAS-A" ‚Üí prefer over inheritance
# SOLID ‚Äî S: one job, O: extend not modify, L: substitutable,
#          I: small interfaces, D: depend on abstractions
```

---

> üìù **Phase 4 Complete!** Next: Phase 5 ‚Äî Error Handling & File Operations
