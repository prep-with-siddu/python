# 5.1 Exception Handling â€” Notes

> **Status**: âœ… Completed  
> **Date**: 28 February 2026

---

## 1. `try`, `except`, `else`, `finally`

```python
# ---- Basic structure ----
try:
    # Code that MIGHT raise an exception
    result = 10 / 2
except ZeroDivisionError:
    # Runs ONLY if the specific exception occurs
    print("Cannot divide by zero!")
else:
    # Runs ONLY if NO exception occurred
    print(f"Result: {result}")
finally:
    # ALWAYS runs â€” exception or not, even if you return!
    print("Cleanup done.")

# Output:
# Result: 5.0
# Cleanup done.
```

### With an Error
```python
try:
    result = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero!")    # â† This runs
else:
    print(f"Result: {result}")          # â† Skipped (exception happened)
finally:
    print("Cleanup done.")             # â† Always runs

# Output:
# Cannot divide by zero!
# Cleanup done.
```

### `finally` Always Runs â€” Even with `return`!
```python
def divide(a, b):
    try:
        result = a / b
        return result
    except ZeroDivisionError:
        return "Error: division by zero"
    finally:
        print("finally block executed!")    # Runs BEFORE the return!

print(divide(10, 2))
# finally block executed!
# 5.0

print(divide(10, 0))
# finally block executed!
# Error: division by zero
```

### Flow Summary
```
try â†’ (exception?) 
  â”œâ”€â”€ YES â†’ except â†’ finally
  â””â”€â”€ NO  â†’ else   â†’ finally
```

> ğŸ’¡ **Backend rule**: Use `else` for code that should only run on success. Use `finally` for cleanup (closing connections, files, etc.).

---

## 2. Catching Specific Exceptions

```python
# âŒ BAD â€” bare except catches EVERYTHING (even KeyboardInterrupt, SystemExit!)
try:
    x = int("abc")
except:
    print("Something went wrong")    # Too broad!

# âŒ BAD â€” catching Exception is too broad
try:
    x = int("abc")
except Exception:
    print("Something went wrong")    # Better, but still too broad

# âœ… GOOD â€” catch SPECIFIC exceptions
try:
    x = int("abc")
except ValueError:
    print("Invalid number format")    # Exact!

# âœ… Access the exception object
try:
    x = int("abc")
except ValueError as e:
    print(f"Error: {e}")              # Error: invalid literal for int() with base 10: 'abc'
    print(f"Type: {type(e).__name__}") # Type: ValueError
```

### Common Built-in Exceptions
| Exception | When It Happens |
|-----------|----------------|
| `ValueError` | Wrong value (`int("abc")`) |
| `TypeError` | Wrong type (`"2" + 2`) |
| `KeyError` | Missing dict key (`d["missing"]`) |
| `IndexError` | List index out of range (`[1,2][5]`) |
| `AttributeError` | Missing attribute (`"hi".foo()`) |
| `FileNotFoundError` | File doesn't exist |
| `PermissionError` | No file permissions |
| `ZeroDivisionError` | Division by zero |
| `ImportError` | Module not found |
| `ConnectionError` | Network connection failed |
| `TimeoutError` | Operation timed out |
| `OSError` | OS-level error |
| `RuntimeError` | Generic runtime error |
| `StopIteration` | Iterator exhausted |
| `OverflowError` | Number too large |
| `RecursionError` | Max recursion depth exceeded |

---

## 3. Multiple `except` Blocks

```python
def process_data(data, index):
    try:
        value = data[index]       # Could raise IndexError
        result = int(value)       # Could raise ValueError
        answer = 100 / result     # Could raise ZeroDivisionError
        return answer
    except IndexError:
        print(f"Index {index} is out of range")
    except ValueError:
        print(f"'{data[index]}' is not a valid number")
    except ZeroDivisionError:
        print("Cannot divide by zero")

data = ["10", "abc", "0", "5"]

process_data(data, 0)     # Returns 10.0
process_data(data, 10)    # Index 10 is out of range
process_data(data, 1)     # 'abc' is not a valid number
process_data(data, 2)     # Cannot divide by zero
```

### Catching Multiple Exceptions in One Block
```python
try:
    # some risky operation
    result = int("abc") / 0
except (ValueError, ZeroDivisionError, TypeError) as e:
    print(f"Error: {type(e).__name__}: {e}")
```

### Ordering Matters â€” Specific Before General!
```python
# âœ… CORRECT â€” specific first
try:
    open("/nonexistent/file.txt")
except FileNotFoundError:     # More specific (child class)
    print("File not found!")
except OSError:               # More general (parent class)
    print("OS error occurred!")
except Exception:             # Most general
    print("Something went wrong!")

# âŒ WRONG â€” general first catches everything
try:
    open("/nonexistent/file.txt")
except Exception:             # Catches EVERYTHING â€” specific blocks never reached!
    print("Something went wrong!")
except FileNotFoundError:     # âš ï¸ NEVER reached! Dead code!
    print("File not found!")
```

---

## 4. Exception Hierarchy

```
BaseException
â”œâ”€â”€ SystemExit             â† sys.exit()
â”œâ”€â”€ KeyboardInterrupt      â† Ctrl+C
â”œâ”€â”€ GeneratorExit
â””â”€â”€ Exception              â† ALL regular exceptions
    â”œâ”€â”€ StopIteration
    â”œâ”€â”€ ArithmeticError
    â”‚   â”œâ”€â”€ ZeroDivisionError
    â”‚   â”œâ”€â”€ OverflowError
    â”‚   â””â”€â”€ FloatingPointError
    â”œâ”€â”€ LookupError
    â”‚   â”œâ”€â”€ IndexError
    â”‚   â””â”€â”€ KeyError
    â”œâ”€â”€ OSError
    â”‚   â”œâ”€â”€ FileNotFoundError
    â”‚   â”œâ”€â”€ PermissionError
    â”‚   â”œâ”€â”€ ConnectionError
    â”‚   â”‚   â”œâ”€â”€ ConnectionRefusedError
    â”‚   â”‚   â””â”€â”€ ConnectionResetError
    â”‚   â””â”€â”€ TimeoutError
    â”œâ”€â”€ ValueError
    â”‚   â””â”€â”€ UnicodeError
    â”œâ”€â”€ TypeError
    â”œâ”€â”€ AttributeError
    â”œâ”€â”€ ImportError
    â”‚   â””â”€â”€ ModuleNotFoundError
    â”œâ”€â”€ RuntimeError
    â”‚   â”œâ”€â”€ RecursionError
    â”‚   â””â”€â”€ NotImplementedError
    â””â”€â”€ Warning
```

### Why This Matters
```python
# Catching a parent catches ALL children!
try:
    d = {"a": 1}
    print(d["z"])          # KeyError
except LookupError:        # Catches KeyError AND IndexError
    print("Lookup failed!")

# Never catch BaseException (it catches Ctrl+C and sys.exit too!)
# except BaseException:    # âŒ BAD!
# except Exception:        # âœ… Catches all "normal" exceptions
```

> ğŸ’¡ **Rule**: Always catch `Exception` or more specific. Never catch `BaseException`.

---

## 5. Custom Exceptions (Creating Your Own)

```python
# ---- Basic custom exception ----
class InsufficientFundsError(Exception):
    pass

# ---- Custom exception with data ----
class ValidationError(Exception):
    def __init__(self, field, message, code=None):
        self.field = field
        self.message = message
        self.code = code
        super().__init__(f"{field}: {message}")
    
    def to_dict(self):
        return {
            "field": self.field,
            "message": self.message,
            "code": self.code
        }

# Usage
try:
    raise ValidationError("email", "Invalid email format", code="INVALID_EMAIL")
except ValidationError as e:
    print(e)                 # email: Invalid email format
    print(e.to_dict())      # {'field': 'email', 'message': 'Invalid email format', 'code': 'INVALID_EMAIL'}
```

### Backend Exception Hierarchy Pattern
```python
# Base exception for your entire application
class AppError(Exception):
    """Base exception for MyApp"""
    def __init__(self, message, status_code=500):
        self.message = message
        self.status_code = status_code
        super().__init__(message)

# Auth errors
class AuthenticationError(AppError):
    def __init__(self, message="Authentication failed"):
        super().__init__(message, status_code=401)

class PermissionDeniedError(AppError):
    def __init__(self, message="Permission denied"):
        super().__init__(message, status_code=403)

# Resource errors
class NotFoundError(AppError):
    def __init__(self, resource, resource_id):
        message = f"{resource} with id '{resource_id}' not found"
        super().__init__(message, status_code=404)

class ConflictError(AppError):
    def __init__(self, message="Resource already exists"):
        super().__init__(message, status_code=409)

# Validation errors
class InvalidInputError(AppError):
    def __init__(self, errors):
        self.errors = errors    # List of field errors
        super().__init__("Validation failed", status_code=422)

# Usage
try:
    raise NotFoundError("User", 42)
except AppError as e:
    print(f"HTTP {e.status_code}: {e.message}")
    # HTTP 404: User with id '42' not found
```

> ğŸ’¡ **Backend pattern**: Create a hierarchy of custom exceptions â†’ catch them in middleware â†’ return proper HTTP error responses.

---

## 6. `raise` Keyword

```python
# ---- Raise an exception ----
def set_age(age):
    if age < 0:
        raise ValueError("Age cannot be negative")
    if age > 150:
        raise ValueError("Age seems unrealistic")
    return age

try:
    set_age(-5)
except ValueError as e:
    print(e)    # Age cannot be negative

# ---- Re-raise the same exception ----
def process():
    try:
        result = 10 / 0
    except ZeroDivisionError:
        print("Logging the error...")
        raise    # Re-raises the SAME exception (preserves traceback!)

# ---- Raise from variable ----
error = ValueError("Something broke")
# raise error    # Can raise exception objects

# ---- Conditional raise ----
def validate_email(email):
    if not email:
        raise ValueError("Email is required")
    if "@" not in email:
        raise ValueError(f"Invalid email: {email}")
    return email.lower().strip()
```

---

## 7. Exception Chaining (`raise ... from ...`)

```python
# ---- Implicit chaining (automatic) ----
try:
    try:
        int("abc")
    except ValueError:
        # New exception during handling â†’ implicit chain
        d = {}
        print(d["key"])    # KeyError happens while handling ValueError
except KeyError:
    import traceback
    traceback.print_exc()
    # Shows: "During handling of the above exception, another exception occurred"

# ---- Explicit chaining (raise ... from ...) ----
class DatabaseError(Exception):
    pass

def get_user(user_id):
    try:
        # Simulate database query failing
        raise ConnectionError("Connection refused")
    except ConnectionError as e:
        # Wrap the low-level error in a high-level error
        raise DatabaseError(f"Failed to fetch user {user_id}") from e

try:
    get_user(42)
except DatabaseError as e:
    print(f"Error: {e}")                    # Error: Failed to fetch user 42
    print(f"Caused by: {e.__cause__}")      # Caused by: Connection refused
    print(f"Cause type: {type(e.__cause__).__name__}")  # Cause type: ConnectionError

# ---- Suppress chaining (raise ... from None) ----
def clean_error():
    try:
        int("abc")
    except ValueError:
        raise RuntimeError("Processing failed") from None    # Hides the original error

try:
    clean_error()
except RuntimeError as e:
    print(e)                # Processing failed
    print(e.__cause__)      # None (suppressed)
```

> ğŸ’¡ **Backend tip**: Use `raise ... from e` to wrap low-level errors (database, network) into meaningful app-level errors. Keeps the cause chain for debugging.

---

## 8. Context Managers (`with` Statement)

Context managers auto-handle **setup** and **cleanup** â€” guaranteed, even if exceptions occur.

```python
# ---- File handling (most common) ----
# Without context manager â€” risky!
f = open("test.txt", "w")
f.write("hello")
# If error here â†’ file never closed!
f.close()

# With context manager â€” safe!
with open("test.txt", "w") as f:
    f.write("hello")
# File is AUTOMATICALLY closed, even if an exception occurs!

# ---- Multiple context managers ----
with open("input.txt") as infile, open("output.txt", "w") as outfile:
    data = infile.read()
    outfile.write(data.upper())

# ---- Python 3.10+ â€” parenthesized context managers ----
with (
    open("input.txt") as infile,
    open("output.txt", "w") as outfile,
):
    pass
```

### Common Built-in Context Managers
```python
import threading
import sqlite3

# File handling
with open("file.txt") as f:
    data = f.read()

# Threading locks
lock = threading.Lock()
with lock:    # Acquires on enter, releases on exit
    # Critical section
    pass

# Database connections
with sqlite3.connect("mydb.db") as conn:
    conn.execute("CREATE TABLE IF NOT EXISTS users (id INTEGER, name TEXT)")
    # Auto-commits on success, rolls back on exception

# Suppressing exceptions
from contextlib import suppress
with suppress(FileNotFoundError):
    os.remove("maybe_missing.txt")    # No error if file doesn't exist
```

---

## 9. Creating Custom Context Managers (`__enter__`, `__exit__`)

### Class-Based Context Manager
```python
class Timer:
    """Measures execution time of a code block"""
    def __enter__(self):
        import time
        self.start = time.time()
        return self    # This is what `as` binds to
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        import time
        self.elapsed = time.time() - self.start
        print(f"Elapsed: {self.elapsed:.4f}s")
        return False    # Don't suppress exceptions

with Timer() as t:
    # Some operation
    total = sum(range(1_000_000))
# Elapsed: 0.0312s
print(f"Total: {total}, Time: {t.elapsed:.4f}s")


class DatabaseConnection:
    def __init__(self, db_url):
        self.db_url = db_url
        self.connection = None
    
    def __enter__(self):
        print(f"Connecting to {self.db_url}...")
        self.connection = {"status": "connected", "url": self.db_url}  # Simulated
        return self.connection
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Closing connection...")
        self.connection = None
        
        if exc_type is not None:
            print(f"Error occurred: {exc_type.__name__}: {exc_val}")
            # return True to suppress the exception
            # return False (or None) to let it propagate
        return False

with DatabaseConnection("postgres://localhost/mydb") as conn:
    print(f"Status: {conn['status']}")
# Connecting to postgres://localhost/mydb...
# Status: connected
# Closing connection...
```

### `__exit__` Parameters
```python
def __exit__(self, exc_type, exc_val, exc_tb):
    # exc_type  â†’ Exception class (e.g., ValueError) or None
    # exc_val   â†’ Exception instance (e.g., ValueError("bad"))  or None
    # exc_tb    â†’ Traceback object or None
    
    # If no exception: all three are None
    # Return True  â†’ suppress the exception (swallow it)
    # Return False â†’ let the exception propagate (re-raise it)
    pass
```

---

## 10. `contextlib` Module (`contextmanager` Decorator)

The **easier** way to create context managers â€” using a generator function!

```python
from contextlib import contextmanager

@contextmanager
def timer(label="Block"):
    import time
    start = time.time()
    try:
        yield    # Everything before yield = __enter__, after = __exit__
    finally:
        elapsed = time.time() - start
        print(f"{label}: {elapsed:.4f}s")

with timer("Sorting"):
    sorted(range(1_000_000, 0, -1))
# Sorting: 0.1234s
```

### With a Return Value
```python
from contextlib import contextmanager

@contextmanager
def managed_file(path, mode="r"):
    f = open(path, mode)
    try:
        yield f        # `as` binds to whatever you yield
    finally:
        f.close()
        print(f"File '{path}' closed")

with managed_file("test.txt", "w") as f:
    f.write("Hello from contextmanager!")
# File 'test.txt' closed
```

### Real-World Backend Example â€” Transaction Manager
```python
from contextlib import contextmanager

@contextmanager
def transaction(connection):
    """Manages database transaction â€” commits on success, rolls back on error"""
    cursor = connection.cursor()
    try:
        yield cursor
        connection.commit()
        print("Transaction committed")
    except Exception:
        connection.rollback()
        print("Transaction rolled back!")
        raise    # Re-raise after rollback
    finally:
        cursor.close()

# Usage:
# with transaction(db_conn) as cursor:
#     cursor.execute("INSERT INTO users ...")
#     cursor.execute("UPDATE accounts ...")
#     # If error â†’ auto rollback. If success â†’ auto commit.
```

### Other Useful `contextlib` Tools
```python
from contextlib import suppress, redirect_stdout, closing
import io

# suppress â€” ignore specific exceptions
with suppress(FileNotFoundError, PermissionError):
    os.remove("nonexistent.txt")    # No error raised

# redirect_stdout â€” capture print output
f = io.StringIO()
with redirect_stdout(f):
    print("This goes to StringIO, not console")
captured = f.getvalue()
print(f"Captured: {captured}")

# closing â€” auto-call .close() on exit
# with closing(urllib.request.urlopen("http://example.com")) as page:
#     html = page.read()

# ExitStack â€” dynamic number of context managers
from contextlib import ExitStack

files_to_open = ["file1.txt", "file2.txt", "file3.txt"]
with ExitStack() as stack:
    files = [stack.enter_context(open(f, "w")) for f in files_to_open]
    for f in files:
        f.write("hello\n")
# All files closed automatically!
```

---

## 11. Logging Errors Properly (`logging` Module)

```python
import logging

# ---- Basic setup ----
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S"
)

logger = logging.getLogger(__name__)

# ---- Log levels (lowest â†’ highest) ----
logger.debug("Variable x = 42")           # Debugging details
logger.info("User logged in")             # General info
logger.warning("Disk space running low")  # Something concerning
logger.error("Failed to connect to DB")   # Error occurred
logger.critical("Application is DOWN!")   # Critical failure
```

### Logging Exceptions (with Traceback!)
```python
import logging

logger = logging.getLogger(__name__)

def divide(a, b):
    try:
        return a / b
    except ZeroDivisionError:
        # âœ… exc_info=True includes full traceback in log
        logger.error("Division by zero!", exc_info=True)
        return None
    except Exception:
        # âœ… logger.exception() = logger.error() + exc_info=True
        logger.exception("Unexpected error in divide()")
        return None

divide(10, 0)
# 2026-02-28 10:00:00 [ERROR] __main__: Division by zero!
# Traceback (most recent call last):
#   File "...", line 7, in divide
#     return a / b
# ZeroDivisionError: division by zero
```

### Logging to File
```python
import logging

# Log to file AND console
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler("app.log"),         # To file
        logging.StreamHandler()                  # To console
    ]
)

logger = logging.getLogger("myapp")
logger.info("Application started")
logger.error("Database connection failed")
```

### Backend Logging Pattern
```python
import logging

logger = logging.getLogger(__name__)

def create_user(data):
    logger.info(f"Creating user: {data.get('email')}")
    
    try:
        # ... create user logic ...
        user_id = 42  # simulated
        logger.info(f"User created successfully: id={user_id}")
        return user_id
    except Exception as e:
        logger.exception(f"Failed to create user: {data.get('email')}")  # Full traceback
        raise

# âŒ NEVER log sensitive data!
# logger.info(f"User password: {password}")     # âŒ 
# logger.info(f"API key: {api_key}")            # âŒ
# logger.info(f"Token: {auth_token}")           # âŒ
```

### Log Levels Guide
| Level | When to Use | Example |
|-------|------------|---------|
| `DEBUG` | Detailed dev info | `"Query returned 42 rows"` |
| `INFO` | Normal operations | `"User 123 logged in"` |
| `WARNING` | Something unusual | `"Rate limit approaching"` |
| `ERROR` | Operation failed | `"Failed to send email"` |
| `CRITICAL` | System is broken | `"Database is unreachable"` |

> ğŸ’¡ **Backend rule**: ALWAYS use `logging`, NEVER use `print()` in production. Use `logger.exception()` to capture tracebacks.

---

## ğŸ”— Quick Reference

```python
# ---- try/except/else/finally ----
try:
    risky_operation()
except SpecificError as e:
    handle_error(e)
except (Error1, Error2):
    handle_multiple()
else:
    on_success()
finally:
    cleanup()

# ---- Custom exceptions ----
class MyError(Exception):
    def __init__(self, message, code=None):
        self.code = code
        super().__init__(message)

# ---- Raise / Chain ----
raise ValueError("bad input")
raise AppError("failed") from original_error
raise  # re-raise current exception

# ---- Context managers ----
with open("f.txt") as f: ...              # Built-in
with MyContextManager() as x: ...        # Class-based

from contextlib import contextmanager
@contextmanager
def my_cm():
    setup()
    try:
        yield resource
    finally:
        cleanup()

# ---- Logging ----
import logging
logger = logging.getLogger(__name__)
logger.info("message")
logger.exception("error with traceback")
```

---

> ğŸ“ **Next up**: Section 5.2 â€” File Handling
