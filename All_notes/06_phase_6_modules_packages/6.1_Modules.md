# 6.1 Modules â€” Notes

> **Status**: âœ… Completed  
> **Date**: 28 February 2026

---

## 1. Importing Modules (`import`, `from ... import`, `as`)

### Basic `import`
```python
# ---- import entire module ----
import math

print(math.sqrt(16))       # 4.0
print(math.pi)             # 3.141592653589793
print(math.ceil(4.3))      # 5
print(math.floor(4.7))     # 4

# You MUST use the module name as prefix: math.sqrt()
```

### `from ... import`
```python
# ---- Import specific items ----
from math import sqrt, pi, ceil

print(sqrt(16))             # 4.0 â€” no prefix needed!
print(pi)                   # 3.141592653589793
print(ceil(4.3))            # 5

# ---- Import everything (AVOID THIS!) ----
from math import *          # âŒ Bad practice â€” pollutes namespace
print(sqrt(16))             # Works but you don't know where sqrt came from

# Why it's bad:
from math import *
from numpy import *         # numpy also has sqrt! Which one wins? Confusion!
```

### `as` (Aliasing)
```python
# ---- Rename module ----
import numpy as np          # Convention: numpy â†’ np
import pandas as pd         # Convention: pandas â†’ pd
import matplotlib.pyplot as plt

print(np.array([1, 2, 3]))

# ---- Rename specific import ----
from datetime import datetime as dt

now = dt.now()
print(now)

# ---- Useful for long module names ----
from collections import defaultdict as dd
from concurrent.futures import ThreadPoolExecutor as TPE
```

### Import Styles â€” When to Use What

| Style | When to Use | Example |
|-------|------------|---------|
| `import module` | Using many things from module | `import os` |
| `from module import x` | Using 1-3 specific things | `from pathlib import Path` |
| `import module as alias` | Long module name / convention | `import numpy as np` |
| `from module import *` | **NEVER** (in production code) | â€” |

### What Happens When You Import?
```python
import math
# 1. Python searches for "math" module
# 2. Executes ALL code in math.py (top-level)
# 3. Creates a module object
# 4. Binds the name "math" in current namespace

# Import is CACHED â€” second import doesn't re-execute!
import math    # First time â†’ executes math.py
import math    # Second time â†’ uses cached version (no re-execution)
```

### Module Search Order
```python
# When you do: import mymodule
# Python searches in this order:
# 1. sys.modules (cache of already-imported modules)
# 2. Built-in modules (math, os, sys, etc.)
# 3. sys.path:
#    a. Current directory
#    b. PYTHONPATH environment variable
#    c. Standard library directories
#    d. Site-packages (pip installed packages)

import sys
print(sys.path)    # Shows all search directories

# You can add to sys.path dynamically (but avoid in production)
sys.path.append("/my/custom/path")
```

---

## 2. `__name__` and `if __name__ == "__main__"`

This is one of the **most important** Python concepts.

### How It Works
```python
# ---- utils.py ----
def greet(name):
    return f"Hello, {name}!"

def add(a, b):
    return a + b

print(f"__name__ = {__name__}")

# When you RUN this file directly:
#   python utils.py â†’ __name__ = "__main__"

# When you IMPORT this file:
#   import utils â†’ __name__ = "utils" (the module name)
```

### The Pattern
```python
# ---- utils.py ----
def greet(name):
    return f"Hello, {name}!"

def add(a, b):
    return a + b

# This block ONLY runs when file is executed directly
if __name__ == "__main__":
    # Test code, demo code, CLI entry point
    print(greet("Sid"))       # Hello, Sid!
    print(add(2, 3))          # 5
    print("Running utils.py directly!")
```

```python
# ---- main.py ----
import utils

# Only the functions are available â€” the test code did NOT run!
print(utils.greet("Rahul"))    # Hello, Rahul!
print(utils.add(10, 20))      # 30
```

### Why It Matters (Real-World Use Cases)
```python
# ---- 1. Script that can also be imported ----
# db_migrator.py
def migrate_database():
    print("Running migrations...")

def rollback_database():
    print("Rolling back...")

if __name__ == "__main__":
    # Run as CLI: python db_migrator.py
    migrate_database()

# But also importable:
# from db_migrator import migrate_database

# ---- 2. Quick testing without pytest ----
# calculator.py
def multiply(a, b):
    return a * b

if __name__ == "__main__":
    # Quick manual test
    assert multiply(3, 4) == 12
    assert multiply(0, 5) == 0
    print("All tests passed!")

# ---- 3. Entry point for packages ----
# app/main.py
from app.routes import setup_routes
from app.config import load_config

def create_app():
    config = load_config()
    app = setup_routes(config)
    return app

if __name__ == "__main__":
    app = create_app()
    app.run(host="0.0.0.0", port=8000)
```

### Memory Trick
```
__name__ == "__main__"  â†’ "Am I the main character?"
  - If YES (run directly) â†’ Execute this block
  - If NO (imported)     â†’ Skip this block
```

---

## 3. Creating Your Own Modules

A module is just a `.py` file!

### Simple Module
```python
# ---- string_utils.py (this IS a module!) ----

def capitalize_words(text):
    """Capitalize first letter of each word."""
    return " ".join(word.capitalize() for word in text.split())

def reverse_string(text):
    """Reverse a string."""
    return text[::-1]

def count_vowels(text):
    """Count vowels in a string."""
    return sum(1 for ch in text.lower() if ch in "aeiou")

# Constants (module-level variables)
VOWELS = "aeiou"
MAX_LENGTH = 255
```

```python
# ---- main.py ----
import string_utils

print(string_utils.capitalize_words("hello world"))    # Hello World
print(string_utils.reverse_string("Python"))           # nohtyP
print(string_utils.count_vowels("beautiful"))          # 5
print(string_utils.MAX_LENGTH)                         # 255

# Or import specific items
from string_utils import capitalize_words, VOWELS
print(capitalize_words("good morning"))                # Good Morning
```

### Module with Classes
```python
# ---- models.py ----
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email
    
    def __repr__(self):
        return f"User(name='{self.name}', email='{self.email}')"

class Product:
    def __init__(self, name, price):
        self.name = name
        self.price = price
    
    def __repr__(self):
        return f"Product(name='{self.name}', price={self.price})"
```

```python
# ---- app.py ----
from models import User, Product

user = User("Sid", "sid@example.com")
product = Product("Laptop", 75000)
print(user)       # User(name='Sid', email='sid@example.com')
print(product)    # Product(name='Laptop', price=75000)
```

### Module Best Practices
```python
# ---- config.py (good module design) ----

"""
Configuration module for the application.
Handles loading and validating config values.
"""

import os
from pathlib import Path

# Constants at top
BASE_DIR = Path(__file__).parent
DEBUG = os.getenv("DEBUG", "false").lower() == "true"
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///db.sqlite3")

# Functions
def get_config():
    """Return config as a dictionary."""
    return {
        "base_dir": BASE_DIR,
        "debug": DEBUG,
        "database_url": DATABASE_URL,
    }

# Guard for direct execution
if __name__ == "__main__":
    from pprint import pprint
    pprint(get_config())
```

---

## 4. `__init__.py` and Packages

A **package** is a directory with an `__init__.py` file.

### Basic Package Structure
```
myapp/
â”œâ”€â”€ __init__.py          â† Makes myapp a PACKAGE
â”œâ”€â”€ models.py
â”œâ”€â”€ views.py
â”œâ”€â”€ utils.py
â””â”€â”€ services/
    â”œâ”€â”€ __init__.py      â† Makes services a SUB-PACKAGE
    â”œâ”€â”€ auth.py
    â””â”€â”€ email.py
```

### `__init__.py` â€” What It Does
```python
# ---- myapp/__init__.py ----

# 1. Can be EMPTY (just marks directory as a package)
# 2. Can contain initialization code
# 3. Can control what's importable

# Example: Initialize the package
print("myapp package loaded!")    # Runs when you import myapp

# Example: Make key items directly accessible
from myapp.models import User
from myapp.views import home_view

# Now users can do:
# from myapp import User, home_view
# Instead of:
# from myapp.models import User
```

### Package-Level Imports
```python
# ---- myapp/__init__.py ----
from .models import User, Product          # Relative import (.)
from .utils import capitalize_words
from .services.auth import authenticate    # From sub-package

# Package version
__version__ = "1.0.0"
__author__ = "Sid"
```

```python
# ---- Using the package ----
import myapp
print(myapp.__version__)           # 1.0.0

from myapp import User             # Works because of __init__.py!
from myapp import authenticate     # Works because of __init__.py!

# Without __init__.py setup, you'd need:
from myapp.models import User                    # Longer path
from myapp.services.auth import authenticate     # Even longer
```

### Namespace Packages (Python 3.3+)
```python
# Python 3.3+ allows packages WITHOUT __init__.py
# Called "namespace packages"
# Useful for splitting a package across directories

# But for normal use: ALWAYS include __init__.py
# It makes your intent clear and is the standard practice
```

### Real-World Package Example
```
ecommerce/
â”œâ”€â”€ __init__.py           # from .models import *; __version__ = "2.0"
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ __init__.py       # from .user import User; from .product import Product
â”‚   â”œâ”€â”€ user.py           # class User
â”‚   â”œâ”€â”€ product.py        # class Product
â”‚   â””â”€â”€ order.py          # class Order
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ payment.py        # process_payment()
â”‚   â”œâ”€â”€ shipping.py       # calculate_shipping()
â”‚   â””â”€â”€ notification.py   # send_email(), send_sms()
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ routes.py
â”‚   â””â”€â”€ serializers.py
â””â”€â”€ utils/
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ validators.py
    â””â”€â”€ helpers.py
```

---

## 5. Relative Imports vs Absolute Imports

### Absolute Imports (PREFERRED)
```python
# Always specify the FULL path from the project root

# ---- myapp/services/auth.py ----
from myapp.models import User              # Full path from root
from myapp.utils.validators import validate_email
from myapp.services.email import send_email

# Pros: Clear, explicit, easy to understand
# Cons: Can be long for deeply nested packages
```

### Relative Imports
```python
# Use dots (.) to specify relative path
# . = current package
# .. = parent package
# ... = grandparent package

# ---- myapp/services/auth.py ----
from ..models import User              # Go up one level â†’ myapp/models
from ..utils.validators import validate_email  # Go up â†’ myapp/utils/validators
from .email import send_email          # Same directory â†’ myapp/services/email

# ---- myapp/models/__init__.py ----
from .user import User                 # Same directory â†’ myapp/models/user
from .product import Product           # Same directory â†’ myapp/models/product
```

### Comparison

| Feature | Absolute | Relative |
|---------|----------|----------|
| Syntax | `from myapp.models import X` | `from ..models import X` |
| Clarity | Very clear âœ… | Can be confusing âŒ |
| Refactoring | Need to update if package moves | Stays same if internal structure unchanged |
| Works as script? | Yes âœ… | No âŒ (`python file.py` fails) |
| PEP 8 recommendation | **Preferred** âœ… | Acceptable for internal |

### Common Relative Import Error
```python
# âŒ This will FAIL if you run the file directly:
#    python myapp/services/auth.py
# Error: ImportError: attempted relative import with no known parent package

# âœ… Must run as a module:
#    python -m myapp.services.auth

# âœ… Or use absolute imports (always work!)
```

### Best Practice
```python
# Use ABSOLUTE imports for:
# - Top-level imports in any file
# - Imports from other packages
# - When clarity matters (always!)

# Use RELATIVE imports for:
# - __init__.py files (from .module import Class)
# - Internal package structure (keeps package self-contained)
#   e.g., from .utils import helper  (within the same package)
```

---

## 6. `__all__` Variable

Controls what gets exported when someone does `from module import *`.

### Without `__all__`
```python
# ---- myutils.py ----
def public_func():
    return "I'm public"

def another_public():
    return "Also public"

def _private_func():          # Leading underscore = convention for "private"
    return "I'm private"

CONSTANT = 42
_INTERNAL = "secret"
```

```python
# from myutils import *
# Imports: public_func, another_public, CONSTANT
# Does NOT import: _private_func, _INTERNAL (underscore = skipped)
```

### With `__all__`
```python
# ---- myutils.py ----
__all__ = ["public_func", "CONSTANT"]    # ONLY these get exported with *

def public_func():
    return "I'm public"

def another_public():
    return "Also public but NOT in __all__"

def _private_func():
    return "I'm private"

CONSTANT = 42
```

```python
# from myutils import *
# Imports: ONLY public_func, CONSTANT
# another_public is NOT imported (not in __all__)!
# But you can still do: from myutils import another_public (explicit import always works)
```

### `__all__` in `__init__.py`
```python
# ---- myapp/__init__.py ----
from .models import User, Product
from .utils import validate_email
from .services import authenticate

__all__ = [
    "User",
    "Product",
    "validate_email",
    "authenticate",
]

# from myapp import * â†’ Only gets User, Product, validate_email, authenticate
```

### Why Use `__all__`?
```python
# 1. Controls public API â€” tells users what's meant to be used
# 2. Documentation â€” clearly shows what the module exports
# 3. Prevents namespace pollution with import *
# 4. IDEs and linters use it for auto-completion

# ---- Real example: Django model file ----
__all__ = ["User", "Profile", "Address"]

class User:
    pass

class Profile:
    pass

class Address:
    pass

class _HelperMixin:     # Internal â€” not in __all__
    pass
```

---

## 7. `importlib` for Dynamic Imports

Import modules at **runtime** using strings â€” useful for plugins, config-driven loading.

### Basic Dynamic Import
```python
import importlib

# ---- Import a module by string name ----
math_module = importlib.import_module("math")
print(math_module.sqrt(16))    # 4.0

# Same as: import math
# But the module name can be a VARIABLE!

module_name = "json"
mod = importlib.import_module(module_name)
print(mod.dumps({"key": "value"}))    # '{"key": "value"}'
```

### Import from a Package
```python
import importlib

# ---- Import submodule ----
# Same as: from os import path
path_module = importlib.import_module("os.path")
print(path_module.exists("/tmp"))    # True

# ---- Import with package parameter ----
# Same as: from myapp.services import auth
auth = importlib.import_module(".services.auth", package="myapp")
```

### Get Specific Attribute
```python
import importlib

# Load a class/function dynamically
module = importlib.import_module("json")
dumps_func = getattr(module, "dumps")    # Get the function
result = dumps_func({"name": "Sid"})
print(result)    # '{"name": "Sid"}'
```

### Real-World Use Cases

#### Plugin System
```python
import importlib

# config.yaml: plugins: ["myapp.plugins.auth", "myapp.plugins.logging"]
plugin_names = ["myapp.plugins.auth", "myapp.plugins.logging"]

plugins = []
for name in plugin_names:
    module = importlib.import_module(name)
    plugin = module.Plugin()       # Each plugin module has a Plugin class
    plugins.append(plugin)
    plugin.initialize()
```

#### Config-Driven Database Backend
```python
import importlib

# settings.py: DATABASE_BACKEND = "myapp.backends.postgresql"
BACKEND = "myapp.backends.postgresql"

def get_database_connection():
    backend = importlib.import_module(BACKEND)
    return backend.connect()

# Switch to MySQL just by changing the config:
# BACKEND = "myapp.backends.mysql"
```

#### Dynamic Serializer Loading (Django-like)
```python
import importlib

def get_serializer(model_name):
    """Load serializer class based on model name."""
    module_path = f"myapp.serializers.{model_name.lower()}"
    class_name = f"{model_name}Serializer"
    
    module = importlib.import_module(module_path)
    serializer_class = getattr(module, class_name)
    return serializer_class

# Usage:
UserSerializer = get_serializer("User")        # Loads myapp.serializers.user.UserSerializer
ProductSerializer = get_serializer("Product")   # Loads myapp.serializers.product.ProductSerializer
```

### `importlib.reload()` â€” Reload a Module
```python
import importlib
import myconfig

# After changing myconfig.py at runtime:
importlib.reload(myconfig)    # Re-executes the module!
# Useful in development/REPL, NOT in production
```

---

## ğŸ”— Quick Reference

```python
# ---- Import styles ----
import math                          # Full module
from math import sqrt, pi           # Specific items
import numpy as np                  # Alias
from pathlib import Path            # Common pattern

# ---- __name__ guard ----
if __name__ == "__main__":
    main()                           # Only runs when executed directly

# ---- Package structure ----
# mypackage/
#   __init__.py    â† Required (makes it a package)
#   module.py

# ---- __init__.py ----
from .models import User             # Relative import in __init__
__all__ = ["User"]                   # Control * exports

# ---- Relative vs Absolute ----
from myapp.models import User        # Absolute (PREFERRED)
from ..models import User            # Relative (for internal use)
from .utils import helper            # Same-package relative

# ---- __all__ ----
__all__ = ["public_func", "MyClass"] # Controls: from module import *

# ---- Dynamic imports ----
import importlib
mod = importlib.import_module("math")
cls = getattr(mod, "sqrt")
importlib.reload(mod)                # Reload module
```

---

> ğŸ“ **Next up**: 6.2 Project Structure â€” Standard layouts, `pyproject.toml`, `poetry`, `uv`, `Makefile`, `pre-commit` hooks
