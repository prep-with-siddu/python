# 6.2 Project Structure â€” Notes

> **Status**: âœ… Completed  
> **Date**: 28 February 2026

---

## 1. Standard Python Project Layout

### Minimal Project
```
my_project/
â”œâ”€â”€ my_project/           â† Source code (same name as project)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ main.py
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â””â”€â”€ test_main.py
â”œâ”€â”€ .gitignore
â”œâ”€â”€ README.md
â”œâ”€â”€ requirements.txt
â””â”€â”€ pyproject.toml        â† Modern config (replaces setup.py)
```

### Full Professional Backend Project
```
my_backend/
â”œâ”€â”€ src/                        â† "src layout" (recommended)
â”‚   â””â”€â”€ my_backend/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ main.py             â† Entry point
â”‚       â”œâ”€â”€ config.py           â† Settings/configuration
â”‚       â”œâ”€â”€ models/
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ user.py
â”‚       â”‚   â””â”€â”€ product.py
â”‚       â”œâ”€â”€ api/
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ routes.py
â”‚       â”‚   â””â”€â”€ middleware.py
â”‚       â”œâ”€â”€ services/
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ auth.py
â”‚       â”‚   â””â”€â”€ email.py
â”‚       â”œâ”€â”€ repositories/       â† Database access layer
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â””â”€â”€ user_repo.py
â”‚       â”œâ”€â”€ schemas/            â† Pydantic models / serializers
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â””â”€â”€ user.py
â”‚       â””â”€â”€ utils/
â”‚           â”œâ”€â”€ __init__.py
â”‚           â””â”€â”€ helpers.py
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ conftest.py             â† Shared fixtures
â”‚   â”œâ”€â”€ test_models/
â”‚   â”œâ”€â”€ test_api/
â”‚   â””â”€â”€ test_services/
â”œâ”€â”€ migrations/                  â† Alembic / Django migrations
â”œâ”€â”€ scripts/                     â† Utility scripts
â”œâ”€â”€ docs/                        â† Documentation
â”œâ”€â”€ .env                         â† Environment variables (NOT in git!)
â”œâ”€â”€ .env.example                 â† Template for .env (IN git)
â”œâ”€â”€ .gitignore
â”œâ”€â”€ .pre-commit-config.yaml
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ Makefile
â”œâ”€â”€ README.md
â”œâ”€â”€ pyproject.toml
â””â”€â”€ requirements/
    â”œâ”€â”€ base.txt                â† Common dependencies
    â”œâ”€â”€ dev.txt                 â† Dev tools (pytest, black, etc.)
    â””â”€â”€ prod.txt                â† Production only
```

### Flat Layout vs Src Layout

| Layout | Structure | When to Use |
|--------|-----------|-------------|
| **Flat** | `my_project/my_project/` | Simple projects, scripts |
| **Src** | `my_project/src/my_project/` | Libraries, serious projects |

```
# Flat layout (simpler)
my_project/
â”œâ”€â”€ my_project/
â”‚   â””â”€â”€ __init__.py
â””â”€â”€ tests/

# Src layout (prevents accidental imports from project root)
my_project/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ my_project/
â”‚       â””â”€â”€ __init__.py
â””â”€â”€ tests/
```

> ğŸ’¡ **Src layout** prevents a common bug: accidentally importing from source instead of installed package during testing.

---

## 2. `setup.py` and `pyproject.toml`

### `setup.py` (Legacy â€” Still Works)
```python
# setup.py â€” the OLD way to configure Python packages
from setuptools import setup, find_packages

setup(
    name="my-backend",
    version="1.0.0",
    author="Sid",
    author_email="sid@example.com",
    description="My backend project",
    packages=find_packages(where="src"),
    package_dir={"": "src"},
    python_requires=">=3.9",
    install_requires=[
        "fastapi>=0.100.0",
        "uvicorn>=0.23.0",
        "sqlalchemy>=2.0",
        "pydantic>=2.0",
    ],
    extras_require={
        "dev": ["pytest", "black", "ruff", "mypy"],
    },
)

# Install: pip install .
# Install dev: pip install .[dev]
# Install editable: pip install -e .
```

### `pyproject.toml` (MODERN â€” Use This!)
```toml
# pyproject.toml â€” the MODERN standard (PEP 518, PEP 621)
# One file to rule them all: build config + tool config

[build-system]
requires = ["setuptools>=68.0", "wheel"]
build-backend = "setuptools.backends"

[project]
name = "my-backend"
version = "1.0.0"
description = "My awesome backend project"
readme = "README.md"
license = {text = "MIT"}
requires-python = ">=3.9"
authors = [
    {name = "Sid", email = "sid@example.com"},
]

dependencies = [
    "fastapi>=0.100.0",
    "uvicorn>=0.23.0",
    "sqlalchemy>=2.0",
    "pydantic>=2.0",
    "alembic>=1.12",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0",
    "pytest-cov>=4.0",
    "black>=23.0",
    "ruff>=0.1.0",
    "mypy>=1.5",
    "pre-commit>=3.0",
]

[project.scripts]
# CLI entry points
my-backend = "my_backend.main:app"

# ---- Tool configurations (all in one file!) ----

[tool.black]
line-length = 88
target-version = ["py311"]

[tool.ruff]
line-length = 88
select = ["E", "F", "I", "N", "W"]

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = "test_*.py"
addopts = "-v --cov=my_backend --cov-report=term-missing"

[tool.mypy]
python_version = "3.11"
strict = true
warn_return_any = true
```

### `setup.py` vs `pyproject.toml`

| Feature | `setup.py` | `pyproject.toml` |
|---------|-----------|-----------------|
| Format | Python code | TOML (declarative) |
| Standard | Legacy | Modern (PEP 621) |
| Tool config | Separate files | All in one file |
| Recommended | For old projects | **For all new projects** âœ… |

> ğŸ’¡ **Rule**: Always use `pyproject.toml` for new projects. `setup.py` is legacy.

---

## 3. `pip` and `pipx`

### `pip` â€” Package Installer
```bash
# Install a package
pip install requests

# Install specific version
pip install requests==2.31.0
pip install "requests>=2.28,<3.0"    # Version range

# Install from requirements.txt
pip install -r requirements.txt

# Upgrade a package
pip install --upgrade requests

# Uninstall
pip uninstall requests

# List installed packages
pip list
pip list --outdated    # Show packages that can be upgraded

# Show package info
pip show requests

# Freeze installed versions
pip freeze > requirements.txt

# Install in editable mode (for development)
pip install -e .       # Installs current project as editable
pip install -e ".[dev]"   # With dev dependencies
```

### `requirements.txt` Best Practices
```
# requirements/base.txt â€” Production dependencies
fastapi==0.104.1
uvicorn==0.24.0
sqlalchemy==2.0.23
pydantic==2.5.2
alembic==1.13.0
redis==5.0.1

# requirements/dev.txt â€” Development dependencies
-r base.txt            # Include base requirements!
pytest==7.4.3
pytest-cov==4.1.0
black==23.12.0
ruff==0.1.8
mypy==1.7.1
pre-commit==3.6.0
factory-boy==3.3.0
faker==20.1.0

# requirements/prod.txt â€” Production-specific
-r base.txt
gunicorn==21.2.0
psycopg2-binary==2.9.9
```

### `pipx` â€” Install CLI Tools in Isolated Environments
```bash
# pipx installs Python CLI tools globally, each in their own venv
# So they don't conflict with your project's dependencies!

# Install pipx
pip install pipx
pipx ensurepath    # Add to PATH

# Install CLI tools with pipx
pipx install black         # Code formatter
pipx install ruff          # Linter
pipx install poetry        # Dependency manager
pipx install httpie        # HTTP client (like curl but better)
pipx install cookiecutter  # Project templates
pipx install pre-commit    # Git hooks
pipx install uv            # Fast pip replacement

# List installed tools
pipx list

# Run a tool once without installing
pipx run cowsay "hello"

# Upgrade
pipx upgrade black
pipx upgrade-all
```

### `pip` vs `pipx`

| Use Case | Tool | Why |
|----------|------|-----|
| Project dependencies | `pip` | Install in project venv |
| CLI tools (black, ruff) | `pipx` | Isolated, global access |
| Libraries (requests, fastapi) | `pip` | Part of your project |
| Development tools | `pipx` | Don't pollute project venv |

---

## 4. `poetry` for Dependency Management

Poetry is an **all-in-one** tool: dependency management + packaging + publishing.

### Setup
```bash
# Install poetry
pipx install poetry        # Recommended way
# OR
curl -sSL https://install.python-poetry.org | python3 -

# Create new project
poetry new my-backend
# Creates:
# my-backend/
# â”œâ”€â”€ my_backend/
# â”‚   â””â”€â”€ __init__.py
# â”œâ”€â”€ tests/
# â”‚   â””â”€â”€ __init__.py
# â”œâ”€â”€ README.md
# â””â”€â”€ pyproject.toml

# Initialize in existing project
cd existing-project
poetry init    # Interactive setup â†’ creates pyproject.toml
```

### `pyproject.toml` with Poetry
```toml
[tool.poetry]
name = "my-backend"
version = "1.0.0"
description = "My backend project"
authors = ["Sid <sid@example.com>"]
readme = "README.md"

[tool.poetry.dependencies]
python = "^3.9"
fastapi = "^0.104.0"
uvicorn = "^0.24.0"
sqlalchemy = "^2.0"
pydantic = "^2.5"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4"
black = "^23.12"
ruff = "^0.1"
mypy = "^1.7"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
```

### Poetry Commands
```bash
# ---- Dependency management ----
poetry add fastapi              # Add dependency
poetry add uvicorn sqlalchemy   # Add multiple
poetry add pytest --group dev   # Add to dev group
poetry remove fastapi           # Remove dependency
poetry update                   # Update all dependencies
poetry update fastapi           # Update specific

# ---- Virtual environment ----
poetry install                  # Install all dependencies (creates venv)
poetry shell                    # Activate virtual environment
poetry env info                 # Show venv info
poetry env list                 # List environments

# ---- Running commands ----
poetry run python main.py       # Run in poetry's venv
poetry run pytest               # Run tests
poetry run uvicorn app:main     # Run server

# ---- Lock file ----
poetry lock                     # Update poetry.lock (don't install)
poetry install --no-dev         # Production install (no dev deps)

# ---- Export ----
poetry export -f requirements.txt -o requirements.txt    # For Docker
```

### `poetry.lock`
```
# poetry.lock â€” ALWAYS commit this file!
# It contains EXACT versions of ALL dependencies (including transitive)
# Ensures everyone (and CI/CD) uses the same versions

# .gitignore should NOT include poetry.lock
```

---

## 5. `pipenv` Basics

Pipenv combines `pip` + `virtualenv` into one tool. Less popular now (poetry/uv preferred).

```bash
# Install
pip install pipenv

# Create project with Pipenv
cd my-project
pipenv install                  # Creates Pipfile + virtual env
pipenv install fastapi          # Add dependency
pipenv install pytest --dev     # Add dev dependency
pipenv install -r requirements.txt  # From requirements.txt

# Virtual environment
pipenv shell                    # Activate
exit                            # Deactivate
pipenv --venv                   # Show venv path

# Running
pipenv run python main.py
pipenv run pytest

# Lock
pipenv lock                     # Generate Pipfile.lock
```

### Pipfile
```toml
[[source]]
url = "https://pypi.org/simple"
verify_ssl = true
name = "pypi"

[packages]
fastapi = "*"
uvicorn = "*"

[dev-packages]
pytest = "*"
black = "*"

[requires]
python_version = "3.11"
```

### Poetry vs Pipenv

| Feature | Poetry | Pipenv |
|---------|--------|--------|
| Lock file | `poetry.lock` | `Pipfile.lock` |
| Config | `pyproject.toml` | `Pipfile` |
| Speed | Faster âœ… | Slower |
| Publishing | Built-in | No |
| Community | Growing fast âœ… | Declining |
| Recommendation | **Use this** âœ… | Legacy |

---

## 6. `.gitignore` for Python Projects

```gitignore
# ---- Python ----
__pycache__/
*.py[cod]
*$py.class
*.so
*.egg
*.egg-info/
dist/
build/
eggs/

# ---- Virtual environments ----
venv/
.venv/
env/
.env/
myenv/

# ---- Environment variables ----
.env
.env.local
.env.production

# ---- IDE ----
.vscode/
.idea/
*.swp
*.swo
*~

# ---- Testing ----
.pytest_cache/
htmlcov/
.coverage
.coverage.*
coverage.xml
*.cover

# ---- Type checking ----
.mypy_cache/

# ---- Distribution ----
dist/
build/
*.egg-info/

# ---- Linting ----
.ruff_cache/

# ---- OS ----
.DS_Store           # macOS
Thumbs.db           # Windows

# ---- Database ----
*.sqlite3
*.db

# ---- Logs ----
*.log

# ---- Jupyter ----
.ipynb_checkpoints/
```

> ğŸ’¡ Use [gitignore.io](https://gitignore.io) to generate `.gitignore` for any stack. Search "Python" and it gives you a comprehensive one.

---

## 7. `Makefile` for Common Commands

A `Makefile` is a shortcut system â€” run complex commands with simple names.

```makefile
# Makefile â€” put this at project root
# Run with: make <target>

.PHONY: help install run test lint format clean migrate docker-up docker-down

# Default target
help:  ## Show this help
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | \
		awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-20s\033[0m %s\n", $$1, $$2}'

# ---- Setup ----
install:  ## Install dependencies
	pip install -e ".[dev]"
	pre-commit install

# ---- Development ----
run:  ## Run development server
	uvicorn my_backend.main:app --reload --port 8000

shell:  ## Open Python shell
	python -c "import IPython; IPython.start_ipython()" 2>/dev/null || python

# ---- Testing ----
test:  ## Run tests
	pytest -v --cov=my_backend --cov-report=term-missing

test-fast:  ## Run tests without coverage
	pytest -x -q

# ---- Code Quality ----
lint:  ## Run linter
	ruff check .
	mypy my_backend/

format:  ## Format code
	black .
	ruff check --fix .
	isort .

check:  ## Run all checks (lint + test)
	make lint
	make test

# ---- Database ----
migrate:  ## Run database migrations
	alembic upgrade head

migration:  ## Create new migration
	alembic revision --autogenerate -m "$(msg)"

# ---- Docker ----
docker-up:  ## Start Docker services
	docker-compose up -d

docker-down:  ## Stop Docker services
	docker-compose down

docker-build:  ## Build Docker image
	docker-compose build

# ---- Cleanup ----
clean:  ## Remove cache files
	find . -type d -name __pycache__ -exec rm -rf {} +
	find . -type f -name '*.pyc' -delete
	rm -rf .pytest_cache .mypy_cache .ruff_cache htmlcov .coverage
```

### Using Makefile
```bash
make install       # Install dependencies
make run           # Start server
make test          # Run tests
make lint          # Run linter
make format        # Format code
make check         # Lint + test
make clean         # Remove cache files
make docker-up     # Start Docker services
make help          # Show all available commands

# With variables
make migration msg="add user table"
```

> ğŸ’¡ **Makefile** makes onboarding easy â€” new devs just run `make install && make run`.

---

## 8. `pre-commit` Hooks

Automatically run checks **before every git commit** â€” catches errors early.

### Setup
```bash
# Install
pip install pre-commit
# OR
pipx install pre-commit

# Install hooks in your repo
pre-commit install    # Now runs on every `git commit`
```

### Configuration (`.pre-commit-config.yaml`)
```yaml
# .pre-commit-config.yaml â€” put at project root

repos:
  # ---- Code formatting ----
  - repo: https://github.com/psf/black
    rev: 23.12.0
    hooks:
      - id: black
        language_version: python3

  # ---- Import sorting ----
  - repo: https://github.com/pycqa/isort
    rev: 5.13.0
    hooks:
      - id: isort

  # ---- Linting (ruff â€” fast!) ----
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.1.8
    hooks:
      - id: ruff
        args: [--fix]

  # ---- Type checking ----
  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.7.1
    hooks:
      - id: mypy
        additional_dependencies: [types-requests]

  # ---- General checks ----
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace       # Remove trailing spaces
      - id: end-of-file-fixer         # Ensure newline at EOF
      - id: check-yaml                # Validate YAML
      - id: check-json                # Validate JSON
      - id: check-toml                # Validate TOML
      - id: check-added-large-files   # Prevent large files
        args: [--maxkb=500]
      - id: check-merge-conflict      # Catch merge conflict markers
      - id: debug-statements          # Catch leftover debugger imports
      - id: detect-private-key        # Prevent committing secrets

  # ---- Security ----
  - repo: https://github.com/PyCQA/bandit
    rev: 1.7.6
    hooks:
      - id: bandit
        args: [-c, pyproject.toml]
```

### Usage
```bash
# Runs automatically on git commit
git add .
git commit -m "feature: add user model"
# â†’ black runs â†’ isort runs â†’ ruff runs â†’ mypy runs â†’ commit (if all pass)

# Run manually on all files
pre-commit run --all-files

# Update hooks to latest versions
pre-commit autoupdate

# Skip hooks (emergency only!)
git commit --no-verify -m "hotfix: skip hooks"    # âŒ Avoid this!
```

### What Happens on Commit
```
$ git commit -m "add feature"

black....................................................Passed
isort....................................................Passed
ruff.....................................................Failed
  - main.py:15: F401 `os` imported but unused

# Commit BLOCKED! Fix the issue first.
# After fixing:
$ git add .
$ git commit -m "add feature"
# All hooks pass â†’ Commit succeeds âœ…
```

---

## 9. `uv` Package Manager (Modern, Fast Alternative to pip)

`uv` is a **blazing fast** Python package manager written in Rust. By Astral (same team as `ruff`).

### Install
```bash
# macOS / Linux
curl -LsSf https://astral.sh/uv/install.sh | sh

# Or with pipx
pipx install uv

# Or with Homebrew
brew install uv
```

### Basic Usage (pip Replacement)
```bash
# ---- Works as a drop-in pip replacement ----
uv pip install requests              # Install package
uv pip install -r requirements.txt   # From requirements
uv pip install -e ".[dev]"           # Editable install
uv pip uninstall requests            # Uninstall
uv pip list                          # List packages
uv pip freeze                        # Freeze versions
uv pip compile requirements.in -o requirements.txt  # Compile/lock

# Speed comparison:
# pip install django     â†’ ~10 seconds
# uv pip install django  â†’ ~0.5 seconds  (20x faster!)
```

### Project Management (Like Poetry)
```bash
# ---- Create new project ----
uv init my-backend
cd my-backend

# ---- Add dependencies ----
uv add fastapi
uv add uvicorn sqlalchemy pydantic
uv add pytest ruff --dev          # Dev dependencies

# ---- Remove ----
uv remove requests

# ---- Install all ----
uv sync                           # Install from pyproject.toml + uv.lock

# ---- Run commands ----
uv run python main.py
uv run pytest
uv run uvicorn app:main --reload

# ---- Virtual environment ----
uv venv                          # Create .venv
uv venv --python 3.11            # Specific Python version
```

### `uv` Generated `pyproject.toml`
```toml
[project]
name = "my-backend"
version = "0.1.0"
description = ""
readme = "README.md"
requires-python = ">=3.9"
dependencies = [
    "fastapi>=0.104.0",
    "uvicorn>=0.24.0",
]

[tool.uv]
dev-dependencies = [
    "pytest>=7.4",
    "ruff>=0.1",
]
```

### Why `uv`?

| Feature | pip | poetry | **uv** |
|---------|-----|--------|--------|
| Speed | Slow | Medium | **20-100x faster** âœ… |
| Lock file | No | Yes | Yes |
| Venv management | Manual | Built-in | Built-in |
| Python installer | No | No | **Yes** âœ… |
| Resolver | Basic | Good | **Best** âœ… |
| Written in | Python | Python | **Rust** |

```bash
# uv can even install Python itself!
uv python install 3.12
uv python list    # Show available versions
```

> ğŸ’¡ **2026 recommendation**: Use `uv` for new projects. It's the future of Python packaging.

---

## 10. Monorepo vs Multi-Repo Structure

### Monorepo (One Repo, Multiple Services)
```
company-backend/                    â† Single git repo
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ auth-service/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ tests/
â”‚   â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”‚   â””â”€â”€ pyproject.toml
â”‚   â”œâ”€â”€ payment-service/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ tests/
â”‚   â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”‚   â””â”€â”€ pyproject.toml
â”‚   â””â”€â”€ notification-service/
â”‚       â”œâ”€â”€ src/
â”‚       â”œâ”€â”€ tests/
â”‚       â”œâ”€â”€ Dockerfile
â”‚       â””â”€â”€ pyproject.toml
â”œâ”€â”€ shared/                         â† Shared code between services
â”‚   â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ utils/
â”‚   â””â”€â”€ pyproject.toml
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Makefile
â””â”€â”€ .github/workflows/
```

### Multi-Repo (Separate Repo per Service)
```
# Repo 1: github.com/company/auth-service
auth-service/
â”œâ”€â”€ src/
â”œâ”€â”€ tests/
â”œâ”€â”€ Dockerfile
â””â”€â”€ pyproject.toml

# Repo 2: github.com/company/payment-service
payment-service/
â”œâ”€â”€ src/
â”œâ”€â”€ tests/
â”œâ”€â”€ Dockerfile
â””â”€â”€ pyproject.toml

# Repo 3: github.com/company/notification-service
notification-service/
â”œâ”€â”€ src/
â”œâ”€â”€ tests/
â”œâ”€â”€ Dockerfile
â””â”€â”€ pyproject.toml
```

### Comparison

| Feature | Monorepo | Multi-Repo |
|---------|----------|------------|
| Code sharing | Easy (shared folder) âœ… | Hard (publish packages) |
| CI/CD | Complex (selective builds) | Simple per service âœ… |
| Code review | See all changes together âœ… | Separate PRs |
| Dependencies | Shared versions âœ… | Independent |
| Team autonomy | Lower | Higher âœ… |
| Repo size | Large | Small âœ… |
| Used by | Google, Meta, Uber | Netflix, Amazon |
| Good for | Small-medium teams âœ… | Large teams âœ… |

> ğŸ’¡ **Startup advice**: Start with a monorepo. Split into multi-repo only when team grows and services are truly independent.

---

## 11. Semantic Versioning (`MAJOR.MINOR.PATCH`)

### Format: `X.Y.Z`
```
MAJOR.MINOR.PATCH
  â”‚     â”‚     â”‚
  â”‚     â”‚     â””â”€â”€ Bug fixes (backward compatible)
  â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€ New features (backward compatible)
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Breaking changes (NOT backward compatible)
```

### Examples
```
1.0.0 â†’ 1.0.1    # PATCH: Bug fix (safe to upgrade)
1.0.1 â†’ 1.1.0    # MINOR: New feature added (safe to upgrade)
1.1.0 â†’ 2.0.0    # MAJOR: Breaking change (READ changelog first!)

0.x.y             # Pre-release: Anything can change
1.0.0-alpha       # Alpha release
1.0.0-beta.1      # Beta release
1.0.0-rc.1        # Release candidate
```

### In `pyproject.toml` / `requirements.txt`
```toml
# Exact version
fastapi == "0.104.1"

# Compatible (MINOR updates OK)
fastapi = "^0.104.0"     # Poetry: >=0.104.0, <0.105.0 (for 0.x)
fastapi = "~=0.104.0"    # pip: >=0.104.0, <0.105.0

# Range
fastapi = ">=0.100.0,<1.0.0"
```

### Version Specifiers Cheat Sheet
```
==1.0.0     Exact match
!=1.0.0     Not this version
>=1.0.0     This version or higher
<=1.0.0     This version or lower
~=1.4.0     >=1.4.0, <1.5.0  (compatible release â€” patch updates only)
^1.4.0      >=1.4.0, <2.0.0  (poetry â€” minor updates OK)
*           Any version (AVOID in production!)
```

### Versioning Your Own Project
```python
# my_backend/__init__.py
__version__ = "1.2.3"

# Or in pyproject.toml
[project]
version = "1.2.3"

# Dynamic versioning (from git tags)
[project]
dynamic = ["version"]
[tool.setuptools.dynamic]
version = {attr = "my_backend.__version__"}
```

### When to Bump

| Change | Version Bump | Example |
|--------|-------------|---------|
| Fix a bug | PATCH (0.0.X) | Fix login crash |
| Add new endpoint | MINOR (0.X.0) | Add `/users/search` |
| Change response format | MAJOR (X.0.0) | Rename `user_name` â†’ `username` |
| Add optional field | MINOR | Add `avatar_url` to response |
| Remove a field | MAJOR | Remove `legacy_id` from response |
| Internal refactor | PATCH | No API change |

> ğŸ’¡ **API rule**: If existing clients will break â†’ it's a MAJOR version change.

---

## ğŸ”— Quick Reference

```
# ---- Project Layout ----
my_project/
â”œâ”€â”€ src/my_project/     # Source code (src layout)
â”œâ”€â”€ tests/              # Tests
â”œâ”€â”€ pyproject.toml      # Config (MODERN)
â”œâ”€â”€ Makefile            # Shortcuts
â”œâ”€â”€ .pre-commit-config.yaml
â”œâ”€â”€ .gitignore
â”œâ”€â”€ .env.example
â”œâ”€â”€ Dockerfile
â””â”€â”€ README.md

# ---- Package Managers ----
pip install X               # Install package
pipx install X              # Install CLI tool (isolated)
poetry add X                # Add dependency (poetry)
uv add X                    # Add dependency (uv â€” fastest!)

# ---- Key Commands ----
make run                    # Run via Makefile
pre-commit run --all-files  # Run all hooks
uv sync                     # Install all deps (uv)
poetry install              # Install all deps (poetry)

# ---- Versioning ----
MAJOR.MINOR.PATCH           # X.Y.Z
^1.4.0 â†’ >=1.4.0, <2.0.0   # Poetry compatible
~=1.4.0 â†’ >=1.4.0, <1.5.0  # pip compatible
```

---

> ğŸ“ **Phase 6 Complete!** Next: Phase 7 â€” Advanced Python (Iterators, Generators, Concurrency, Memory, Metaprogramming)
