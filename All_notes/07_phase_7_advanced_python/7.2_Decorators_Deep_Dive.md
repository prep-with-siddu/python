# 7.2 Decorators (Deep Dive) ‚Äî Notes

> **Status**: ‚úÖ Completed  
> **Date**: 28 February 2026

---

## 1. Function Decorators

A decorator **wraps** a function to add behavior ‚Äî without changing the original function.

### How Decorators Work
```python
# A decorator is just a function that:
# 1. Takes a function as argument
# 2. Returns a new function (wrapper)
# 3. The wrapper adds behavior before/after the original

def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Before function call")
        result = func(*args, **kwargs)    # Call original function
        print("After function call")
        return result
    return wrapper

# ---- Using @ syntax (syntactic sugar) ----
@my_decorator
def say_hello(name):
    print(f"Hello, {name}!")

say_hello("Sid")
# Before function call
# Hello, Sid!
# After function call

# ---- @ syntax is just shorthand for: ----
# say_hello = my_decorator(say_hello)
```

### Decorator Template (Copy This!)
```python
import functools

def my_decorator(func):
    @functools.wraps(func)    # ‚Üê Preserves function metadata!
    def wrapper(*args, **kwargs):
        # --- Before ---
        result = func(*args, **kwargs)
        # --- After ---
        return result
    return wrapper
```

### Practical Example: Timing Decorator
```python
import functools
import time

def timer(func):
    """Measure execution time of a function."""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start = time.perf_counter()
        result = func(*args, **kwargs)
        end = time.perf_counter()
        print(f"{func.__name__} took {end - start:.4f} seconds")
        return result
    return wrapper

@timer
def slow_function():
    time.sleep(1)
    return "done"

slow_function()    # slow_function took 1.0012 seconds
```

---

## 2. Class Decorators

### Class AS a Decorator (Using `__call__`)
```python
class CountCalls:
    """Decorator that counts how many times a function is called."""
    
    def __init__(self, func):
        functools.update_wrapper(self, func)
        self.func = func
        self.count = 0
    
    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"{self.func.__name__} called {self.count} times")
        return self.func(*args, **kwargs)

@CountCalls
def greet(name):
    return f"Hello, {name}!"

greet("Sid")      # greet called 1 times
greet("Rahul")    # greet called 2 times
print(greet.count) # 2
```

### Decorator ON a Class
```python
def add_repr(cls):
    """Add a __repr__ method to any class."""
    def __repr__(self):
        attrs = ", ".join(f"{k}={v!r}" for k, v in self.__dict__.items())
        return f"{cls.__name__}({attrs})"
    cls.__repr__ = __repr__
    return cls

@add_repr
class User:
    def __init__(self, name, age):
        self.name = name
        self.age = age

print(User("Sid", 25))    # User(name='Sid', age=25)
```

### Singleton Decorator
```python
def singleton(cls):
    """Ensure only one instance of a class exists."""
    instances = {}
    
    @functools.wraps(cls)
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    
    return get_instance

@singleton
class Database:
    def __init__(self, url):
        self.url = url
        print(f"Connecting to {url}...")

db1 = Database("postgres://localhost/mydb")    # Connecting to postgres://...
db2 = Database("postgres://localhost/other")   # No print ‚Äî same instance!
print(db1 is db2)    # True
```

---

## 3. Decorators with Arguments

When you need to pass arguments to the decorator itself.

```python
import functools

# Three levels of nesting!
def repeat(times):                         # 1. Decorator factory (takes args)
    def decorator(func):                   # 2. Actual decorator (takes func)
        @functools.wraps(func)
        def wrapper(*args, **kwargs):      # 3. Wrapper (takes func's args)
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(times=3)
def say_hi(name):
    print(f"Hi, {name}!")

say_hi("Sid")
# Hi, Sid!
# Hi, Sid!
# Hi, Sid!

# What happens:
# repeat(times=3) ‚Üí returns decorator function
# @decorator ‚Üí decorates say_hi ‚Üí returns wrapper
# say_hi("Sid") ‚Üí calls wrapper("Sid")
```

### Practical: Rate Limiter with Arguments
```python
import functools
import time

def rate_limit(max_calls, period):
    """Limit function calls to max_calls per period seconds."""
    def decorator(func):
        calls = []
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            now = time.time()
            # Remove old calls outside the period
            calls[:] = [t for t in calls if now - t < period]
            
            if len(calls) >= max_calls:
                wait = period - (now - calls[0])
                raise Exception(f"Rate limit exceeded. Try again in {wait:.1f}s")
            
            calls.append(now)
            return func(*args, **kwargs)
        return wrapper
    return decorator

@rate_limit(max_calls=3, period=60)    # 3 calls per minute
def call_api(endpoint):
    print(f"Calling {endpoint}")
    return {"status": "ok"}
```

---

## 4. Decorator Factories

A decorator factory is a function that **creates decorators** based on parameters.

```python
import functools

def validate_types(**type_hints):
    """Decorator factory: validate argument types at runtime."""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # Check positional args
            import inspect
            sig = inspect.signature(func)
            params = list(sig.parameters.keys())
            
            for i, (param, arg) in enumerate(zip(params, args)):
                if param in type_hints and not isinstance(arg, type_hints[param]):
                    raise TypeError(
                        f"Argument '{param}' must be {type_hints[param].__name__}, "
                        f"got {type(arg).__name__}"
                    )
            
            # Check keyword args
            for key, value in kwargs.items():
                if key in type_hints and not isinstance(value, type_hints[key]):
                    raise TypeError(
                        f"Argument '{key}' must be {type_hints[key].__name__}, "
                        f"got {type(value).__name__}"
                    )
            
            return func(*args, **kwargs)
        return wrapper
    return decorator

@validate_types(name=str, age=int)
def create_user(name, age):
    return {"name": name, "age": age}

create_user("Sid", 25)        # ‚úÖ Works
create_user("Sid", "twenty")  # ‚ùå TypeError: Argument 'age' must be int, got str
```

### Flexible Decorator (Works With or Without Arguments)
```python
import functools

def smart_decorator(_func=None, *, prefix="LOG"):
    """Works as @smart_decorator or @smart_decorator(prefix='DEBUG')."""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            print(f"[{prefix}] Calling {func.__name__}")
            return func(*args, **kwargs)
        return wrapper
    
    if _func is not None:
        return decorator(_func)    # Called without arguments: @smart_decorator
    return decorator               # Called with arguments: @smart_decorator(prefix="X")

@smart_decorator          # No parentheses ‚Äî works!
def func_a():
    pass

@smart_decorator(prefix="DEBUG")    # With arguments ‚Äî also works!
def func_b():
    pass

func_a()    # [LOG] Calling func_a
func_b()    # [DEBUG] Calling func_b
```

---

## 5. `@wraps` Importance

### The Problem Without `@wraps`
```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        """Wrapper docstring."""
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def greet(name):
    """Greet a user by name."""
    return f"Hello, {name}"

# ‚ùå Function metadata is LOST!
print(greet.__name__)    # "wrapper" (not "greet"!)
print(greet.__doc__)     # "Wrapper docstring." (not "Greet a user...")
print(greet.__module__)  # Wrong module info
```

### The Fix: `@functools.wraps`
```python
import functools

def my_decorator(func):
    @functools.wraps(func)    # ‚Üê Copies metadata from func to wrapper
    def wrapper(*args, **kwargs):
        """Wrapper docstring."""
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def greet(name):
    """Greet a user by name."""
    return f"Hello, {name}"

# ‚úÖ Metadata preserved!
print(greet.__name__)      # "greet"
print(greet.__doc__)       # "Greet a user by name."
print(greet.__wrapped__)   # <function greet> (original function!)
```

### Why It Matters
```python
# 1. Debugging ‚Äî stack traces show correct function name
# 2. Documentation ‚Äî help(greet) shows correct docstring
# 3. Introspection ‚Äî tools like pytest, Sphinx, Flask routing depend on __name__
# 4. Access original ‚Äî greet.__wrapped__ gives the undecorated function

# ‚ö° RULE: ALWAYS use @functools.wraps in every decorator!
```

---

## 6. Real-World Decorator Patterns

### 1. Timing Decorator
```python
import functools, time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start = time.perf_counter()
        result = func(*args, **kwargs)
        elapsed = time.perf_counter() - start
        print(f"‚è± {func.__name__}: {elapsed:.4f}s")
        return result
    return wrapper
```

### 2. Logging Decorator
```python
import functools, logging

logger = logging.getLogger(__name__)

def log_calls(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        args_repr = [repr(a) for a in args]
        kwargs_repr = [f"{k}={v!r}" for k, v in kwargs.items()]
        signature = ", ".join(args_repr + kwargs_repr)
        logger.info(f"Calling {func.__name__}({signature})")
        try:
            result = func(*args, **kwargs)
            logger.info(f"{func.__name__} returned {result!r}")
            return result
        except Exception as e:
            logger.exception(f"{func.__name__} raised {e}")
            raise
    return wrapper
```

### 3. Authentication Decorator (Flask/Django Pattern)
```python
import functools

def login_required(func):
    """Check if user is authenticated."""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # In Flask: from flask import request, g
        # user = get_current_user(request)
        user = kwargs.get("current_user")
        if not user:
            raise PermissionError("Authentication required")
        return func(*args, **kwargs)
    return wrapper

def role_required(*roles):
    """Check if user has required role."""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            user = kwargs.get("current_user")
            if not user or user.role not in roles:
                raise PermissionError(f"Requires role: {roles}")
            return func(*args, **kwargs)
        return wrapper
    return decorator

@login_required
def get_profile(current_user=None):
    return {"user": current_user}

@role_required("admin", "moderator")
def delete_user(user_id, current_user=None):
    return {"deleted": user_id}
```

### 4. Retry Decorator
```python
import functools, time

def retry(max_retries=3, delay=1, backoff=2, exceptions=(Exception,)):
    """Retry function on failure with exponential backoff."""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            current_delay = delay
            for attempt in range(max_retries + 1):
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    if attempt == max_retries:
                        raise
                    print(f"Attempt {attempt + 1} failed: {e}. Retrying in {current_delay}s...")
                    time.sleep(current_delay)
                    current_delay *= backoff
        return wrapper
    return decorator

@retry(max_retries=3, delay=1, backoff=2, exceptions=(ConnectionError, TimeoutError))
def fetch_data(url):
    import requests
    response = requests.get(url, timeout=5)
    response.raise_for_status()
    return response.json()
```

### 5. Caching Decorator (`lru_cache`)
```python
from functools import lru_cache

@lru_cache(maxsize=128)    # Cache last 128 unique calls
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(100))          # Instant! (without cache ‚Üí takes forever)
print(fibonacci.cache_info())  # CacheInfo(hits=98, misses=101, maxsize=128, currsize=101)
fibonacci.cache_clear()        # Clear the cache

# ---- Custom cache with TTL ----
import functools, time

def cache_with_ttl(ttl_seconds=300):
    """Cache with Time-To-Live (expires after ttl)."""
    def decorator(func):
        cache = {}
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            key = (args, tuple(sorted(kwargs.items())))
            now = time.time()
            
            if key in cache:
                result, timestamp = cache[key]
                if now - timestamp < ttl_seconds:
                    return result    # Return cached
            
            result = func(*args, **kwargs)
            cache[key] = (result, now)
            return result
        
        wrapper.cache = cache
        wrapper.cache_clear = lambda: cache.clear()
        return wrapper
    return decorator

@cache_with_ttl(ttl_seconds=60)
def get_user(user_id):
    # Expensive DB query
    return db.query(f"SELECT * FROM users WHERE id = {user_id}")
```

### 6. Rate Limiting Decorator
```python
import functools, time
from collections import defaultdict

def rate_limit(calls=10, period=60):
    """Limit function to `calls` per `period` seconds."""
    def decorator(func):
        timestamps = defaultdict(list)
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            key = args[0] if args else "default"    # Rate limit per first arg (e.g., user_id)
            now = time.time()
            
            # Clean old timestamps
            timestamps[key] = [t for t in timestamps[key] if now - t < period]
            
            if len(timestamps[key]) >= calls:
                raise Exception(f"Rate limit: {calls} calls per {period}s exceeded")
            
            timestamps[key].append(now)
            return func(*args, **kwargs)
        return wrapper
    return decorator

@rate_limit(calls=5, period=60)
def api_endpoint(user_id, data):
    return {"status": "ok"}
```

### Stacking Multiple Decorators
```python
@timer
@log_calls
@login_required
def get_dashboard(current_user=None):
    return {"data": "dashboard"}

# Execution order (bottom ‚Üí top):
# 1. login_required checks auth
# 2. log_calls logs the call
# 3. timer measures total time (including logging!)

# Equivalent to:
# get_dashboard = timer(log_calls(login_required(get_dashboard)))
```

---

## üîó Quick Reference

```python
import functools

# ---- Basic decorator template ----
def decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # before
        result = func(*args, **kwargs)
        # after
        return result
    return wrapper

# ---- Decorator with arguments ----
def decorator(arg1, arg2):
    def actual_decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        return wrapper
    return actual_decorator

# ---- Built-in decorators ----
@staticmethod          # No self parameter
@classmethod           # First param is cls
@property              # Getter
@functools.wraps       # Preserve metadata
@functools.lru_cache   # Memoization
@functools.total_ordering  # Auto-generate comparison methods

# ---- Stacking (bottom decorator runs first) ----
@decorator_c    # Runs last (outermost)
@decorator_b    # Runs second
@decorator_a    # Runs first (innermost)
def my_func(): ...
```

---

> üìù **Next up**: 7.3 Concurrency & Parallelism ‚Äî GIL, threading, multiprocessing, asyncio
