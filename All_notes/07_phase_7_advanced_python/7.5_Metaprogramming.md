# 7.5 Metaprogramming ‚Äî Notes

> **Status**: ‚úÖ Completed  
> **Date**: 28 February 2026

---

## 1. Metaclasses (Deep Dive)

A metaclass is the **class of a class**. Just as a class creates objects, a metaclass creates classes.

```python
# Everything in Python is an object, even classes!
class User:
    pass

print(type(42))        # <class 'int'>
print(type("hello"))   # <class 'str'>
print(type(User))      # <class 'type'> ‚Üê User is an instance of 'type'!
print(type(type))      # <class 'type'> ‚Üê type is its own metaclass!

# Object hierarchy:
# type ‚Üí creates ‚Üí User (class) ‚Üí creates ‚Üí User() (instance)
# metaclass ‚Üí creates ‚Üí class ‚Üí creates ‚Üí object
```

### Creating a Metaclass
```python
class MyMeta(type):
    """A metaclass that prints when a class is created."""
    
    def __new__(mcs, name, bases, namespace):
        print(f"Creating class: {name}")
        print(f"  Bases: {bases}")
        print(f"  Attributes: {list(namespace.keys())}")
        
        # You can modify the class before it's created!
        cls = super().__new__(mcs, name, bases, namespace)
        return cls
    
    def __init__(cls, name, bases, namespace):
        print(f"Initializing class: {name}")
        super().__init__(name, bases, namespace)

class User(metaclass=MyMeta):
    name: str
    
    def greet(self):
        return f"Hello, {self.name}"

# Output:
# Creating class: User
#   Bases: ()
#   Attributes: ['__module__', '__qualname__', '__annotations__', 'name', 'greet']
# Initializing class: User
```

### Practical Metaclass: Auto-Register Classes
```python
class PluginMeta(type):
    """Auto-register all subclasses."""
    registry = {}
    
    def __new__(mcs, name, bases, namespace):
        cls = super().__new__(mcs, name, bases, namespace)
        if bases:    # Don't register the base class itself
            PluginMeta.registry[name] = cls
        return cls

class Plugin(metaclass=PluginMeta):
    """Base plugin class."""
    pass

class AuthPlugin(Plugin):
    def run(self): return "Auth running"

class LogPlugin(Plugin):
    def run(self): return "Log running"

print(PluginMeta.registry)
# {'AuthPlugin': <class 'AuthPlugin'>, 'LogPlugin': <class 'LogPlugin'>}

# Load plugin by name
plugin = PluginMeta.registry["AuthPlugin"]()
print(plugin.run())    # Auth running
```

### Practical Metaclass: Enforce Interface
```python
class InterfaceMeta(type):
    """Ensure subclasses implement required methods."""
    required_methods = []
    
    def __init__(cls, name, bases, namespace):
        super().__init__(name, bases, namespace)
        if bases:    # Skip base class
            for method in cls.required_methods:
                if method not in namespace:
                    raise TypeError(f"{name} must implement {method}()")

class Serializer(metaclass=InterfaceMeta):
    required_methods = ["serialize", "deserialize"]

# class BadSerializer(Serializer):    # ‚ùå TypeError!
#     def serialize(self): pass
#     # Missing deserialize!

class GoodSerializer(Serializer):     # ‚úÖ OK
    def serialize(self): pass
    def deserialize(self): pass
```

> üí° **In practice**: Most developers never need to write metaclasses. Use `ABC` for interfaces, `__init_subclass__` for class registration. Metaclasses are for framework authors.

---

## 2. `type()` as a Class Factory

`type()` can **create classes dynamically** at runtime!

```python
# ---- type() for checking types ----
print(type(42))       # <class 'int'>
print(type("hi"))     # <class 'str'>

# ---- type() for CREATING classes ----
# type(name, bases, namespace)

# This:
User = type("User", (), {
    "name": "default",
    "greet": lambda self: f"Hello, {self.name}",
})

# Is IDENTICAL to:
class User:
    name = "default"
    def greet(self):
        return f"Hello, {self.name}"

u = User()
u.name = "Sid"
print(u.greet())    # Hello, Sid

# ---- With inheritance ----
Admin = type("Admin", (User,), {
    "role": "admin",
    "is_admin": lambda self: True,
})

a = Admin()
a.name = "Sid"
print(a.greet())      # Hello, Sid (inherited)
print(a.is_admin())   # True
```

### Dynamic Model Creation (Django-like)
```python
def create_model(name, **fields):
    """Dynamically create a model class."""
    def __init__(self, **kwargs):
        for key, value in kwargs.items():
            setattr(self, key, value)
    
    def __repr__(self):
        attrs = ", ".join(f"{k}={v!r}" for k, v in self.__dict__.items())
        return f"{name}({attrs})"
    
    namespace = {
        "__init__": __init__,
        "__repr__": __repr__,
        "fields": fields,
    }
    
    return type(name, (), namespace)

# Create models on the fly!
User = create_model("User", name=str, age=int, email=str)
Product = create_model("Product", name=str, price=float)

u = User(name="Sid", age=25, email="sid@test.com")
print(u)    # User(name='Sid', age=25, email='sid@test.com')
```

---

## 3. `__new__` vs `__init__`

```python
class MyClass:
    def __new__(cls, *args, **kwargs):
        """Called FIRST ‚Äî creates the instance."""
        print(f"__new__: Creating instance of {cls.__name__}")
        instance = super().__new__(cls)    # Actually create the object
        return instance                     # MUST return the instance!
    
    def __init__(self, name):
        """Called SECOND ‚Äî initializes the instance."""
        print(f"__init__: Initializing with name={name}")
        self.name = name

obj = MyClass("Sid")
# __new__: Creating instance of MyClass
# __init__: Initializing with name=Sid
```

### Key Differences

| Feature | `__new__` | `__init__` |
|---------|-----------|-----------|
| Purpose | **Create** the instance | **Initialize** the instance |
| Called | First | Second |
| Receives | `cls` (the class) | `self` (the instance) |
| Returns | The new instance (required!) | `None` (always) |
| Use case | Singleton, immutables, caching | Set attributes |

### Singleton Using `__new__`
```python
class Singleton:
    _instance = None
    
    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self, value):
        self.value = value

a = Singleton(10)
b = Singleton(20)
print(a is b)        # True (same object!)
print(a.value)       # 20 (re-initialized)
```

### Immutable Type Customization
```python
class PositiveInt(int):
    """Integer that's always positive."""
    
    def __new__(cls, value):
        # Must use __new__ because int is immutable!
        # Can't change value in __init__
        return super().__new__(cls, abs(value))

n = PositiveInt(-42)
print(n)         # 42
print(type(n))   # <class 'PositiveInt'>
```

---

## 4. Descriptors (Deep Dive)

Descriptors control **attribute access** on classes. They power `@property`, `@classmethod`, `@staticmethod`.

### Descriptor Protocol
```python
class Descriptor:
    """A descriptor implements any of these methods."""
    
    def __get__(self, obj, objtype=None):
        """Called when attribute is accessed."""
        pass
    
    def __set__(self, obj, value):
        """Called when attribute is assigned."""
        pass
    
    def __delete__(self, obj):
        """Called when attribute is deleted."""
        pass
```

### Practical: Validated Attribute
```python
class Validated:
    """Descriptor that validates values."""
    
    def __init__(self, name, validator):
        self.name = name
        self.validator = validator
    
    def __set_name__(self, owner, name):
        self.name = name    # Auto-set name from class attribute
    
    def __get__(self, obj, objtype=None):
        if obj is None:
            return self    # Accessed on class, not instance
        return obj.__dict__.get(self.name)
    
    def __set__(self, obj, value):
        if not self.validator(value):
            raise ValueError(f"Invalid value for {self.name}: {value}")
        obj.__dict__[self.name] = value

# Validators
def positive(value): return isinstance(value, (int, float)) and value > 0
def non_empty_string(value): return isinstance(value, str) and len(value) > 0

class Product:
    name = Validated("name", non_empty_string)
    price = Validated("price", positive)
    quantity = Validated("quantity", positive)
    
    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price
        self.quantity = quantity

p = Product("Laptop", 75000, 10)    # ‚úÖ OK
# Product("", 100, 5)               # ‚ùå ValueError: Invalid value for name
# Product("Phone", -500, 5)         # ‚ùå ValueError: Invalid value for price
```

### How `@property` Is a Descriptor
```python
# @property is just a descriptor under the hood!

# This:
class User:
    @property
    def name(self):
        return self._name

# Is basically:
class User:
    def get_name(self):
        return self._name
    name = property(get_name)    # property() returns a descriptor object!
```

---

## 5. `inspect` Module

Introspect live objects ‚Äî great for debugging, documentation tools, and frameworks.

```python
import inspect

# ---- Inspect functions ----
def greet(name: str, greeting: str = "Hello") -> str:
    """Greet a person."""
    return f"{greeting}, {name}!"

print(inspect.signature(greet))           # (name: str, greeting: str = 'Hello') -> str
print(inspect.getsource(greet))           # Prints the source code!
print(inspect.getdoc(greet))              # Greet a person.
print(inspect.isfunction(greet))          # True
print(inspect.isclass(str))              # True

# ---- Get function parameters ----
sig = inspect.signature(greet)
for param_name, param in sig.parameters.items():
    print(f"  {param_name}: default={param.default}, kind={param.kind.name}")
# name: default=<class 'inspect._empty'>, kind=POSITIONAL_OR_KEYWORD
# greeting: default=Hello, kind=POSITIONAL_OR_KEYWORD

# ---- Inspect a class ----
class User:
    def __init__(self, name):
        self.name = name
    
    def greet(self):
        return f"Hi, {self.name}"
    
    @staticmethod
    def create(name):
        return User(name)

# Get all methods
members = inspect.getmembers(User, predicate=inspect.isfunction)
print(members)    # [('__init__', ...), ('create', ...), ('greet', ...)]

# Get source file
print(inspect.getfile(User))    # Path to the .py file

# ---- Get call stack ----
def inner():
    frame = inspect.currentframe()
    caller = inspect.getouterframes(frame)[1]
    print(f"Called from: {caller.function} at line {caller.lineno}")

def outer():
    inner()

outer()    # Called from: outer at line ...
```

---

## 6. Dynamic Attribute Access

### `__getattr__` ‚Äî Called When Attribute NOT Found
```python
class FlexibleConfig:
    """Return None for missing attributes instead of AttributeError."""
    
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)
    
    def __getattr__(self, name):
        # Called ONLY when normal lookup fails
        print(f"Attribute '{name}' not found, returning None")
        return None

config = FlexibleConfig(host="localhost", port=8000)
print(config.host)       # localhost (normal lookup)
print(config.debug)      # None (triggers __getattr__)
```

### `__setattr__` ‚Äî Called on EVERY Assignment
```python
class TrackedObject:
    """Log every attribute change."""
    
    def __init__(self, **kwargs):
        for key, value in kwargs.items():
            object.__setattr__(self, key, value)    # Bypass our __setattr__
    
    def __setattr__(self, name, value):
        print(f"Setting {name} = {value}")
        super().__setattr__(name, value)

obj = TrackedObject(x=1)
obj.y = 2       # Setting y = 2
obj.x = 10      # Setting x = 10
```

### `__getattribute__` ‚Äî Called on EVERY Access (Dangerous!)
```python
class LoggedAccess:
    """Log every attribute access."""
    
    def __init__(self, name):
        self.name = name
    
    def __getattribute__(self, name):
        print(f"Accessing: {name}")
        return super().__getattribute__(name)    # MUST call super!

obj = LoggedAccess("Sid")
print(obj.name)
# Accessing: name
# Sid
```

### Comparison

| Method | When Called | Use Case |
|--------|-----------|----------|
| `__getattr__` | Attribute NOT found | Fallback, defaults, proxy |
| `__setattr__` | Every `obj.x = val` | Validation, logging |
| `__getattribute__` | Every `obj.x` access | Logging, proxying (rare!) |
| `__delattr__` | Every `del obj.x` | Prevent deletion |

### Proxy Pattern
```python
class Proxy:
    """Forward all attribute access to another object."""
    
    def __init__(self, target):
        object.__setattr__(self, "_target", target)
    
    def __getattr__(self, name):
        return getattr(self._target, name)
    
    def __setattr__(self, name, value):
        setattr(self._target, name, value)

# Proxy to a dict
class DictProxy:
    """Access dict keys as attributes."""
    
    def __init__(self, data):
        object.__setattr__(self, "_data", data)
    
    def __getattr__(self, name):
        try:
            return self._data[name]
        except KeyError:
            raise AttributeError(f"No key '{name}'")
    
    def __setattr__(self, name, value):
        self._data[name] = value

config = DictProxy({"host": "localhost", "port": 8000})
print(config.host)    # localhost
config.debug = True   # Adds to dict
```

---

## 7. `exec()` and `eval()` (and Why to Avoid Them)

### `eval()` ‚Äî Evaluate an Expression
```python
# eval() evaluates a SINGLE expression and returns its value
result = eval("2 + 3 * 4")
print(result)    # 14

x = 10
result = eval("x * 2 + 5")
print(result)    # 25

# With custom namespace
result = eval("a + b", {"a": 10, "b": 20})
print(result)    # 30
```

### `exec()` ‚Äî Execute Statements
```python
# exec() executes arbitrary Python code (blocks, functions, etc.)
exec("x = 42")
exec("""
def greet(name):
    print(f'Hello, {name}!')
greet('Sid')
""")
# Hello, Sid!

# Create function dynamically
namespace = {}
exec("def add(a, b): return a + b", namespace)
print(namespace["add"](3, 4))    # 7
```

### WHY TO AVOID THEM ‚ö†Ô∏è
```python
# ---- SECURITY RISK ----
user_input = "__import__('os').system('rm -rf /')"
# eval(user_input)    # ‚ùå DELETES YOUR ENTIRE SYSTEM!!!

user_input = "__import__('subprocess').call(['cat', '/etc/passwd'])"
# eval(user_input)    # ‚ùå Reads password file!

# ---- Even with restrictions, it's bypassable ----
# eval(user_input, {"__builtins__": {}})  # Still bypassable!

# ---- ALTERNATIVES (use these instead!) ----

# Instead of eval() for math:
import ast
result = ast.literal_eval("{'key': [1, 2, 3]}")    # Safe! Only literals
# ast.literal_eval("__import__('os')")              # ‚ùå ValueError (blocked!)

# Instead of eval() for JSON:
import json
data = json.loads('{"key": "value"}')

# Instead of exec() for dynamic dispatch:
actions = {
    "add": lambda a, b: a + b,
    "mul": lambda a, b: a * b,
}
result = actions["add"](3, 4)    # 7 ‚Äî safe!
```

### When Are They Acceptable?
```python
# ‚úÖ Template engines (Jinja2, Mako ‚Äî they use exec safely)
# ‚úÖ REPL/debugging tools (you control the input)
# ‚úÖ Code generation tools (trusted source code)
# ‚ùå NEVER with user input
# ‚ùå NEVER in web applications
# ‚ùå NEVER in APIs
```

---

## üîó Quick Reference

```python
# ---- Metaclass ----
class MyMeta(type):
    def __new__(mcs, name, bases, namespace):
        return super().__new__(mcs, name, bases, namespace)

class MyClass(metaclass=MyMeta): pass

# ---- type() as factory ----
MyClass = type("MyClass", (BaseClass,), {"method": lambda self: ...})

# ---- __new__ vs __init__ ----
# __new__: creates instance (use for singletons, immutables)
# __init__: initializes instance (set attributes)

# ---- Descriptors ----
class Desc:
    def __get__(self, obj, objtype=None): ...
    def __set__(self, obj, value): ...
    def __set_name__(self, owner, name): ...

# ---- inspect ----
import inspect
inspect.signature(func)       # Function signature
inspect.getsource(obj)        # Source code
inspect.getmembers(cls)       # All members

# ---- Dynamic attributes ----
__getattr__         # Missing attribute fallback
__setattr__         # Every assignment
__getattribute__    # Every access (careful!)

# ---- AVOID ----
# eval(), exec() ‚Üí security risk! Use ast.literal_eval() or json.loads()
```

---

> üìù **Next up**: 7.6 Type Hints & Static Analysis ‚Äî typing, Pydantic, mypy, marshmallow
