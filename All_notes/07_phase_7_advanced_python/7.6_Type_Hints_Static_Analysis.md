# 7.6 Type Hints & Static Analysis ‚Äî Notes

> **Status**: ‚úÖ Completed  
> **Date**: 28 February 2026

---

## 1. Basic Type Hints (`int`, `str`, `list`, `dict`)

```python
# ---- Variable annotations ----
name: str = "Sid"
age: int = 25
price: float = 99.99
active: bool = True

# ---- Function annotations ----
def greet(name: str) -> str:
    return f"Hello, {name}!"

def add(a: int, b: int) -> int:
    return a + b

def process(data: list) -> dict:
    return {"count": len(data)}

# ---- Type hints are OPTIONAL ‚Äî Python ignores them at runtime! ----
# These run fine despite wrong types:
result: int = "not an int"    # No error at runtime!
# Type checkers (mypy) catch these at development time
```

### Python 3.9+ Built-in Generics
```python
# Python 3.9+: Use built-in types directly
names: list[str] = ["Sid", "Rahul"]
scores: dict[str, int] = {"Sid": 95, "Rahul": 88}
coords: tuple[float, float] = (12.97, 77.59)
unique_ids: set[int] = {1, 2, 3}

# Nested types
matrix: list[list[int]] = [[1, 2], [3, 4]]
config: dict[str, list[str]] = {"admins": ["Sid"], "users": ["Rahul"]}

# Before Python 3.9: needed typing module
from typing import List, Dict, Tuple, Set
names: List[str] = ["Sid"]    # Old style (still works)
```

---

## 2. `typing` Module

```python
from typing import (
    List, Dict, Tuple, Set,        # Generic collections (pre-3.9)
    Optional,                       # Can be None
    Union,                          # Multiple types
    Any,                            # Any type
    Callable,                       # Function type
    Iterator, Generator,            # Iterator types
    Sequence, Mapping, Iterable,    # Abstract types
)

# ---- Optional ‚Äî value or None ----
def find_user(user_id: int) -> Optional[dict]:
    """Returns user dict or None if not found."""
    if user_id == 1:
        return {"name": "Sid"}
    return None    # Equivalent to: Union[dict, None]

# Python 3.10+: use | instead of Optional/Union
def find_user(user_id: int) -> dict | None:
    ...

# ---- Union ‚Äî multiple possible types ----
def process(value: Union[str, int]) -> str:
    return str(value)

# Python 3.10+:
def process(value: str | int) -> str:
    return str(value)

# ---- Any ‚Äî accepts anything (escape hatch) ----
def log(message: Any) -> None:
    print(message)

# ---- Callable ‚Äî function types ----
def apply(func: Callable[[int, int], int], a: int, b: int) -> int:
    return func(a, b)
#                 ‚Üë arg types      ‚Üë return type

apply(lambda a, b: a + b, 3, 4)    # 7

# ---- Sequence ‚Äî anything indexable ----
def first_item(items: Sequence[str]) -> str:
    return items[0]    # Works with list, tuple, str

# ---- Mapping ‚Äî anything dict-like ----
def get_name(data: Mapping[str, Any]) -> str:
    return data["name"]
```

---

## 3. `TypeVar` and Generics

Create functions/classes that work with **any type** while keeping type safety.

```python
from typing import TypeVar, Generic

# ---- TypeVar ‚Äî generic type variable ----
T = TypeVar("T")

def first(items: list[T]) -> T:
    """Return first item ‚Äî type is preserved!"""
    return items[0]

result = first([1, 2, 3])      # mypy knows: result is int
result = first(["a", "b"])     # mypy knows: result is str

# ---- Bounded TypeVar ----
from typing import TypeVar

Number = TypeVar("Number", int, float)    # Only int or float

def double(x: Number) -> Number:
    return x * 2

double(5)      # ‚úÖ int
double(3.14)   # ‚úÖ float
# double("hi") # ‚ùå mypy error

# ---- Generic Classes ----
from typing import Generic, TypeVar

T = TypeVar("T")

class Stack(Generic[T]):
    def __init__(self) -> None:
        self._items: list[T] = []
    
    def push(self, item: T) -> None:
        self._items.append(item)
    
    def pop(self) -> T:
        return self._items.pop()
    
    def peek(self) -> T:
        return self._items[-1]

int_stack: Stack[int] = Stack()
int_stack.push(42)       # ‚úÖ
# int_stack.push("hi")   # ‚ùå mypy catches this!

str_stack: Stack[str] = Stack()
str_stack.push("hello")  # ‚úÖ
```

---

## 4. `Protocol` (Structural Subtyping)

Duck typing with type safety! Define what methods an object must have ‚Äî no inheritance needed.

```python
from typing import Protocol

class Drawable(Protocol):
    def draw(self) -> str: ...

class Circle:
    def draw(self) -> str:
        return "Drawing circle"

class Square:
    def draw(self) -> str:
        return "Drawing square"

class NotDrawable:
    pass

def render(shape: Drawable) -> None:
    print(shape.draw())

render(Circle())       # ‚úÖ Has draw() method
render(Square())       # ‚úÖ Has draw() method
# render(NotDrawable())  # ‚ùå mypy error: doesn't have draw()

# No inheritance needed! Just implement the methods.
```

### Backend Example: Repository Protocol
```python
from typing import Protocol, TypeVar, Optional

T = TypeVar("T")

class Repository(Protocol[T]):
    """Any class with these methods can be used as a Repository."""
    
    def get(self, id: int) -> Optional[T]: ...
    def create(self, item: T) -> T: ...
    def delete(self, id: int) -> bool: ...

class PostgresUserRepo:
    def get(self, id: int) -> Optional[dict]:
        return {"id": id, "name": "Sid"}
    
    def create(self, item: dict) -> dict:
        return {**item, "id": 1}
    
    def delete(self, id: int) -> bool:
        return True

class MockUserRepo:
    def get(self, id: int) -> Optional[dict]:
        return {"id": id, "name": "Mock User"}
    
    def create(self, item: dict) -> dict:
        return item
    
    def delete(self, id: int) -> bool:
        return True

def get_users(repo: Repository[dict]) -> list[dict]:
    """Works with ANY repo that matches the Protocol!"""
    user = repo.get(1)
    return [user] if user else []

# Both work ‚Äî no inheritance required!
get_users(PostgresUserRepo())
get_users(MockUserRepo())
```

---

## 5. `Literal`, `TypedDict`, `Final`

```python
from typing import Literal, TypedDict, Final

# ---- Literal ‚Äî restrict to specific values ----
def set_status(status: Literal["active", "inactive", "banned"]) -> None:
    print(f"Status: {status}")

set_status("active")      # ‚úÖ
# set_status("unknown")   # ‚ùå mypy error

def set_mode(mode: Literal["read", "write", "append"]) -> None:
    ...

# ---- TypedDict ‚Äî typed dictionary ----
class UserDict(TypedDict):
    name: str
    age: int
    email: str

# Optional fields
class UserDict(TypedDict, total=False):    # All fields optional
    name: str
    age: int

# Required + Optional mix (Python 3.11+)
class UserDict(TypedDict):
    name: str              # Required
    age: int               # Required
    email: str             # Required
    # NotRequired fields need: from typing import NotRequired

user: UserDict = {"name": "Sid", "age": 25, "email": "sid@test.com"}    # ‚úÖ
# user: UserDict = {"name": "Sid"}    # ‚ùå Missing fields

# ---- Final ‚Äî constant, cannot be reassigned ----
MAX_RETRIES: Final = 3
API_URL: Final[str] = "https://api.example.com"

# MAX_RETRIES = 5    # ‚ùå mypy error: cannot assign to final variable

class Config:
    MAX_SIZE: Final = 1024
    
    # def update(self):
    #     self.MAX_SIZE = 2048    # ‚ùå mypy error
```

---

## 6. `Annotated` Type

Add metadata to types ‚Äî used heavily by Pydantic, FastAPI, and other frameworks.

```python
from typing import Annotated

# ---- Basic usage ----
UserId = Annotated[int, "Must be positive"]
Username = Annotated[str, "3-50 characters"]

def get_user(user_id: UserId, name: Username) -> dict:
    return {"id": user_id, "name": name}

# ---- With Pydantic (FastAPI uses this!) ----
from pydantic import Field
from typing import Annotated

PositiveInt = Annotated[int, Field(gt=0)]
Email = Annotated[str, Field(pattern=r"^[\w.]+@[\w.]+$")]

# ---- With FastAPI ----
# from fastapi import Query
# Annotated[int, Query(ge=1, le=100)]
# ‚Üí Query parameter, must be between 1 and 100
```

---

## 7. `mypy` for Static Type Checking

```bash
# Install
pip install mypy

# Run
mypy my_file.py
mypy src/            # Check entire directory
mypy --strict src/   # Strict mode (maximum checks)
```

### Example
```python
# app.py
def greet(name: str) -> str:
    return f"Hello, {name}"

result: int = greet("Sid")    # ‚ùå mypy: Incompatible types
                               # assigned "str" to "int"

def add(a: int, b: int) -> int:
    return a + b

add(1, "2")    # ‚ùå mypy: Argument 2 has incompatible type "str"
```

```bash
$ mypy app.py
app.py:4: error: Incompatible types in assignment (expression has type "str", variable has type "int")
app.py:9: error: Argument 2 to "add" has incompatible type "str"; expected "int"
Found 2 errors in 1 file
```

### `pyproject.toml` Config
```toml
[tool.mypy]
python_version = "3.11"
strict = true
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true

# Per-module overrides
[[tool.mypy.overrides]]
module = "tests.*"
disallow_untyped_defs = false

[[tool.mypy.overrides]]
module = "third_party_lib.*"
ignore_missing_imports = true
```

### Common mypy Commands
```bash
mypy .                          # Check everything
mypy --ignore-missing-imports . # Ignore untyped libraries
mypy --show-error-codes .       # Show error codes
mypy --html-report report/ .    # Generate HTML report
```

---

## 8. Pydantic for Runtime Validation (CRUCIAL for Backend)

Pydantic validates data **at runtime** using type hints. THE library for FastAPI.

```python
# pip install pydantic
from pydantic import BaseModel, EmailStr, Field, field_validator
from typing import Optional
from datetime import datetime

# ---- Basic Model ----
class User(BaseModel):
    name: str
    age: int
    email: str
    active: bool = True              # Default value
    created_at: datetime = Field(default_factory=datetime.now)

# Pydantic validates AND converts types!
user = User(name="Sid", age="25", email="sid@test.com")
print(user.age)           # 25 (int! ‚Äî auto-converted from "25")
print(type(user.age))     # <class 'int'>
print(user.active)        # True (default)
print(user.model_dump())  # {'name': 'Sid', 'age': 25, 'email': 'sid@test.com', ...}

# ‚ùå Invalid data raises ValidationError
# User(name="Sid", age="not_a_number", email="sid@test.com")
# pydantic.ValidationError: 1 validation error for User
#   age: Input should be a valid integer

# ---- JSON round-trip ----
json_str = user.model_dump_json()     # ‚Üí JSON string
user2 = User.model_validate_json(json_str)   # ‚Üí User object
```

### Field Validation
```python
from pydantic import BaseModel, Field

class Product(BaseModel):
    name: str = Field(min_length=1, max_length=100)
    price: float = Field(gt=0, description="Price in INR")
    quantity: int = Field(ge=0, le=10000)
    category: str = Field(default="General", pattern=r"^[A-Za-z]+$")
    tags: list[str] = Field(default_factory=list, max_length=10)

p = Product(name="Laptop", price=75000, quantity=50)
# Product(name="", price=-100, quantity=-1)    # ‚ùå All fail validation!
```

### Custom Validators
```python
from pydantic import BaseModel, field_validator, model_validator

class User(BaseModel):
    name: str
    age: int
    password: str
    confirm_password: str
    
    @field_validator("name")
    @classmethod
    def name_must_not_be_empty(cls, v):
        if not v.strip():
            raise ValueError("Name cannot be empty")
        return v.strip().title()    # Transform the value
    
    @field_validator("age")
    @classmethod
    def age_must_be_valid(cls, v):
        if v < 18 or v > 120:
            raise ValueError("Age must be between 18 and 120")
        return v
    
    @model_validator(mode="after")
    def passwords_match(self):
        if self.password != self.confirm_password:
            raise ValueError("Passwords do not match")
        return self

user = User(name="  sid  ", age=25, password="abc123", confirm_password="abc123")
print(user.name)    # "Sid" (stripped and title-cased by validator!)
```

---

## 9. Pydantic v2 ‚Äî Validators, Model Config, Computed Fields

### Model Config
```python
from pydantic import BaseModel, ConfigDict

class User(BaseModel):
    model_config = ConfigDict(
        str_strip_whitespace=True,     # Auto-strip strings
        str_min_length=1,              # No empty strings
        frozen=True,                   # Immutable (like dataclass frozen)
        extra="forbid",                # Don't allow extra fields
        from_attributes=True,          # Allow from ORM objects
        json_schema_extra={            # Custom JSON schema
            "examples": [{"name": "Sid", "age": 25}]
        },
    )
    
    name: str
    age: int

# user.name = "New"    # ‚ùå frozen=True makes it immutable!
# User(name="Sid", age=25, extra_field="x")  # ‚ùå extra="forbid"
```

### Computed Fields
```python
from pydantic import BaseModel, computed_field

class Rectangle(BaseModel):
    width: float
    height: float
    
    @computed_field
    @property
    def area(self) -> float:
        return self.width * self.height
    
    @computed_field
    @property
    def perimeter(self) -> float:
        return 2 * (self.width + self.height)

r = Rectangle(width=5, height=3)
print(r.area)          # 15.0
print(r.perimeter)     # 16.0
print(r.model_dump())  # {'width': 5.0, 'height': 3.0, 'area': 15.0, 'perimeter': 16.0}
```

### Nested Models (API Pattern)
```python
from pydantic import BaseModel
from datetime import datetime

class Address(BaseModel):
    street: str
    city: str
    state: str
    pin_code: str

class UserResponse(BaseModel):
    id: int
    name: str
    email: str
    address: Address                    # Nested model
    orders: list["OrderSummary"] = []   # List of nested models

class OrderSummary(BaseModel):
    order_id: int
    total: float
    status: str

# API response validation
data = {
    "id": 1,
    "name": "Sid",
    "email": "sid@test.com",
    "address": {
        "street": "MG Road",
        "city": "Bangalore",
        "state": "Karnataka",
        "pin_code": "560001"
    },
    "orders": [
        {"order_id": 101, "total": 1500.0, "status": "delivered"}
    ]
}

user = UserResponse(**data)    # Validated!
print(user.address.city)       # Bangalore
```

---

## 10. `marshmallow` for Serialization/Validation (Flask Ecosystem)

```python
# pip install marshmallow
from marshmallow import Schema, fields, validate, post_load

class UserSchema(Schema):
    name = fields.Str(required=True, validate=validate.Length(min=1, max=100))
    age = fields.Int(required=True, validate=validate.Range(min=18))
    email = fields.Email(required=True)
    role = fields.Str(validate=validate.OneOf(["admin", "user", "moderator"]))
    
    @post_load
    def make_user(self, data, **kwargs):
        """Convert validated data to User object."""
        return User(**data)

class User:
    def __init__(self, name, age, email, role="user"):
        self.name = name
        self.age = age
        self.email = email
        self.role = role

schema = UserSchema()

# ---- Deserialize (load) ‚Äî validate input ----
result = schema.load({"name": "Sid", "age": 25, "email": "sid@test.com"})
print(result)    # User object (thanks to @post_load)

# ---- Serialize (dump) ‚Äî convert to dict/JSON ----
user = User("Sid", 25, "sid@example.com")
output = schema.dump(user)
print(output)    # {'name': 'Sid', 'age': 25, 'email': 'sid@example.com', 'role': 'user'}

# ---- Validation errors ----
try:
    schema.load({"name": "", "age": 15, "email": "invalid"})
except Exception as e:
    print(e.messages)
# {'name': ['Length must be between 1 and 100.'],
#  'age': ['Must be at least 18.'],
#  'email': ['Not a valid email address.']}
```

### Pydantic vs Marshmallow

| Feature | Pydantic | Marshmallow |
|---------|---------|-------------|
| Validation | Type hints based | Schema class based |
| Speed | **Much faster** (Rust core) ‚úÖ | Slower |
| FastAPI | Native integration ‚úÖ | No |
| Flask | Works | Native ecosystem ‚úÖ |
| JSON Schema | Auto-generated ‚úÖ | Plugin needed |
| Recommendation | New projects ‚úÖ | Flask legacy projects |

---

## 11. `cattrs` for Structuring/Unstructuring

```python
# pip install cattrs
import cattrs
from attrs import define

@define
class User:
    name: str
    age: int

# ---- Structure (dict ‚Üí object) ----
user = cattrs.structure({"name": "Sid", "age": 25}, User)
print(user)    # User(name='Sid', age=25)

# ---- Unstructure (object ‚Üí dict) ----
data = cattrs.unstructure(user)
print(data)    # {'name': 'Sid', 'age': 25}

# ---- With nested types ----
@define
class Address:
    city: str

@define
class UserWithAddr:
    name: str
    address: Address

data = {"name": "Sid", "address": {"city": "Bangalore"}}
user = cattrs.structure(data, UserWithAddr)
print(user.address.city)    # Bangalore
```

> üí° `cattrs` is lightweight and fast. Use it when you need simple struct/unstruct without full Pydantic validation.

---

## üîó Quick Reference

```python
# ---- Basic hints (Python 3.10+) ----
x: int = 5
names: list[str] = ["a", "b"]
data: dict[str, int] = {"a": 1}
result: str | None = None          # Optional

# ---- typing module ----
from typing import Optional, Union, Any, Callable, Literal, Final
from typing import TypeVar, Generic, Protocol, TypedDict, Annotated

# ---- TypeVar ----
T = TypeVar("T")
def first(items: list[T]) -> T: ...

# ---- Protocol (duck typing) ----
class Printable(Protocol):
    def __str__(self) -> str: ...

# ---- Pydantic (runtime validation) ----
from pydantic import BaseModel, Field, field_validator
class User(BaseModel):
    name: str = Field(min_length=1)
    age: int = Field(ge=18)

# ---- mypy ----
# mypy . --strict

# ---- Marshmallow ----
from marshmallow import Schema, fields
class UserSchema(Schema):
    name = fields.Str(required=True)
```

---

> üìù **Next up**: 7.7 Networking & HTTP from Python ‚Äî requests, httpx, aiohttp, tenacity
