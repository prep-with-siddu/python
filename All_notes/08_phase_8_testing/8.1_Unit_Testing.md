# 8.1 Unit Testing ‚Äî Notes

> **Status**: ‚úÖ Completed  
> **Date**: 28 February 2026

---

## 1. `unittest` Module Basics

Python's built-in testing framework (xUnit style).

```python
import unittest

class TestMathOperations(unittest.TestCase):
    
    # ---- Setup & Teardown ----
    def setUp(self):
        """Runs BEFORE each test method."""
        self.calculator = Calculator()
    
    def tearDown(self):
        """Runs AFTER each test method."""
        pass
    
    @classmethod
    def setUpClass(cls):
        """Runs ONCE before all tests in the class."""
        cls.db = connect_db()
    
    @classmethod
    def tearDownClass(cls):
        """Runs ONCE after all tests in the class."""
        cls.db.close()
    
    # ---- Test Methods (must start with 'test_') ----
    def test_add(self):
        self.assertEqual(self.calculator.add(2, 3), 5)
    
    def test_subtract(self):
        self.assertEqual(self.calculator.subtract(10, 4), 6)
    
    def test_divide(self):
        self.assertEqual(self.calculator.divide(10, 2), 5.0)
    
    def test_divide_by_zero(self):
        with self.assertRaises(ZeroDivisionError):
            self.calculator.divide(10, 0)

# Run
if __name__ == "__main__":
    unittest.main()
```

### Common Assertions
```python
# Equality
self.assertEqual(a, b)          # a == b
self.assertNotEqual(a, b)       # a != b

# Truth
self.assertTrue(x)              # bool(x) is True
self.assertFalse(x)             # bool(x) is False

# Identity / None
self.assertIs(a, b)             # a is b
self.assertIsNone(x)            # x is None
self.assertIsNotNone(x)         # x is not None

# Membership
self.assertIn(a, b)             # a in b
self.assertNotIn(a, b)          # a not in b

# Type
self.assertIsInstance(a, int)   # isinstance(a, int)

# Numeric
self.assertAlmostEqual(a, b, places=5)    # round(a-b, 5) == 0
self.assertGreater(a, b)                   # a > b
self.assertLess(a, b)                      # a < b

# Exceptions
with self.assertRaises(ValueError):
    int("not_a_number")

with self.assertRaises(ValueError) as ctx:
    raise ValueError("bad input")
self.assertIn("bad", str(ctx.exception))

# Regex
self.assertRegex("hello123", r"\d+")

# Collections
self.assertCountEqual([1, 2, 3], [3, 2, 1])    # Same elements, any order
self.assertDictEqual(dict_a, dict_b)
self.assertListEqual(list_a, list_b)
```

```bash
# Run unittest
python -m unittest test_module.py
python -m unittest test_module.TestClass.test_method    # Single test
python -m unittest discover -s tests -p "test_*.py"     # Auto-discover
```

> üí° `unittest` works but is verbose. **Use `pytest` for new projects** ‚Äî it's simpler and more powerful.

---

## 2. `pytest` ‚Äî Setup, Writing Tests, Assertions

The gold standard for Python testing. Simple, powerful, extensible.

```bash
# Install
pip install pytest

# Run
pytest                          # Auto-discovers test_*.py / *_test.py
pytest tests/                   # Run tests in directory
pytest tests/test_users.py      # Run one file
pytest -v                       # Verbose output
pytest -x                       # Stop on first failure
pytest -s                       # Show print() output
pytest --tb=short               # Shorter tracebacks
pytest -k "test_login"          # Run tests matching name pattern
```

### Writing Tests
```python
# test_calculator.py
# No class needed! Just functions starting with test_

def test_add():
    assert 2 + 3 == 5

def test_subtract():
    assert 10 - 4 == 6

def test_string_upper():
    assert "hello".upper() == "HELLO"

def test_list_append():
    items = [1, 2]
    items.append(3)
    assert items == [1, 2, 3]
    assert len(items) == 3

# ---- Testing Exceptions ----
import pytest

def divide(a, b):
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b

def test_divide_by_zero():
    with pytest.raises(ValueError, match="Cannot divide by zero"):
        divide(10, 0)

def test_divide():
    assert divide(10, 2) == 5.0

# ---- Approximate comparisons ----
def test_float_math():
    assert 0.1 + 0.2 == pytest.approx(0.3)
    assert abs(0.1 + 0.2 - 0.3) < 1e-9    # Manual way
```

### Class-Based Tests (optional)
```python
class TestUser:
    def test_create_user(self):
        user = User("Sid", 25)
        assert user.name == "Sid"
        assert user.age == 25
    
    def test_user_greeting(self):
        user = User("Sid", 25)
        assert user.greet() == "Hello, I'm Sid!"
```

### pytest vs unittest

| Feature | pytest | unittest |
|---------|--------|----------|
| Syntax | Plain `assert` ‚úÖ | `self.assertEqual()` |
| Boilerplate | Minimal ‚úÖ | Class required |
| Fixtures | Powerful, composable ‚úÖ | setUp/tearDown only |
| Plugins | 1000+ plugins ‚úÖ | Limited |
| Parametrize | Built-in ‚úÖ | Needs third-party |
| Auto-discovery | ‚úÖ | Basic |
| Recommendation | **New projects ‚úÖ** | Legacy/stdlib only |

---

## 3. `pytest` Fixtures

Fixtures = reusable setup/teardown logic. The **killer feature** of pytest.

```python
import pytest

# ---- Basic Fixture ----
@pytest.fixture
def user():
    """Create a test user."""
    return {"name": "Sid", "age": 25, "email": "sid@test.com"}

def test_user_name(user):        # pytest auto-injects 'user' fixture!
    assert user["name"] == "Sid"

def test_user_email(user):
    assert "@" in user["email"]

# ---- Fixture with Setup & Teardown ----
@pytest.fixture
def db_connection():
    """Provide a database connection, clean up after."""
    conn = create_connection("test.db")
    yield conn              # ‚Üê Test runs here (between setup and teardown)
    conn.rollback()         # Teardown: undo changes
    conn.close()            # Teardown: close connection

def test_insert_user(db_connection):
    db_connection.execute("INSERT INTO users VALUES ('Sid', 25)")
    result = db_connection.execute("SELECT * FROM users").fetchall()
    assert len(result) == 1

# ---- Fixture Scopes ----
@pytest.fixture(scope="function")    # Default ‚Äî runs per test
def per_test(): ...

@pytest.fixture(scope="class")       # Once per test class
def per_class(): ...

@pytest.fixture(scope="module")      # Once per file
def per_module(): ...

@pytest.fixture(scope="session")     # Once per entire test run
def per_session(): ...

# Example: expensive DB setup only once
@pytest.fixture(scope="session")
def db_engine():
    engine = create_engine("sqlite:///test.db")
    Base.metadata.create_all(engine)
    yield engine
    Base.metadata.drop_all(engine)

@pytest.fixture(scope="function")
def db_session(db_engine):
    session = Session(db_engine)
    yield session
    session.rollback()
    session.close()
```

### Fixture Composition (fixtures using other fixtures)
```python
@pytest.fixture
def app():
    """Create test Flask/FastAPI app."""
    app = create_app(testing=True)
    return app

@pytest.fixture
def client(app):
    """Create test client using app fixture."""
    return app.test_client()

@pytest.fixture
def auth_headers(client):
    """Get auth headers using client fixture."""
    response = client.post("/login", json={"user": "sid", "pass": "123"})
    token = response.json()["token"]
    return {"Authorization": f"Bearer {token}"}

def test_protected_route(client, auth_headers):
    response = client.get("/profile", headers=auth_headers)
    assert response.status_code == 200
```

### `autouse` Fixture
```python
@pytest.fixture(autouse=True)
def reset_database(db_session):
    """Automatically runs before EVERY test ‚Äî no need to pass it."""
    yield
    db_session.rollback()
```

---

## 4. `pytest` Parametrize

Run the same test with multiple inputs ‚Äî DRY testing!

```python
import pytest

# ---- Basic Parametrize ----
@pytest.mark.parametrize("input,expected", [
    (1, 1),
    (2, 4),
    (3, 9),
    (4, 16),
    (-2, 4),
])
def test_square(input, expected):
    assert input ** 2 == expected

# ---- Multiple parameters ----
@pytest.mark.parametrize("a,b,expected", [
    (1, 2, 3),
    (0, 0, 0),
    (-1, 1, 0),
    (100, 200, 300),
])
def test_add(a, b, expected):
    assert a + b == expected

# ---- With IDs (for readable output) ----
@pytest.mark.parametrize("email,is_valid", [
    ("sid@test.com", True),
    ("invalid", False),
    ("", False),
    ("a@b.c", True),
], ids=["valid_email", "no_at_sign", "empty", "minimal_valid"])
def test_email_validation(email, is_valid):
    assert validate_email(email) == is_valid

# Output:
# test_email.py::test_email_validation[valid_email] PASSED
# test_email.py::test_email_validation[no_at_sign] PASSED

# ---- Stack multiple parametrize (cartesian product) ----
@pytest.mark.parametrize("method", ["GET", "POST", "PUT"])
@pytest.mark.parametrize("status", [200, 400, 500])
def test_response_handling(method, status):
    # Runs 3 √ó 3 = 9 test combinations!
    response = handle_response(method, status)
    assert response is not None

# ---- Parametrize with pytest.raises ----
@pytest.mark.parametrize("value,error", [
    ("abc", ValueError),
    (None, TypeError),
    ([], TypeError),
])
def test_parse_int_errors(value, error):
    with pytest.raises(error):
        parse_int(value)
```

---

## 5. `pytest` Markers

Tag tests for selective running, skipping, or special behavior.

```python
import pytest
import sys

# ---- Built-in Markers ----

# Skip unconditionally
@pytest.mark.skip(reason="Feature not implemented yet")
def test_future_feature():
    pass

# Skip conditionally
@pytest.mark.skipif(sys.platform != "linux", reason="Linux only")
def test_linux_specific():
    pass

# Expected failure (test is known to fail)
@pytest.mark.xfail(reason="Bug #123 not fixed yet")
def test_known_bug():
    assert buggy_function() == "correct"

# ---- Custom Markers ----

@pytest.mark.slow
def test_heavy_computation():
    """Takes minutes to run."""
    result = train_model()
    assert result.accuracy > 0.9

@pytest.mark.integration
def test_database_connection():
    assert db.is_connected()

@pytest.mark.api
def test_user_endpoint():
    response = client.get("/users")
    assert response.status_code == 200
```

### Register Custom Markers
```ini
# pytest.ini or pyproject.toml

# pytest.ini
[pytest]
markers =
    slow: marks tests as slow (deselect with '-m "not slow"')
    integration: marks integration tests
    api: marks API tests
    unit: marks unit tests

# pyproject.toml
[tool.pytest.ini_options]
markers = [
    "slow: marks tests as slow",
    "integration: marks integration tests",
    "api: marks API tests",
]
```

### Running with Markers
```bash
pytest -m slow                  # Only slow tests
pytest -m "not slow"            # Everything EXCEPT slow
pytest -m "api and not slow"    # API tests that aren't slow
pytest -m "unit or integration" # Unit OR integration
```

---

## 6. `pytest` conftest.py

Shared fixtures and hooks ‚Äî pytest auto-discovers `conftest.py` files.

```
tests/
‚îú‚îÄ‚îÄ conftest.py              # Shared across ALL tests
‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py          # Shared within unit/ only
‚îÇ   ‚îú‚îÄ‚îÄ test_models.py
‚îÇ   ‚îî‚îÄ‚îÄ test_services.py
‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py          # Shared within integration/ only
‚îÇ   ‚îú‚îÄ‚îÄ test_api.py
‚îÇ   ‚îî‚îÄ‚îÄ test_database.py
‚îî‚îÄ‚îÄ e2e/
    ‚îú‚îÄ‚îÄ conftest.py
    ‚îî‚îÄ‚îÄ test_workflows.py
```

### Root conftest.py
```python
# tests/conftest.py
import pytest
from app import create_app
from app.database import db as _db

# ---- App Fixture (session-scoped) ----
@pytest.fixture(scope="session")
def app():
    """Create application for the tests."""
    app = create_app(config="testing")
    return app

# ---- Test Client ----
@pytest.fixture(scope="function")
def client(app):
    """Create a test client for the app."""
    return app.test_client()

# ---- Database Session (with rollback) ----
@pytest.fixture(scope="function")
def db(app):
    """Create a fresh database for each test."""
    _db.create_all()
    yield _db
    _db.session.rollback()
    _db.drop_all()

# ---- Auth Token ----
@pytest.fixture
def auth_token(client):
    response = client.post("/auth/login", json={
        "email": "test@test.com",
        "password": "password123"
    })
    return response.json()["access_token"]

@pytest.fixture
def auth_headers(auth_token):
    return {"Authorization": f"Bearer {auth_token}"}

# ---- Sample Data ----
@pytest.fixture
def sample_user():
    return {
        "name": "Sid",
        "email": "sid@test.com",
        "age": 25,
    }
```

### conftest.py Best Practices
```python
# ‚úÖ DO: Keep fixtures focused and composable
@pytest.fixture
def user_data():
    return {"name": "Sid", "age": 25}

@pytest.fixture
def created_user(client, user_data):
    response = client.post("/users", json=user_data)
    return response.json()

# ‚úÖ DO: Use yield for cleanup
@pytest.fixture
def temp_file():
    path = "/tmp/test_file.txt"
    with open(path, "w") as f:
        f.write("test data")
    yield path
    os.remove(path)    # Cleanup after test

# ‚ùå DON'T: Giant fixtures that do everything
# ‚ùå DON'T: Logic in conftest ‚Äî keep it simple
# ‚ùå DON'T: Import conftest ‚Äî pytest handles it automatically
```

---

## 7. Mocking (`unittest.mock`)

Replace real objects with fake ones during testing. Essential for isolating units.

```python
from unittest.mock import Mock, MagicMock, patch, AsyncMock

# ---- Mock Basics ----
mock = Mock()

# Mock accepts any method call
mock.some_method()
mock.any_attribute.nested.call(1, 2, 3)

# Configure return values
mock.get_name.return_value = "Sid"
assert mock.get_name() == "Sid"

# Configure side effects
mock.fetch.side_effect = ValueError("API down")
# mock.fetch()   # Raises ValueError!

mock.process.side_effect = [1, 2, 3]    # Return different values each call
assert mock.process() == 1
assert mock.process() == 2
assert mock.process() == 3

# ---- Assertions on calls ----
mock = Mock()
mock.save("Sid", age=25)

mock.save.assert_called_once()
mock.save.assert_called_with("Sid", age=25)
mock.save.assert_called_once_with("Sid", age=25)
assert mock.save.call_count == 1
assert mock.save.call_args == (("Sid",), {"age": 25})
```

### MagicMock (Mock with magic methods)
```python
from unittest.mock import MagicMock

# MagicMock supports __len__, __iter__, __str__, etc.
mock = MagicMock()
mock.__len__.return_value = 5
assert len(mock) == 5

mock.__iter__.return_value = iter([1, 2, 3])
assert list(mock) == [1, 2, 3]

mock.__str__.return_value = "MockObject"
assert str(mock) == "MockObject"

# Context manager
mock.__enter__.return_value = "resource"
with mock as m:
    assert m == "resource"
```

### `patch` ‚Äî The Most Important Tool
```python
from unittest.mock import patch

# ---- Patch as decorator ----
# services.py
import requests

def get_user(user_id):
    response = requests.get(f"https://api.example.com/users/{user_id}")
    return response.json()

# test_services.py
@patch("services.requests.get")    # Patch WHERE it's USED, not where defined!
def test_get_user(mock_get):
    # Configure the mock
    mock_response = Mock()
    mock_response.json.return_value = {"id": 1, "name": "Sid"}
    mock_get.return_value = mock_response
    
    # Call the function
    result = get_user(1)
    
    # Assertions
    assert result == {"id": 1, "name": "Sid"}
    mock_get.assert_called_once_with("https://api.example.com/users/1")

# ---- Patch as context manager ----
def test_get_user_v2():
    with patch("services.requests.get") as mock_get:
        mock_get.return_value.json.return_value = {"id": 1, "name": "Sid"}
        result = get_user(1)
        assert result["name"] == "Sid"

# ---- Patch multiple things ----
@patch("services.requests.get")
@patch("services.cache.get")
def test_with_cache(mock_cache, mock_requests):    # Reverse order!
    mock_cache.return_value = None    # Cache miss
    mock_requests.return_value.json.return_value = {"id": 1}
    result = get_user(1)
    assert result["id"] == 1
```

### Patching Patterns for Backend
```python
# ---- Mock Database ----
@patch("services.user_service.db")
def test_create_user(mock_db):
    mock_db.session.add = Mock()
    mock_db.session.commit = Mock()
    
    user = create_user("Sid", "sid@test.com")
    
    mock_db.session.add.assert_called_once()
    mock_db.session.commit.assert_called_once()

# ---- Mock External API ----
@patch("services.payment.requests.post")
def test_process_payment(mock_post):
    mock_post.return_value = Mock(
        status_code=200,
        json=lambda: {"txn_id": "T123", "status": "success"}
    )
    
    result = process_payment(amount=1500)
    assert result["status"] == "success"

# ---- Mock datetime ----
from datetime import datetime

@patch("services.user_service.datetime")
def test_user_created_at(mock_dt):
    mock_dt.now.return_value = datetime(2026, 2, 28, 12, 0, 0)
    user = create_user("Sid")
    assert user.created_at == datetime(2026, 2, 28, 12, 0, 0)

# ---- AsyncMock (for async functions) ----
from unittest.mock import AsyncMock

@patch("services.user_service.fetch_user", new_callable=AsyncMock)
async def test_async_fetch(mock_fetch):
    mock_fetch.return_value = {"id": 1, "name": "Sid"}
    result = await fetch_user(1)
    assert result["name"] == "Sid"
```

### patch.object & patch.dict
```python
# ---- patch.object ‚Äî patch a method on a specific object ----
class UserService:
    def get_user(self, id):
        # Real DB call
        ...

def test_get_user():
    service = UserService()
    with patch.object(service, "get_user", return_value={"name": "Sid"}):
        result = service.get_user(1)
        assert result["name"] == "Sid"

# ---- patch.dict ‚Äî patch a dictionary ----
import os

@patch.dict(os.environ, {"API_KEY": "test-key", "DEBUG": "true"})
def test_with_env_vars():
    assert os.environ["API_KEY"] == "test-key"
    assert os.environ["DEBUG"] == "true"
```

---

## 8. Test Coverage (`pytest-cov`)

Measure how much of your code is tested.

```bash
# Install
pip install pytest-cov

# Run with coverage
pytest --cov=src                           # Cover src/ directory
pytest --cov=src --cov-report=html         # HTML report
pytest --cov=src --cov-report=term-missing # Show uncovered lines
pytest --cov=src --cov-fail-under=80       # Fail if < 80% coverage
```

### Output Example
```
----------- coverage: platform darwin, python 3.11 -----------
Name                      Stmts   Miss  Cover   Missing
---------------------------------------------------------
src/models/user.py           45      3    93%   22, 35-36
src/services/auth.py         78     12    85%   45-49, 67-72
src/utils/helpers.py         23      0   100%
---------------------------------------------------------
TOTAL                       146     15    90%
```

### pyproject.toml Config
```toml
[tool.pytest.ini_options]
addopts = "--cov=src --cov-report=term-missing --cov-fail-under=80"
testpaths = ["tests"]

[tool.coverage.run]
source = ["src"]
omit = [
    "*/tests/*",
    "*/migrations/*",
    "*/__init__.py",
]

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "if __name__ == .__main__.",
    "if TYPE_CHECKING:",
    "raise NotImplementedError",
]
```

### What to Cover
```
‚úÖ Cover: Business logic, API endpoints, utilities, error paths
‚ùå Don't chase 100%: Config files, abstract methods, type hints

80-90% coverage is a good target for most projects.
Focus on meaningful tests, not coverage numbers!
```

---

## 9. Test-Driven Development (TDD) Mindset

Write tests FIRST, then code.

### The TDD Cycle: Red ‚Üí Green ‚Üí Refactor
```
1. RED    ‚Äî Write a failing test
2. GREEN  ‚Äî Write minimum code to pass
3. REFACTOR ‚Äî Clean up, keep tests green
4. REPEAT
```

### TDD Example: User Registration
```python
# -------- Step 1: RED ‚Äî Write failing test --------
# test_auth.py
def test_register_user(client):
    response = client.post("/register", json={
        "name": "Sid",
        "email": "sid@test.com",
        "password": "strong_password_123"
    })
    assert response.status_code == 201
    assert response.json()["name"] == "Sid"
    assert "id" in response.json()
    assert "password" not in response.json()    # Don't leak password!

# Run: pytest ‚Üí FAILS (no endpoint exists yet)

# -------- Step 2: GREEN ‚Äî Write minimum code --------
# routes/auth.py
@router.post("/register", status_code=201)
def register(data: RegisterSchema):
    user = User(name=data.name, email=data.email)
    user.set_password(data.password)
    db.session.add(user)
    db.session.commit()
    return {"id": user.id, "name": user.name, "email": user.email}

# Run: pytest ‚Üí PASSES ‚úÖ

# -------- Step 3: REFACTOR --------
# Add more edge case tests, clean up code
def test_register_duplicate_email(client):
    client.post("/register", json={...})    # First registration
    response = client.post("/register", json={...})    # Same email
    assert response.status_code == 409
    assert "already exists" in response.json()["detail"]

def test_register_weak_password(client):
    response = client.post("/register", json={
        "name": "Sid",
        "email": "sid@test.com",
        "password": "123"    # Too weak
    })
    assert response.status_code == 422
```

### TDD Benefits for Backend
```
‚úÖ Forces you to think about API design BEFORE coding
‚úÖ Catches bugs before they reach production
‚úÖ Makes refactoring safe ‚Äî tests catch regressions
‚úÖ Acts as living documentation
‚úÖ Builds confidence in deployments
```

### Test Organization Best Practice
```
project/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py          # Shared fixtures
‚îÇ   ‚îú‚îÄ‚îÄ unit/                # Fast, isolated
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_models.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test_services.py
‚îÇ   ‚îú‚îÄ‚îÄ integration/         # Tests with DB, APIs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test_api.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test_database.py
‚îÇ   ‚îî‚îÄ‚îÄ e2e/                 # Full workflow tests
‚îÇ       ‚îî‚îÄ‚îÄ test_workflows.py
‚îú‚îÄ‚îÄ pytest.ini
‚îî‚îÄ‚îÄ pyproject.toml
```

### Testing Pyramid
```
        /\
       /  \     E2E Tests (few, slow, expensive)
      /    \    
     /------\
    /        \   Integration Tests (moderate)
   /          \  
  /------------\
 /              \ Unit Tests (many, fast, cheap) ‚úÖ
/________________\

Aim for: 70% Unit | 20% Integration | 10% E2E
```

---

## üîó Quick Reference

```python
# ---- pytest basics ----
def test_something():
    assert result == expected
    assert value in collection
    with pytest.raises(ValueError):
        bad_function()

# ---- Fixtures ----
@pytest.fixture
def data():
    return {"key": "value"}
def test_it(data):    # Auto-injected
    assert data["key"] == "value"

# ---- Parametrize ----
@pytest.mark.parametrize("input,expected", [(1,1), (2,4)])
def test_square(input, expected):
    assert input**2 == expected

# ---- Markers ----
@pytest.mark.slow
@pytest.mark.skip(reason="WIP")
@pytest.mark.xfail

# ---- Mocking ----
from unittest.mock import patch, Mock
@patch("module.dependency")
def test_it(mock_dep):
    mock_dep.return_value = "fake"

# ---- Coverage ----
# pytest --cov=src --cov-report=term-missing

# ---- TDD: Red ‚Üí Green ‚Üí Refactor ----
```

### Common pytest Commands
```bash
pytest                              # Run all
pytest -v                           # Verbose
pytest -x                           # Stop on first fail
pytest -k "test_login"              # Name matching
pytest -m "not slow"                # Marker filtering
pytest --cov=src                    # With coverage
pytest --lf                         # Rerun last failed
pytest --ff                         # Failed first
pytest -n auto                      # Parallel (pytest-xdist)
```

---

> üìù **Next up**: 8.2 Integration & API Testing ‚Äî test clients, factory_boy, faker, locust
