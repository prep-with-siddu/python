# 8.2 Integration & API Testing ‚Äî Notes

> **Status**: ‚úÖ Completed  
> **Date**: 28 February 2026

---

## 1. Testing APIs with `pytest` + Framework Test Clients

### FastAPI Test Client
```python
# pip install httpx  (FastAPI uses httpx for testing)
from fastapi import FastAPI
from fastapi.testclient import TestClient

app = FastAPI()

@app.get("/users/{user_id}")
def get_user(user_id: int):
    return {"id": user_id, "name": "Sid"}

@app.post("/users", status_code=201)
def create_user(data: dict):
    return {"id": 1, **data}

# ---- Tests ----
client = TestClient(app)

def test_get_user():
    response = client.get("/users/1")
    assert response.status_code == 200
    assert response.json() == {"id": 1, "name": "Sid"}

def test_create_user():
    response = client.post("/users", json={"name": "Rahul", "age": 22})
    assert response.status_code == 201
    assert response.json()["name"] == "Rahul"

def test_user_not_found():
    response = client.get("/users/999")
    assert response.status_code == 404

# ---- With Fixtures (conftest.py) ----
import pytest

@pytest.fixture
def client():
    return TestClient(app)

@pytest.fixture
def auth_headers(client):
    resp = client.post("/login", json={"email": "sid@test.com", "password": "pass"})
    token = resp.json()["token"]
    return {"Authorization": f"Bearer {token}"}

def test_protected(client, auth_headers):
    response = client.get("/profile", headers=auth_headers)
    assert response.status_code == 200
```

### Flask Test Client
```python
import pytest
from app import create_app

@pytest.fixture
def app():
    app = create_app({"TESTING": True, "SQLALCHEMY_DATABASE_URI": "sqlite://"})
    yield app

@pytest.fixture
def client(app):
    return app.test_client()

def test_index(client):
    response = client.get("/")
    assert response.status_code == 200

def test_create_user(client):
    response = client.post("/users", json={"name": "Sid"})
    assert response.status_code == 201
    assert b"Sid" in response.data
```

### Django Test Client
```python
from django.test import TestCase, Client

class UserAPITest(TestCase):
    def setUp(self):
        self.client = Client()
    
    def test_get_users(self):
        response = self.client.get("/api/users/")
        self.assertEqual(response.status_code, 200)
    
    def test_create_user(self):
        response = self.client.post(
            "/api/users/",
            data={"name": "Sid", "email": "sid@test.com"},
            content_type="application/json"
        )
        self.assertEqual(response.status_code, 201)
```

---

## 2. Testing Database Operations

### SQLAlchemy with pytest (Transaction Rollback Pattern)
```python
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import Session
from app.models import Base, User

@pytest.fixture(scope="session")
def engine():
    """Create test database engine once."""
    engine = create_engine("sqlite:///:memory:")
    Base.metadata.create_all(engine)
    yield engine
    Base.metadata.drop_all(engine)

@pytest.fixture(scope="function")
def db_session(engine):
    """Each test gets a fresh session with auto-rollback."""
    connection = engine.connect()
    transaction = connection.begin()
    session = Session(bind=connection)
    
    yield session
    
    session.close()
    transaction.rollback()     # Undo ALL changes after each test!
    connection.close()

# ---- Test CRUD operations ----
def test_create_user(db_session):
    user = User(name="Sid", email="sid@test.com")
    db_session.add(user)
    db_session.commit()
    
    result = db_session.query(User).filter_by(name="Sid").first()
    assert result is not None
    assert result.email == "sid@test.com"

def test_update_user(db_session):
    user = User(name="Sid", email="old@test.com")
    db_session.add(user)
    db_session.commit()
    
    user.email = "new@test.com"
    db_session.commit()
    
    result = db_session.query(User).filter_by(name="Sid").first()
    assert result.email == "new@test.com"

def test_delete_user(db_session):
    user = User(name="Sid", email="sid@test.com")
    db_session.add(user)
    db_session.commit()
    
    db_session.delete(user)
    db_session.commit()
    
    result = db_session.query(User).filter_by(name="Sid").first()
    assert result is None

# Each test starts with a CLEAN database thanks to rollback!
```

### Testing with Async DB (asyncpg / SQLAlchemy async)
```python
import pytest
import pytest_asyncio
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession

@pytest_asyncio.fixture
async def async_session():
    engine = create_async_engine("sqlite+aiosqlite:///:memory:")
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    
    async with AsyncSession(engine) as session:
        yield session
        await session.rollback()
    
    await engine.dispose()

@pytest.mark.asyncio
async def test_async_create_user(async_session):
    user = User(name="Sid", email="sid@test.com")
    async_session.add(user)
    await async_session.commit()
    
    result = await async_session.get(User, 1)
    assert result.name == "Sid"
```

---

## 3. Factory Pattern for Test Data (`factory_boy`)

Create realistic test objects without boilerplate.

```python
# pip install factory-boy
import factory
from app.models import User, Order, Address

# ---- Define Factories ----
class UserFactory(factory.Factory):
    class Meta:
        model = User
    
    name = factory.Faker("name")
    email = factory.Faker("email")
    age = factory.Faker("random_int", min=18, max=65)
    is_active = True

class AddressFactory(factory.Factory):
    class Meta:
        model = Address
    
    street = factory.Faker("street_address")
    city = factory.Faker("city")
    state = factory.Faker("state")
    pin_code = factory.Faker("postcode")

class OrderFactory(factory.Factory):
    class Meta:
        model = Order
    
    user = factory.SubFactory(UserFactory)       # Creates a User too!
    total = factory.Faker("pydecimal", left_digits=4, right_digits=2, positive=True)
    status = factory.Faker("random_element", elements=["pending", "shipped", "delivered"])

# ---- Usage in Tests ----
def test_user_creation():
    user = UserFactory()
    assert user.name            # Random realistic name
    assert "@" in user.email    # Valid-looking email
    assert 18 <= user.age <= 65

def test_user_with_overrides():
    user = UserFactory(name="Sid", age=25)    # Override specific fields
    assert user.name == "Sid"
    assert user.age == 25

def test_batch_creation():
    users = UserFactory.build_batch(10)    # 10 users (not saved to DB)
    assert len(users) == 10

def test_order_with_user():
    order = OrderFactory()
    assert order.user.name      # User auto-created!
    assert order.total > 0
```

### SQLAlchemy Integration
```python
class UserFactory(factory.alchemy.SQLAlchemyModelFactory):
    class Meta:
        model = User
        sqlalchemy_session = None    # Set in conftest
    
    name = factory.Faker("name")
    email = factory.Sequence(lambda n: f"user{n}@test.com")    # Unique!
    age = 25

# conftest.py
@pytest.fixture(autouse=True)
def set_session(db_session):
    UserFactory._meta.sqlalchemy_session = db_session
    OrderFactory._meta.sqlalchemy_session = db_session

def test_db_user(db_session):
    user = UserFactory()           # Auto-saved to DB!
    assert db_session.query(User).count() == 1
```

### Factory Patterns
```python
# ---- Sequence (unique values) ----
class UserFactory(factory.Factory):
    class Meta:
        model = User
    email = factory.Sequence(lambda n: f"user{n}@test.com")
    # user0@test.com, user1@test.com, user2@test.com ...

# ---- LazyAttribute (computed) ----
class UserFactory(factory.Factory):
    class Meta:
        model = User
    name = factory.Faker("name")
    slug = factory.LazyAttribute(lambda obj: obj.name.lower().replace(" ", "-"))

# ---- Traits (variations) ----
class UserFactory(factory.Factory):
    class Meta:
        model = User
    
    name = "Sid"
    is_admin = False
    is_active = True
    
    class Params:
        admin = factory.Trait(is_admin=True, name="Admin User")
        inactive = factory.Trait(is_active=False)

admin = UserFactory(admin=True)        # is_admin=True, name="Admin User"
inactive = UserFactory(inactive=True)  # is_active=False
```

---

## 4. `faker` for Generating Fake Data

```python
# pip install faker
from faker import Faker

fake = Faker()
fake = Faker("en_IN")    # Indian locale!

# ---- Personal ----
fake.name()               # "Rahul Sharma"
fake.first_name()         # "Sid"
fake.last_name()          # "Rameshwar"
fake.email()              # "sid@example.com"
fake.phone_number()       # "+91 9876543210"

# ---- Address ----
fake.address()            # Full address
fake.city()               # "Bangalore"
fake.state()              # "Karnataka"
fake.postcode()           # "560001"
fake.country()            # "India"

# ---- Internet ----
fake.url()                # "https://example.com"
fake.ipv4()               # "192.168.1.1"
fake.user_agent()         # "Mozilla/5.0 ..."
fake.uuid4()              # "a1b2c3d4-..."

# ---- Text ----
fake.text()               # Lorem ipsum paragraph
fake.sentence()           # One sentence
fake.word()               # Random word
fake.paragraph()          # Full paragraph

# ---- Finance ----
fake.pricetag()           # "$1,234.56"
fake.credit_card_number() # "4111111111111111"
fake.cryptocurrency()     # ('BTC', 'Bitcoin')

# ---- Date/Time ----
fake.date_this_year()     # Date in current year
fake.date_time()          # Random datetime
fake.iso8601()            # "2026-02-28T12:00:00"

# ---- Seed for reproducibility ----
Faker.seed(42)
fake.name()               # Always same result with seed 42

# ---- Bulk generation ----
users = [{"name": fake.name(), "email": fake.email()} for _ in range(100)]
```

---

## 5. `httpx` for Async Testing

```python
import pytest
import httpx
from httpx import AsyncClient, ASGITransport
from app.main import app    # FastAPI app

# ---- Async test client ----
@pytest.fixture
async def async_client():
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as client:
        yield client

@pytest.mark.asyncio
async def test_get_users(async_client):
    response = await async_client.get("/users")
    assert response.status_code == 200
    assert isinstance(response.json(), list)

@pytest.mark.asyncio
async def test_create_user(async_client):
    response = await async_client.post("/users", json={
        "name": "Sid",
        "email": "sid@test.com"
    })
    assert response.status_code == 201
    data = response.json()
    assert data["name"] == "Sid"

# ---- Test async endpoints with DB ----
@pytest.mark.asyncio
async def test_full_crud(async_client):
    # Create
    resp = await async_client.post("/users", json={"name": "Sid"})
    user_id = resp.json()["id"]
    
    # Read
    resp = await async_client.get(f"/users/{user_id}")
    assert resp.json()["name"] == "Sid"
    
    # Update
    resp = await async_client.put(f"/users/{user_id}", json={"name": "Updated"})
    assert resp.json()["name"] == "Updated"
    
    # Delete
    resp = await async_client.delete(f"/users/{user_id}")
    assert resp.status_code == 204
```

---

## 6. Load Testing with `locust`

Test how your API handles heavy traffic.

```python
# pip install locust
# locustfile.py
from locust import HttpUser, task, between

class WebUser(HttpUser):
    wait_time = between(1, 3)    # Wait 1-3 sec between tasks
    
    def on_start(self):
        """Login when user starts."""
        response = self.client.post("/login", json={
            "email": "test@test.com",
            "password": "password123"
        })
        self.token = response.json()["token"]
        self.headers = {"Authorization": f"Bearer {self.token}"}
    
    @task(3)    # Weight: 3x more likely than weight-1 tasks
    def get_users(self):
        self.client.get("/users", headers=self.headers)
    
    @task(1)
    def create_user(self):
        self.client.post("/users", 
            json={"name": "Load Test User"},
            headers=self.headers
        )
    
    @task(2)
    def get_orders(self):
        self.client.get("/orders", headers=self.headers)

# Another user type (different behavior)
class AdminUser(HttpUser):
    wait_time = between(2, 5)
    
    @task
    def admin_dashboard(self):
        self.client.get("/admin/dashboard")
```

```bash
# Run
locust -f locustfile.py --host=http://localhost:8000

# Opens web UI at http://localhost:8089
# Set: Number of users, Spawn rate, then click Start!

# Headless mode (CI/CD)
locust -f locustfile.py --host=http://localhost:8000 \
    --users 100 --spawn-rate 10 --run-time 60s --headless
```

### What Locust Measures
```
‚úÖ Requests per second (RPS)
‚úÖ Response times (avg, median, p95, p99)
‚úÖ Failure rate
‚úÖ Concurrent users handling capacity
```

---

## 7. End-to-End Testing Concepts

Tests the **entire system** from user perspective ‚Äî DB, APIs, external services, everything.

```python
# ---- E2E: Full user registration ‚Üí login ‚Üí action flow ----
def test_full_user_journey(client):
    # 1. Register
    resp = client.post("/register", json={
        "name": "Sid",
        "email": "sid@test.com",
        "password": "Str0ng_Pass!"
    })
    assert resp.status_code == 201
    user_id = resp.json()["id"]
    
    # 2. Login
    resp = client.post("/login", json={
        "email": "sid@test.com",
        "password": "Str0ng_Pass!"
    })
    assert resp.status_code == 200
    token = resp.json()["token"]
    headers = {"Authorization": f"Bearer {token}"}
    
    # 3. Create order
    resp = client.post("/orders", json={
        "items": [{"product_id": 1, "qty": 2}]
    }, headers=headers)
    assert resp.status_code == 201
    order_id = resp.json()["id"]
    
    # 4. Check order
    resp = client.get(f"/orders/{order_id}", headers=headers)
    assert resp.status_code == 200
    assert resp.json()["status"] == "pending"
    
    # 5. Cancel order
    resp = client.post(f"/orders/{order_id}/cancel", headers=headers)
    assert resp.status_code == 200
    assert resp.json()["status"] == "cancelled"

# ---- E2E with database verification ----
def test_payment_flow(client, db_session):
    # ... API calls ...
    
    # Verify DB state directly
    order = db_session.query(Order).filter_by(id=order_id).first()
    assert order.payment_status == "completed"
    assert order.total == 1500.0
```

### E2E Best Practices
```
‚úÖ Test critical user flows (sign up, checkout, payment)
‚úÖ Use real (test) database ‚Äî not mocks
‚úÖ Keep E2E tests few but meaningful
‚ùå Don't test every edge case in E2E ‚Äî that's unit test job
‚ùå Don't mock external services in E2E (use test/sandbox environments)
```

---

## 8. `pytest-asyncio` for Async Tests

```python
# pip install pytest-asyncio
import pytest
import asyncio

# ---- Mark individual tests ----
@pytest.mark.asyncio
async def test_async_function():
    result = await some_async_function()
    assert result == "expected"

# ---- Async fixtures ----
import pytest_asyncio

@pytest_asyncio.fixture
async def async_resource():
    resource = await create_resource()
    yield resource
    await resource.close()

@pytest.mark.asyncio
async def test_with_resource(async_resource):
    result = await async_resource.fetch()
    assert result is not None

# ---- Auto mode (all tests are async) ----
# pyproject.toml
# [tool.pytest.ini_options]
# asyncio_mode = "auto"

# Then no need for @pytest.mark.asyncio!
async def test_auto_async():
    await asyncio.sleep(0.1)
    assert True

# ---- Testing async generators ----
@pytest.mark.asyncio
async def test_async_generator():
    results = []
    async for item in async_data_stream():
        results.append(item)
    assert len(results) == 10
```

---

## 9. Snapshot Testing

Compare output against saved "snapshots" ‚Äî great for API responses.

```python
# pip install syrupy (recommended) or pytest-snapshot

# ---- With syrupy ----
def test_user_response(client, snapshot):
    response = client.get("/users/1")
    assert response.json() == snapshot
    
    # First run: creates snapshot file automatically
    # Next runs: compares against saved snapshot
    # Update: pytest --snapshot-update

# ---- Manual snapshot testing ----
import json

def test_api_response_shape(client):
    response = client.get("/users/1")
    data = response.json()
    
    # Assert structure (not exact values)
    assert "id" in data
    assert "name" in data
    assert "email" in data
    assert isinstance(data["id"], int)
    assert isinstance(data["name"], str)

# ---- Snapshot for complex objects ----
def test_order_summary(client, snapshot):
    response = client.get("/orders/summary")
    # Snapshot ignores dynamic fields
    result = response.json()
    result.pop("created_at", None)    # Remove dynamic timestamp
    assert result == snapshot
```

```bash
# Update snapshots when output intentionally changes
pytest --snapshot-update
```

---

## 10. Contract Testing (API Contract Between Services)

Ensure API producer and consumer agree on the interface.

```python
# ---- Using schemathesis (auto-test from OpenAPI spec) ----
# pip install schemathesis

# Command line:
# schemathesis run http://localhost:8000/openapi.json

# ---- Programmatic ----
import schemathesis

schema = schemathesis.from_url("http://localhost:8000/openapi.json")

@schema.parametrize()
def test_api_contract(case):
    """Auto-generates test cases from your OpenAPI spec!"""
    response = case.call()
    case.validate_response(response)
    # Checks: status codes, response schemas, content types

# ---- Manual Contract Testing ----
def test_user_response_contract():
    """Verify response matches expected contract."""
    response = client.get("/users/1")
    data = response.json()
    
    # Contract: required fields
    required_fields = {"id", "name", "email", "created_at"}
    assert required_fields.issubset(data.keys())
    
    # Contract: field types
    assert isinstance(data["id"], int)
    assert isinstance(data["name"], str)
    assert isinstance(data["email"], str)
    
    # Contract: no extra sensitive fields
    assert "password" not in data
    assert "secret_key" not in data

# ---- Pact (Consumer-Driven Contracts) ----
# pip install pact-python
# Consumer defines what it expects ‚Üí provider verifies it matches
# Great for microservices!
```

### When to Use Contract Testing
```
‚úÖ Microservices communicating via APIs
‚úÖ Frontend consuming your backend API
‚úÖ Third-party integrations
‚úÖ API versioning ‚Äî ensure v2 doesn't break v1 consumers
```

---

## 11. `responses` / `respx` for Mocking HTTP Calls

### `responses` (for `requests` library)
```python
# pip install responses
import responses
import requests

@responses.activate
def test_external_api():
    # Register mock response
    responses.add(
        responses.GET,
        "https://api.example.com/users/1",
        json={"id": 1, "name": "Sid"},
        status=200,
    )
    
    # Your code makes a real requests.get() call ‚Äî but gets mock response!
    response = requests.get("https://api.example.com/users/1")
    assert response.json()["name"] == "Sid"
    
    # Verify the call was made
    assert len(responses.calls) == 1
    assert responses.calls[0].request.url == "https://api.example.com/users/1"

@responses.activate
def test_api_failure():
    responses.add(
        responses.GET,
        "https://api.example.com/users/1",
        json={"error": "not found"},
        status=404,
    )
    
    response = requests.get("https://api.example.com/users/1")
    assert response.status_code == 404

@responses.activate
def test_api_timeout():
    responses.add(
        responses.GET,
        "https://api.example.com/slow",
        body=requests.exceptions.Timeout(),
    )
    
    with pytest.raises(requests.exceptions.Timeout):
        requests.get("https://api.example.com/slow")

# ---- Multiple responses (different each call) ----
@responses.activate
def test_retry_logic():
    responses.add(responses.GET, url, status=500)    # 1st call: fail
    responses.add(responses.GET, url, status=500)    # 2nd call: fail
    responses.add(responses.GET, url, json={"ok": True}, status=200)  # 3rd: success
    
    result = fetch_with_retry(url)    # Your retry logic
    assert result["ok"] == True
    assert len(responses.calls) == 3
```

### `respx` (for `httpx` / async)
```python
# pip install respx
import respx
import httpx

# ---- Sync ----
@respx.mock
def test_httpx_call():
    respx.get("https://api.example.com/users/1").respond(
        json={"id": 1, "name": "Sid"},
        status_code=200,
    )
    
    response = httpx.get("https://api.example.com/users/1")
    assert response.json()["name"] == "Sid"

# ---- Async ----
@respx.mock
@pytest.mark.asyncio
async def test_async_httpx():
    respx.get("https://api.example.com/data").respond(
        json={"count": 42}
    )
    
    async with httpx.AsyncClient() as client:
        response = await client.get("https://api.example.com/data")
    
    assert response.json()["count"] == 42

# ---- Pattern matching ----
@respx.mock
def test_pattern_mock():
    # Mock any URL matching pattern
    respx.get(url__startswith="https://api.example.com/").respond(
        json={"mocked": True}
    )
    
    r1 = httpx.get("https://api.example.com/users")
    r2 = httpx.get("https://api.example.com/orders")
    assert r1.json()["mocked"] == True
    assert r2.json()["mocked"] == True

# ---- Side effects ----
@respx.mock
def test_side_effect():
    respx.get("https://api.example.com/error").mock(
        side_effect=httpx.ConnectError
    )
    
    with pytest.raises(httpx.ConnectError):
        httpx.get("https://api.example.com/error")
```

### responses vs respx

| Feature | responses | respx |
|---------|-----------|-------|
| For | `requests` library | `httpx` library |
| Async | ‚ùå | ‚úÖ |
| FastAPI testing | No | Yes ‚úÖ |
| Pattern matching | Basic | Advanced ‚úÖ |
| Use when | Flask / sync code | FastAPI / async code |

---

## üîó Quick Reference

```python
# ---- Test Client (FastAPI) ----
from fastapi.testclient import TestClient
client = TestClient(app)
resp = client.get("/users")
resp = client.post("/users", json={...})

# ---- DB Testing (rollback) ----
@pytest.fixture
def db(engine):
    session = Session(engine)
    yield session
    session.rollback()

# ---- factory_boy ----
class UserFactory(factory.Factory):
    class Meta:
        model = User
    name = factory.Faker("name")
user = UserFactory(name="Sid")    # Override

# ---- faker ----
from faker import Faker
fake = Faker("en_IN")
fake.name()  |  fake.email()  |  fake.address()

# ---- pytest-asyncio ----
@pytest.mark.asyncio
async def test_async():
    result = await async_function()
    assert result

# ---- Mock HTTP (sync) ----
@responses.activate
def test_api():
    responses.add(responses.GET, url, json={...})

# ---- Mock HTTP (async) ----
@respx.mock
async def test_api():
    respx.get(url).respond(json={...})

# ---- Load testing ----
# locust -f locustfile.py --host=http://localhost:8000
```

### Test Strategy Summary
```
Unit Tests (8.1)          ‚Üí Mock everything, test logic
Integration Tests (8.2)   ‚Üí Real DB, test client, mock externals
E2E Tests                 ‚Üí Real everything, test flows
Load Tests (locust)       ‚Üí Test performance under pressure
Contract Tests            ‚Üí Verify API agreements
```

---

> üìù **Phase 8 Complete!** Next: Phase 9 ‚Äî Git, CI/CD & Code Quality
